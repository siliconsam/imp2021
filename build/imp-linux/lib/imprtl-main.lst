         Edinburgh IMP77 Compiler - Version 8.4

   1  
   2      ! Trick to remember the pointer to the command line parameters
   3      %own %integer %name arguments
   4      ! Trick to remember the pointer to the environment variables
   5      %own %integer %name environs
   6  
   7      ! There are 2 forms of IMP program
   8      ! Type 1: %begin ... %end
   9      ! Type 2: %external %routine XXX %alias "__impmain" ... %end
   10      !
   11      ! Both types of IMP "program" are compiled as an external routine,
   12      ! where the external entry symbol is "__impmain"
   13      !
   14      ! To ensure both types use a single runt-time library
   15      ! an intermediate "wrapper" routine "SELECTIMPTYPE" is used
   16      %external %routine %spec impmain %alias "__impmain"
   17  
   18      %external %integer %function %spec split io list ( %string(255) io list )
   19      %external %routine %spec initialise io
   20      %external %routine %spec terminate io
   21  
   22      ! This acts as a "wrapper" routine around the "__impmain" routine
   23      ! Forward declarations (just to ensure routine trap tables follow in order)
   24      %routine %spec selectimptype
   25  
   26      ! IMP main has the parameters in reverse order to the C main
   27      ! define main so that the environment variables can be accessed
   28      ! The external symbol name "_main" (or "main" for Unix/Linux) is used
   29      ! to ensure IMP programs can be used in Windows/Unix/Linux environments
   30      ! that provide a c interface
   31      %external %routine StartImp %alias "main" (%integer %name envp, %integer %name argv, %integer argc )
   32  
   33          %on %event 6,9,10 %start
   34              %integer eventno, sub, info
   35              %string(255) msg
   36  
   37              eventno = event_event
   38              sub = event_sub
   39              info = event_info
   40              msg = event_message
   41  
   42              debugnewline
   43              debugstring( "**** Arrgh! Last chance event handler has been triggered." );debugnewline
   44              debugstring( "**** Triggered by error event (".itos(eventno,0).",".itos(sub,0).",".itos(info,0)."). Error message '".msg."'" );debugnewline
   45  
   46              %if eventno=6 %and sub = 2 %and info = 1 %start
   47                  debugstring("**** Error likely caused by missing command line parameters for input/output file(s)");debug newline
   48              %finish
   49  
   50              %if eventno = 9 %start
   51                  %if (sub = 4) %start
   52                      debugstring("**** Error likely caused by missing/invalid command line parameters for input file(s)");debug newline
   53                  %finish
   54                  %if (sub = 5) %start
   55                      debugstring("**** Error likely caused by missing/invalid command line parameters for output files(s)");debug newline
   56                  %finish
   57              %finish
   58  
   59              %if eventno = 10 %start
   60                  debugstring("**** Error caused by missing/invalid command line parameter(s)");debug newline
   61              %finish
   62  
   63              debugnewline
   64  
   65              %stop
   66  
   67          %finish
   68  
   69          arguments == argv
   70          environs == envp
   71  
   72          ! Intialise the runtime system
   73          ! ass-u-me no debug required
   74          set debug level( 0 )
   75  
   76          %if (length( getenv( getenvindex( "IMP_DEBUG" ) ) ) # 0) %start
   77              ! ok, we want ALL debug levels
   78              set debug level ( 16_ffffffff )
   79          %finish
   80  
   81          initialise io
   82  
   83          ! ok, let's see which flavour of IMP program we have
   84          ! We defer selection of %external %routine XXX %alias "__impmain" IMP program type
   85          ! so that potentially extra ways of calling the compiler generated IMP program code
   86          ! can be implemented
   87          selectimptype
   88  
   89          ! don't forget to close down the I/O system
   90          terminateio
   91  
   92          ! Switch off all debug now we are about to exit
   93          set debug level ( 0 )
   94  
   95          ! If the IMP program exits through %endofprog then report success to the shell
   96          exit(0)
   97      %end
?ARGC unused
   98  
   99      ! Enable access to the environment variables
  100      ! Used by routines in "imprtl-system"
  101      %external %integer %name %function getenvironment
  102          %result == environs
  103      %end
  104  
  105      ! Enable access to the command line parameters
  106      ! Used by routines in "imprtl-system"
  107      %external %integer %name %function getarguments
  108          %result == arguments
  109      %end
  110  
  111      ! for a %begin ... %end IMP program, indicate the expected command line parameters
  112      %routine usage
  113          debugstring( "Usage: <imp program> [in1[,in2[,in3]]]".tostring(FILE SEP)."[out1[,out2[,out3]]] [debug]" )
  114          debug newline
  115          debugstring( "   NB: the '".tostring(FILE SEP)."' separates the input files from the output files" )
  116          debug newline
  117          debugstring( "   NB: debug triggers extra run time debug messages)" )
  118          debug newline
  119          debugstring( "   NB: For debug activation (even if there are no I/O files requested) the '".tostring(FILE SEP)."' is mandatory" )
  120          debug newline
  121          exit(1)
  122      %end
  123  
  124      ! Kludge to see if the program is a %begin .. %end block with file parameters
  125      %predicate runmode(%string(255) arg1)
  126          %string(255) s,a,b,c
  127  
  128          s = arg1
  129          length( a ) = 0
  130          b = tostring(FILE SEP)
  131          length( c ) = 0
  132  
  133          ! ok, now check to see if the first program parameter indicates a file list
  134          s->a.(b).c
  135  
  136          %false %if (s = a)        ;! no FILE SEP found
  137          %true %if (s = b)         ;! a FILE SEP found (but, no I/O files requested) could want to invoke debug?
  138          %true %if (length(a) > 0) ;! input files found
  139          %true %if (length(c) > 0) ;! output files found
  140  
  141          %false                    ;! it looks like this is not a %begin .. %end program
  142      %end
  143  
  144      ! This activates a %begin ... %end IMP program
  145      ! This is in a separate routine to allow future enhancements
  146      %routine imptype1
  147          %integer errcount = 0
  148          %integer argcount = getargcount
  149  
  150          ! Type 1 IMP PROGRAM?
  151          ! Ok, this is a suspected %begin ... %end IMP program
  152          ! set up the input and output streams
  153          ! argc = 1 param 0 == progname
  154          ! argc = 2 param 1 == input file list/output file list
  155          ! argc = 3 param 2 => we want debug mode (any value will do for the moment!)
  156  
  157          ! Possible enhancement is to disable access to the command line parameters
  158          ! if this type of IMP program is written.
  159          ! The only command line access possible would then be in this module
  160          %if (argcount > 1) %start
  161              ! Check we don't have too many parameters
  162              %if (argcount > 3) %start
  163                  usage
  164                  errcount = errcount + 1
  165              %finish %else %start
  166                  ! We may want to debug the I/O initialisation
  167                  ! if so, then uncomment the next line
  168  !                set debug level( debug mode ! DBGIO ! DBGPRIM )
  169                  %if (split io list( getarg(1) ) # 0) %then errcount = errcount + 1;
  170              %finish
  171          %finish
  172  
  173          %if (errcount = 0) %start
  174              ! check for debug mode
  175              %if (argcount > 2) %then set debug level( debug mode ! DBGMAIN ! DBGPROG ! DBGCORE )
  176  
  177              %if ((debug mode & DBGMAIN) # 0) %start
  178                  debug string( "IMPMAINX: About to enter the IMP program")
  179                  debug newline
  180              %finish
  181  
  182              ! ok, let's go IMPing!!
  183              impmain
  184  
  185              %if ((debug mode & DBGMAIN) # 0) %start
  186                  debug string( "IMPMAINX: Completed the IMP program")
  187                  debug newline
  188              %finish
  189          %finish
  190      %end
  191  
  192      ! This activates a suspected %external %routine XXX %alias "__impmain" ... %end IMP program
  193      ! This is in a separate routine to allow future enhancements
  194      %routine imptype2
  195  
  196          ! Type 2 IMP PROGRAM?
  197          ! Ok, this is a suspected %external %routine XXX %alias "__impmain" ... %end
  198          ! It is the IMP programmers responsibility to open files and read the command line
  199  
  200          %if ((debug mode & DBGMAIN) # 0) %start
  201              debug string( "IMPMAIN: About to enter the IMP program")
  202              debug newline
  203          %finish
  204  
  205          ! ok, let's go IMPing!!
  206          impmain
  207  
  208          %if ((debug mode & DBGMAIN) # 0) %start
  209              debug string( "IMPMAIN: Completed the IMP program")
  210              debug newline
  211          %finish
  212      %end
  213  
  214      %routine selectimptype
  215          %if runmode( getarg(1) ) %start
  216              ! Type 1 IMP PROGRAM?
  217              imptype1
  218          %finish %else %start
  219              ! Type 2 IMP PROGRAM?
  220              imptype2
  221          %finish
  222      %end
  223  
  224      ! External Library routines implemented in C
  225      ! N.B. These routines need an alias name referring to the actual C routine
  226      !      Also the alias name may need to be changed for different operating systems
  227      ! imprtl routines implemented in C to access C standard file handles,error status,write a double length real
  228      %external %routine     %spec prim exit            %alias "exit" ( %integer status )
  229      %external %integer %fn %spec prim geterr          %alias "geterrno"
  230      %external %integer %fn %spec prim geterrhandle    %alias "getstderr"
  231      %external %integer %fn %spec prim getinhandle     %alias "getstdin"
  232      %external %integer %fn %spec prim getouthandle    %alias "getstdout"
  233      %external %routine     %spec prim write double    %alias "fileputreal" ( %integer handle, %long %real d )
  234  
  235      %external %integer %fn %spec prim openfile        %alias "fopen" ( %integer mode address, %integer file name address )
  236      %external %integer %fn %spec prim tell            %alias "ftell" ( %integer handle )
  237      %external %routine     %spec prim file rewind     %alias "rewind" ( %integer handle )
  238      %external %routine     %spec prim file seek       %alias "fseek" ( %integer handle, displacement, pos )
  239      %external %routine     %spec prim close           %alias "fclose" ( %integer handle )
  240      %external %integer %fn %spec prim readbytes       %alias "fread" ( %integer handle, count, itemsz, %byte %name buffer )
  241      %external %integer %fn %spec prim writebytes      %alias "fwrite" ( %integer handle, count, itemsz,%byte %name buffer )
  242      %external %integer %fn %spec prim get char        %alias "fgetc" ( %integer handle )
  243      %external %routine     %spec prim put char        %alias "fputc" ( %integer handle,ch )
  244      %external %routine     %spec prim flush           %alias "fflush" ( %integer handle )
  245  
  246      %external %routine exit( %integer status )
  247          prim exit( status )
  248      %end
  249  
  250      %external %integer %fn get error
  251          %result = prim get err
  252      %end
  253  
  254      %external %integer %fn getstderrhandle
  255          %result = prim geterrhandle
  256      %end
  257  
  258      %external %integer %fn getstdinhandle
  259          %result = prim getinhandle
  260      %end
  261  
  262      %external %integer %fn getstdouthandle
  263          %result = prim getouthandle
  264      %end
  265  
  266      %external %routine put double( %integer handle, %long %real d )
  267          prim write double( handle, d )
  268      %end
  269  
  270      %external %integer %fn openfile ( %integer mode address, %integer file name address )
  271          %result = prim openfile( mode address, file name address )
  272      %end
  273  
  274      %external %integer %fn tell ( %integer handle )
  275          %result = prim tell( handle )
  276      %end
  277  
  278      %external %routine file rewind( %integer handle )
  279          prim file rewind( handle )
  280      %end
  281  
  282      %external %routine file seek ( %integer handle, displacement, pos )
  283          prim file seek( handle, displacement, pos )
  284      %end
  285  
  286      %external %routine close( %integer handle )
  287          prim close( handle )
  288      %end
  289  
  290      %external %integer %fn readbytes( %integer handle, count, itemsz, %byte %name buffer )
  291          %result = prim readbytes( handle, count, itemsz, buffer )
  292      %end
  293  
  294      %external %integer %fn writebytes( %integer handle, count, itemsz,%byte %name buffer )
  295          %result = prim writebytes( handle, count, itemsz, buffer )
  296      %end
  297  
  298      %external %integer %fn get char( %integer handle )
  299          %result = prim get char( handle )
  300      %end
  301  
  302      %external %routine put char( %integer handle,ch )
  303          prim put char( handle,ch )
  304      %end
  305  
  306      %external %routine flush( %integer handle )
  307          prim flush( handle )
  308      %end
  309  
  310  %endoffile

  190 Statements compiled
