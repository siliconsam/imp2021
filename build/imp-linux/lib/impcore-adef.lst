         Edinburgh IMP77 Compiler - Version 8.4

   1  
   2      %include "inc.386.registers"
 &  1  %endoflist
 & 10  %endoffile
   3  
   4  {-----------------------------------------------------------------------------}
   5      ! Dope vectors are integer arrays of form
   6      !      :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ArrayElementSize:
   7      !      increasing address -->
   8      !
   9      ! Given a dope vector calculate the offset (in bytes) of the
   10      ! highest element, and also the offset from A(0,...,0) of
   11      ! the first element - the size of the store to allocate is
   12      ! therefore the difference.  We return the two 32 bit answers
   13      ! with one result => "high" answer is in DX, "low" answer
   14      ! is in AX.  Thus DX contains the top, AX the A(0) offset
   15      ! The way we achieve this is compiler dependent, so we declare
   16      ! this as VOID and then do the return in-line
   17      %external %routine impadef ( %integer %name dvp )
   18          %constinteger addressSize = 4
   19          %integer szAddress,lbAddress,ubAddress
   20          %integer dim, sz
   21          %integer lb, ub, row
   22          %integer i, base, limit
   23  
   24          ! The count of array dimensions is located at addr(dvp)
   25          dim = dvp
   26  
   27          ! the element size is given after the last pair of lower,upper bounds
   28          szAddress = addr(dvp) + addressSize*(2*dim + 1)
   29  
   30          ! initialise the base "address" and limit "address"
   31          base = 0
   32          limit = 0
   33  
   34          ! General case iterates backwards toward first dimension
   35          ! last dim upper bound is just before the szAddress
   36          ubAddress = szAddress - addressSize
   37          ! a lower bound is always just before the upper bound
   38          lbAddress = ubAddress - addressSize
   39  
   40          ! Now, iterate over each pair of a dimensions bounds
   41          %for i=1,1,dim %cycle
   42              ! NB. at i=1, we point to the rightmost dimensions lower,upper bounds
   43              lb = integer( lbAddress )
   44              ub = integer( ubAddress )
   45  
   46              ! we declare array bounds so that lb <= ub
   47              %signal 5, 3, 0 %unless lb <= ub
   48  
   49              ! calculate the number of objects in a row
   50              ! NB we add one to avoid the fence post error
   51              row   = (ub - lb) + 1
   52              base  = base * row + lb
   53              limit = limit * row + ub
   54  
   55              ! now point to the lower, upper bounds of the next lower array dimension
   56              ubAddress = lbAddress - addressSize
   57              lbAddress = ubAddress - addressSize
   58          %repeat
   59  
   60          ! finally get the size of each array element
   61          sz = integer( szAddress )
   62  
   63          base = base * sz
   64          limit = (limit + 1) * sz
   65  
   66          *mov_ edx,limit
   67          *mov_ eax,base
   68  
   69          %return
   70      %end
   71  
   72  {-----------------------------------------------------------------------------}
   73  %endoffile

   35 Statements compiled
