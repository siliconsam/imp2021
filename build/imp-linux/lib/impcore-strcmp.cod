{------------------------------------------------------------------------------}
    ! strcmp returns a number comparable to the state of the
    ! strings (-1 = less than, 0 = equal, 1 = more than)
    %external %integer %function impstrcmp ( %byte %name l,r )
 0000                      L1000  EQU $
 0000 C8 00 00 01                     ENTER 0000,1
        %integer lcount, rcount, index
        %byte lx,rx

        lcount = l; ! pick up the counts
 0004 8B 75 0C                        MOV ESI,[EBP+12]
 0007 31 C0                           XOR EAX,EAX
 0009 8A 06                           MOV AL,[ESI]
 000B 89 45 F8                        MOV [EBP-8],EAX
        rcount = r;
 000E 8B 7D 08                        MOV EDI,[EBP+8]
 0011 31 C0                           XOR EAX,EAX
 0013 8A 07                           MOV AL,[EDI]
 0015 89 45 F4                        MOV [EBP-12],EAX

        index = 1
 0018 C7 45 F0 01 00 00 00            MOV WORD [EBP-16],1
        %while (lcount > 0) %and (rcount > 0) %cycle
 001F                      L1001  EQU $
 001F 8B 45 F8                        MOV EAX,[EBP-8]
 0022 3D 00 00 00 00                  CMP EAX,0
 0027 7E 00                           JLE L1002
 0029 8B 45 F4                        MOV EAX,[EBP-12]
 002C 3D 00 00 00 00                  CMP EAX,0
 0031 7E 00                           JLE L1002
            lx = byteinteger( addr( l ) + index ); ! get the address
                                      Generating CODE for 'ADDR' (MACRO 4)
                                      CALL 'ADDR' (MACRO 4)
 0033 8B 45 0C                        MOV EAX,[EBP+12]
 0036 03 45 F0                        ADD EAX,[EBP-16]
                                      Generating CODE for 'BYTE INTEGER' (MACRO 6)
                                      CALL 'BYTE INTEGER' (MACRO 6)
 0039 8A 08                           MOV CL,[EAX]
 003B 88 4D EF                        MOV [EBP-17],CL
            rx = byteinteger( addr( r ) + index ); ! get the address
                                      Generating CODE for 'ADDR' (MACRO 4)
                                      CALL 'ADDR' (MACRO 4)
 003E 8B 45 08                        MOV EAX,[EBP+8]
 0041 03 45 F0                        ADD EAX,[EBP-16]
                                      Generating CODE for 'BYTE INTEGER' (MACRO 6)
                                      CALL 'BYTE INTEGER' (MACRO 6)
 0044 8A 08                           MOV CL,[EAX]
 0046 88 4D EE                        MOV [EBP-18],CL

            %result =  1 %if (lx > rx)
 0049 31 C0                           XOR EAX,EAX
 004B 8A 45 EF                        MOV AL,[EBP-17]
 004E 31 C9                           XOR ECX,ECX
 0050 8A 4D EE                        MOV CL,[EBP-18]
 0053 39 C8                           CMP EAX,ECX
 0055 7E 00                           JLE L1003
 0057 B8 01 00 00 00                  MOV EAX,1
 005C C9                              LEAVE
 005D C3                              RET
 005E                      L1003  EQU $
            %result = -1 %if (rx > lx)
 005E 31 C0                           XOR EAX,EAX
 0060 8A 45 EE                        MOV AL,[EBP-18]
 0063 31 C9                           XOR ECX,ECX
 0065 8A 4D EF                        MOV CL,[EBP-17]
 0068 39 C8                           CMP EAX,ECX
 006A 7E 00                           JLE L1004
 006C B8 FF FF FF FF                  MOV EAX,-1
 0071 C9                              LEAVE
 0072 C3                              RET
 0073                      L1004  EQU $

            index = index + 1
 0073 FF 45 F0                        INC WORD [EBP-16]
            lcount = lcount - 1
 0076 FF 4D F8                        DEC WORD [EBP-8]
            rcount = rcount - 1
 0079 FF 4D F4                        DEC WORD [EBP-12]
        %repeat
 007C EB 00                           JMP L1001
 007E                      L1002  EQU $

        ! here we ran out of characters on one or both sides
        %result =  1 %if (lcount > 0)
 007E 8B 45 F8                        MOV EAX,[EBP-8]
 0081 3D 00 00 00 00                  CMP EAX,0
 0086 7E 00                           JLE L1005
 0088 B8 01 00 00 00                  MOV EAX,1
 008D C9                              LEAVE
 008E C3                              RET
 008F                      L1005  EQU $
        %result = -1 %if (rcount > 0)
 008F 8B 45 F4                        MOV EAX,[EBP-12]
 0092 3D 00 00 00 00                  CMP EAX,0
 0097 7E 00                           JLE L1006
 0099 B8 FF FF FF FF                  MOV EAX,-1
 009E C9                              LEAVE
 009F C3                              RET
 00A0                      L1006  EQU $

        ! if here, the strings are identical
        %result = 0
 00A0 31 C0                           XOR EAX,EAX
 00A2 C9                              LEAVE
 00A3 C3                              RET
    %end

{------------------------------------------------------------------------------}
%endoffile
      _TEXT  ENDS
      CONST  SEGMENT WORD PUBLIC 'CONST'
      CONST  ENDS
      _TEXT  SEGMENT WORD PUBLIC 'CODE'
            ENDS
      DATA  SEGMENT WORD PUBLIC 'DATA'
      DATA    ENDS
              ENDS
      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'
      _SWTAB   ENDS
