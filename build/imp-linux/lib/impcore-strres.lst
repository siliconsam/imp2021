         Edinburgh IMP77 Compiler - Version 8.4

   1  {------------------------------------------------------------------------------}
   2      ! IMP resolution - S->A.(B).C; returns 1 for success, 0 for failure
   3      %external %integer %function impstrres ( %byte %name c,b,a,s )
   4          %integer index, count, i
   5          %byte slen, alen, blen, clen
   6          %byte %name sx,ax,bx,cx
   7  
   8          ! Although s,a,b,c are declared equivalent to C format string arrays
   9          ! we can access a char at index i by x[i]
   10          ! However the string arrays are formatted as IMP strings
   11          ! Hence, x[0] contains the length of the string.
   12          ! And x[x[0] is therefore the last char in the IMP string.
   13          ! DANGER, IMP format string arrays are at most 256 chars (1 for length, 255 for actual string text)
   14          ! DANGER, DANGER. The compiler/programmer may have assigned a lesser size so beware overflow
   15  
   16          ! case 1:   S -> A.(B).C
   17          !  sub-case 1A: length(B) > length(S) => result = 0, A := S,       C := ""
   18          !  sub-case 1B: B not in S            => result = 0, A := S,       C := ""
   19          !  sub-case 1C: B in S                => result = 1, A := S\(B.C), C := S\(A.B)
   20      
   21          ! case 2:   S -> A.(B)
   22          !  sub-case 2A: length(B) > length(S) => result = 0, A := S
   23          !  sub-case 2B: B not in S            => result = 0, A := S
   24          !  sub-case 2C: B in S                => result = 1, A := S\B
   25  
   26          ! case 3:   S ->   (B).C
   27          !  sub-case 3A: length(B) > length(S) => result = 0,         C := ""
   28          !  sub-case 3B: B not in S            => result = 0,         C := ""
   29          !  sub-case 3C: B in S                => result = 1,         C := S\B
   30  
   31          ! General case S -> A.(B).C    (S,B inputs, A,C outputs)
   32          ! initialise:
   33          ! if addr(A) # 0 then A := S
   34          ! if addr(C) # 0 then C := ""
   35          ! case A: length(B) > length(S) => result = 0, if addr(A) # 0 then length(A) := length(S)
   36          ! case B: B not in S            => result = 0, if addr(A) # 0 then length(A) := length(S)
   37          ! case C: B in S                => result = 1, if addr(A) # 0 then length(A) := length(S) - length(B.C), if addr(C) # 0 then C := S\(A.B)
   38  
   39          ! Assume a == %string(255), c == %string(255)
   40          ! We don't care about the size of s,b since we use length(s), length(b)
   41          ! Algorithm regards each s,a,b,c as an array of char in memory
   42          ! where x[MAXLENIMPSTRING+1] == x[0..MAXLENIMPSTRING] and x[0] == length(x)
   43  
   44          ! successively try to fit B into S
   45          ! initialise A = "" (if addr(A) # 0)
   46  
   47          ! successively try to fit B into S
   48          sx == byteinteger( addr( s ) )
   49          bx == byteinteger( addr( b ) )
   50          slen = s                     ;! pick up respective lengths
   51          blen = b
   52  
   53          alen = 0
   54          %if (addr(a) # 0) %start
   55              ax == byteinteger( addr( a ) )
   56              ax = alen
   57          %finish
   58  
   59          clen = 0
   60          %if (addr(c) # 0) %start
   61              cx == byteinteger( addr(c) )
   62              cx = clen
   63          %finish
   64  
   65          %if (blen > slen) %start ;! can't possibly work
   66              %result = 0
   67          %finish
   68  
   69          index = 1
   70          %while ( (index + blen) <= slen + 1) %cycle
   71              ! see if there is a match starting from index
   72              count = 0
   73              %while (count <= blen) %cycle
   74                  sx == byteinteger( addr(s) + index + count )
   75                  bx == byteinteger( addr(b) + 1 + count )
   76  
   77                  %exit %if (sx # bx)
   78  
   79                  count = count + 1;
   80              %repeat
   81  
   82              ! check if a match was found, at offset INDEX
   83              %if (count = blen) %start
   84                  %if (addr(a) # 0) %start
   85                      alen = index - 1
   86  
   87                      ! copy the results
   88                      ! Now to remember the prefix string A in S-> A.(B).C
   89                      ax == byteinteger( addr(a) )
   90                      ax = alen
   91                      %for i = 1,1,alen %cycle
   92                          sx == byteinteger( addr(s) + i )
   93                          ax == byteinteger( addr(a) + i )
   94                          ax = sx;
   95                      %repeat
   96                  %finish
   97  
   98                  ! Now to remember the postfix string C in S-> A.(B).C
   99                  %if (addr(c) # 0) %start
  100                      clen = (slen - (alen + blen))
  101                      ! Ok, we have somewhere to store C
  102                      cx == byteinteger( addr(c) )
  103                      cx = clen
  104                      %for i = 1,1,clen %cycle
  105                          sx == byteinteger( addr(s) + i + alen + blen )
  106                          cx == byteinteger( addr(c) + i )
  107                          cx = sx
  108                      %repeat
  109                  %finish
  110  
  111                  %result = 1
  112              %finish
  113  
  114              ! here = no match
  115              index = index + 1
  116          %repeat
  117  
  118          %if (addr(a) # 0) %start
  119              %for count = 0,1,slen %cycle
  120                  sx == byteinteger( addr(s) + count )
  121                  ax == byteinteger( addr(a) + count )
  122                  ax = sx
  123              %repeat
  124          %finish
  125  
  126          %result = 0
  127      %end
  128  
  129  {------------------------------------------------------------------------------}
  130  %endoffile

   65 Statements compiled
