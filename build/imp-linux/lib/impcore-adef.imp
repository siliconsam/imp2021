
    %include "inc.386.registers"

{-----------------------------------------------------------------------------}
    ! Dope vectors are integer arrays of form
    !      :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ArrayElementSize:
    !      increasing address -->
    !
    ! Given a dope vector calculate the offset (in bytes) of the
    ! highest element, and also the offset from A(0,...,0) of
    ! the first element - the size of the store to allocate is
    ! therefore the difference.  We return the two 32 bit answers
    ! with one result => "high" answer is in DX, "low" answer
    ! is in AX.  Thus DX contains the top, AX the A(0) offset
    ! The way we achieve this is compiler dependent, so we declare
    ! this as VOID and then do the return in-line
    %external %routine impadef ( %integer %name dvp )
        %constinteger addressSize = 4
        %integer szAddress,lbAddress,ubAddress
        %integer dim, sz
        %integer lb, ub, row
        %integer i, base, limit

        ! The count of array dimensions is located at addr(dvp)
        dim = dvp

        ! the element size is given after the last pair of lower,upper bounds
        szAddress = addr(dvp) + addressSize*(2*dim + 1)

        ! initialise the base "address" and limit "address"
        base = 0
        limit = 0

        ! General case iterates backwards toward first dimension
        ! last dim upper bound is just before the szAddress
        ubAddress = szAddress - addressSize
        ! a lower bound is always just before the upper bound
        lbAddress = ubAddress - addressSize

        ! Now, iterate over each pair of a dimensions bounds
        %for i=1,1,dim %cycle
            ! NB. at i=1, we point to the rightmost dimensions lower,upper bounds
            lb = integer( lbAddress )
            ub = integer( ubAddress )

            ! we declare array bounds so that lb <= ub
            %signal 5, 3, 0 %unless lb <= ub

            ! calculate the number of objects in a row
            ! NB we add one to avoid the fence post error
            row   = (ub - lb) + 1
            base  = base * row + lb
            limit = limit * row + ub

            ! now point to the lower, upper bounds of the next lower array dimension
            ubAddress = lbAddress - addressSize
            lbAddress = ubAddress - addressSize
        %repeat

        ! finally get the size of each array element
        sz = integer( szAddress )

        base = base * sz
        limit = (limit + 1) * sz

        *mov_ edx,limit
        *mov_ eax,base

        %return
    %end

{-----------------------------------------------------------------------------}
%endoffile
