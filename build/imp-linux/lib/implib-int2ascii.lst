         Edinburgh IMP77 Compiler - Version 8.4

   1  {----------------------------------------------------------------------------}
   2      %external %string(255) %function int2ascii( %integer nn, base, places )
   3  
   4          %own %string(36) basechar = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   5          %string(255) reversed, human
   6          %integer n, np, r, i, negative;
   7  
   8          ! Validate the number base
   9          ! Since basechar has from 1 to 36 characters, we can only output numbers
   10          ! to base 2 thru 36. Of course if we add more characters then ...
   11          ! NB a number to base 1 cannot sensibly be displayed
   12          %if (base < 2) %then base = 10
   13          %if (base > 36) %then base = 10
   14  
   15          length(reversed) = 0
   16          n = nn
   17          %if (n = 0) %start
   18              r = 0
   19              ! string index starts at 1 - but r starts from 0
   20              ! so if r = 0 we want char 1 in the "basechar" string etc...
   21              length(reversed) = length(reversed) + 1
   22              charno(reversed,length(reversed)) = charno(basechar,r + 1)
   23          %else
   24              ! Now to avoid problems with -MAXINT
   25              %if (n > 0) %start
   26                  negative = 0
   27                  n = -n
   28              %else
   29                  negative = 1
   30              %finish
   31  
   32              %while (n < 0) %cycle
   33                  np = n // base
   34                  r = (np * base) - n
   35                  ! string index starts at 1 - but r starts from 0
   36                  ! so if r = 0 we want char 1 in the "basechar" string etc...
   37                  length(reversed) = length(reversed) + 1
   38                  charno(reversed,length(reversed)) = charno(basechar,r + 1)
   39                  n = np
   40              %repeat
   41  
   42              %if (negative > 0) %start
   43                  length(reversed) = length(reversed) + 1
   44                  charno(reversed,length(reversed)) = '-'
   45              %finish
   46          %finish
   47  
   48          ! Now we adjust Places, also slightly mysteriously
   49          %if places <= 0 %then places = -places %else places = places + 1
   50  
   51          ! Pad out the digits with blank spaces if places more than actual number of 'digits'
   52          %if (places > length(reversed)) %start
   53              %while length(reversed) < places %cycle
   54                  length(reversed) = length(reversed) + 1
   55                  charno(reversed,length(reversed)) = ' '
   56              %repeat
   57          %finish
   58  
   59          ! Now reverse the digits for human readability.
   60          length(human) = 0
   61          %for i = length(reversed), -1, 1 %cycle
   62              length(human) = length(human) + 1
   63              charno(human,length(human)) = charno( reversed, i )
   64          %repeat
   65  
   66          %result = human
   67      %end
   68  
   69  {----------------------------------------------------------------------------}
   70  %endoffile

   46 Statements compiled
