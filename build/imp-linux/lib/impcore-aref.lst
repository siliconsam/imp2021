         Edinburgh IMP77 Compiler - Version 8.4

   1  
   2      %include "inc.386.registers"
 &  1  %endoflist
 & 10  %endoffile
   3  
   4  {------------------------------------------------------------------------------}
   5      ! Array Reference function.
   6  
   7      ! Array indices are pushed left to right so we get them right to left.
   8      ! The last thing pushed (our first C parameter) is a pointer to the Dope Vector.
   9      ! Dope vectors are integer arrays of form :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ObjectSize:
   10      ! We need to fiddle with addresses because this function has a variable parameter count.
   11      ! This parameter count depends on the number of dimensions in the array
   12      ! The parameters are stacked for use by a C routine (but this is IMP!)
   13      ! However, this is an IMP routine so need to access in reverse order
   14      ! Even worse, there are a variable number of index values (One index value for each array index)
   15      ! We pretend there are no stacked parameters in the function declaration
   16      ! Fortunately the "last" IMP parameter (the dope vector) (but 1st C parameter) indicates
   17      ! the expected parameter count.
   18      ! We actually access parameters via the "ebp" register (=Base/Frame pointer)
   19      ! Remember [ebp]   = framep
   20      !          [ebp+4] = return address
   21      !          [ebp+8] = 1st C parameter = dope vector address
   22      !          [ebp+12] = last array index = dim'th index value
   23      !          [ebp+8+dim*4] = 1st array index = 1st index value (assuming 4 byte = 1 integer)
   24      ! The function result is the offset that needs to be added to the
   25      ! notional A(0,0,0) address to get the variable in the array
   26      !
   27      ! C declaration
   28      ! extern int imparef(int *dvp, int idim, ...,int i1 )
   29      !
   30      ! IMP declaration (C parameter order reversed to give IMP order)
   31      ! %external %integer %function imparef(%integer i1 { .. idim} , %integer %name dvp )
   32      !
   33      ! Arrgggh! Even worse, this function has a variable number of parameters (illegal IMP)
   34      ! Hence, the above mentioned contortions to deal with a variable count of parameters
   35      ! Fortunately, the "last" parameter stacked (the dopevector address) gives a clue as to
   36      ! the actual count of parameters.
   37      ! Luckily, the IMP compiler "pops" the set of parameters on return from this routine call
   38      ! Thus we can "pretend" this routine is declared with no parameters, however we need to
   39      ! use a bit of embedded machine code to access the real parameters via the frame pointer
   40  
   41      %external %integer %function imparef
   42  
   43          %integer framep
   44          %integer %name dvp
   45          %integer dim, sz
   46          %integer lb, ub
   47          %integer index
   48          %integer row, result
   49          %integer i
   50          %constant %integer wordsize = 4;        ! wordsize in bytes of integer/address
   51          %constant %integer param1 = 2*wordsize; ! frame pointer offset (in bytes) of "last" parameter on stack
   52                                                  ! e.g. dopevector address
   53          %constant %integer param2 = 3*wordsize; ! frame pointer offset (in bytes) of "last" array index
   54  
   55          ! Get the Base/Frame Pointer
   56          *mov_ framep,ebp
   57  
   58          ! IMP does NOT allow routines with a variable number of parameters
   59          ! but we need 
   60          ! parameter        1) dope vector address
   61          ! parameter 2..dim+1) array index values (dim = array dimensionality)
   62  
   63          ! Now get various data items from the dope vector
   64          ! The "last" parameter stacked is the pointer to dope vector
   65          ! Get the dope vector address ("last" C parameter/"first" IMP parameter)
   66          dvp == integer( integer( framep + param1 ) )
   67          ! Now get the array dimensionality from the dope vector
   68          dim = dvp
   69          ! Now get the size of each array element
   70          sz = integer( addr(dvp) + wordsize*(2*dim + 1) )
   71  
   72          ! For a general number of dimensions, 1 or more, we do this the hard way...
   73          result = 0;        ! result so far
   74          %for i=0,1,dim - 1 %cycle
   75  
   76              ! General case iterates backwards toward first dimension
   77              lb = integer( addr(dvp) + wordsize*(2*(dim - i) - 1));  ! at i=0, point to the rightmost lower bound
   78              ub = integer( addr(dvp) + wordsize*(2*(dim - i)    ));  ! at i=0, point to the rightmost upper bound
   79  
   80              ! Get the index: at i=0, point to the rightmost array index
   81              index = integer( framep + param2 + wordsize*i )
   82  
   83              ! Check the index
   84              %signal 6, 2, index %unless (lb <= index) %and (index <= ub); ! check to see if index in range lb:ub
   85  
   86              row   = (ub - lb) + 1;         ! Number of objects in a row
   87              result = (result * row) + index; ! accumulate this index
   88          %repeat
   89  
   90          %result = result * sz; ! multiply by element size
   91      %end
   92  
   93  {------------------------------------------------------------------------------}
   94  %endoffile

   32 Statements compiled
