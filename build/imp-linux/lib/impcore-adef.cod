
    %include "inc.386.registers"

{-----------------------------------------------------------------------------}
    ! Dope vectors are integer arrays of form
    !      :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ArrayElementSize:
    !      increasing address -->
    !
    ! Given a dope vector calculate the offset (in bytes) of the
    ! highest element, and also the offset from A(0,...,0) of
    ! the first element - the size of the store to allocate is
    ! therefore the difference.  We return the two 32 bit answers
    ! with one result => "high" answer is in DX, "low" answer
    ! is in AX.  Thus DX contains the top, AX the A(0) offset
    ! The way we achieve this is compiler dependent, so we declare
    ! this as VOID and then do the return in-line
    %external %routine impadef ( %integer %name dvp )
 0000                      L1000  EQU $
 0000 C8 00 00 01                     ENTER 0000,1
        %constinteger addressSize = 4
        %integer szAddress,lbAddress,ubAddress
        %integer dim, sz
        %integer lb, ub, row
        %integer i, base, limit

        ! The count of array dimensions is located at addr(dvp)
        dim = dvp
 0004 8B 75 08                        MOV ESI,[EBP+8]
 0007 8B 06                           MOV EAX,[ESI]
 0009 89 45 EC                        MOV [EBP-20],EAX

        ! the element size is given after the last pair of lower,upper bounds
        szAddress = addr(dvp) + addressSize*(2*dim + 1)
                                      Generating CODE for 'ADDR' (MACRO 4)
                                      CALL 'ADDR' (MACRO 4)
 000C 8B 45 EC                        MOV EAX,[EBP-20]
 000F D1 E0                           SHL EAX,1
 0011 40                              INC EAX
 0012 C1 E0 02                        SHL EAX,2
 0015 03 45 08                        ADD EAX,[EBP+8]
 0018 89 45 F8                        MOV [EBP-8],EAX

        ! initialise the base "address" and limit "address"
        base = 0
 001B C7 45 D4 00 00 00 00            MOV WORD [EBP-44],0
        limit = 0
 0022 C7 45 D0 00 00 00 00            MOV WORD [EBP-48],0

        ! General case iterates backwards toward first dimension
        ! last dim upper bound is just before the szAddress
        ubAddress = szAddress - addressSize
 0029 8B 45 F8                        MOV EAX,[EBP-8]
 002C 2D 04 00 00 00                  SUB EAX,4
 0031 89 45 F0                        MOV [EBP-16],EAX
        ! a lower bound is always just before the upper bound
        lbAddress = ubAddress - addressSize
 0034 8B 45 F0                        MOV EAX,[EBP-16]
 0037 2D 04 00 00 00                  SUB EAX,4
 003C 89 45 F4                        MOV [EBP-12],EAX

        ! Now, iterate over each pair of a dimensions bounds
        %for i=1,1,dim %cycle
 003F 8B 45 EC                        MOV EAX,[EBP-20]
 0042 89 45 CC                        MOV [EBP-52],EAX
 0045 C7 45 D8 00 00 00 00            MOV WORD [EBP-40],0
 004C                      L1001  EQU $
 004C 8B 45 D8                        MOV EAX,[EBP-40]
 004F 3B 45 CC                        CMP EAX,[EBP-52]
 0052 74 00                           JE L1002
 0054 40                              INC EAX
 0055 89 45 D8                        MOV [EBP-40],EAX
            ! NB. at i=1, we point to the rightmost dimensions lower,upper bounds
            lb = integer( lbAddress )
                                      Generating CODE for 'INTEGER' (MACRO 5)
                                      CALL 'INTEGER' (MACRO 5)
 0058 8B 7D F4                        MOV EDI,[EBP-12]
 005B 8B 07                           MOV EAX,[EDI]
 005D 89 45 E4                        MOV [EBP-28],EAX
            ub = integer( ubAddress )
                                      Generating CODE for 'INTEGER' (MACRO 5)
                                      CALL 'INTEGER' (MACRO 5)
 0060 8B 5D F0                        MOV EBX,[EBP-16]
 0063 8B 03                           MOV EAX,[EBX]
 0065 89 45 E0                        MOV [EBP-32],EAX

            ! we declare array bounds so that lb <= ub
            %signal 5, 3, 0 %unless lb <= ub
 0068 8B 45 E4                        MOV EAX,[EBP-28]
 006B 3B 45 E0                        CMP EAX,[EBP-32]
 006E 7E 00                           JLE L1003
 0070 B8 05 00 00 00                  MOV EAX,5
 0075 50                              PUSH EAX
 0076 31 C0                           XOR EAX,EAX
 0078 50                              PUSH EAX
 0079 B8 03 00 00 00                  MOV EAX,3
 007E 50                              PUSH EAX
 007F E8 0B 00                        CALL '_IMPSIGNAL' (EXTERN 11)
 0082 83 C4 0C                        ADD ESP,12
 0085                      L1003  EQU $

            ! calculate the number of objects in a row
            ! NB we add one to avoid the fence post error
            row   = (ub - lb) + 1
 0085 8B 45 E0                        MOV EAX,[EBP-32]
 0088 2B 45 E4                        SUB EAX,[EBP-28]
 008B 40                              INC EAX
 008C 89 45 DC                        MOV [EBP-36],EAX
            base  = base * row + lb
 008F 8B 45 D4                        MOV EAX,[EBP-44]
 0092 F7 6D DC                        IMUL WORD [EBP-36]
 0095 03 45 E4                        ADD EAX,[EBP-28]
 0098 89 45 D4                        MOV [EBP-44],EAX
            limit = limit * row + ub
 009B 8B 45 D0                        MOV EAX,[EBP-48]
 009E F7 6D DC                        IMUL WORD [EBP-36]
 00A1 03 45 E0                        ADD EAX,[EBP-32]
 00A4 89 45 D0                        MOV [EBP-48],EAX

            ! now point to the lower, upper bounds of the next lower array dimension
            ubAddress = lbAddress - addressSize
 00A7 8B 45 F4                        MOV EAX,[EBP-12]
 00AA 2D 04 00 00 00                  SUB EAX,4
 00AF 89 45 F0                        MOV [EBP-16],EAX
            lbAddress = ubAddress - addressSize
 00B2 8B 45 F0                        MOV EAX,[EBP-16]
 00B5 2D 04 00 00 00                  SUB EAX,4
 00BA 89 45 F4                        MOV [EBP-12],EAX
        %repeat
 00BD EB 00                           JMP L1001
 00BF                      L1002  EQU $

        ! finally get the size of each array element
        sz = integer( szAddress )
                                      Generating CODE for 'INTEGER' (MACRO 5)
                                      CALL 'INTEGER' (MACRO 5)
 00BF 8B 75 F8                        MOV ESI,[EBP-8]
 00C2 8B 06                           MOV EAX,[ESI]
 00C4 89 45 E8                        MOV [EBP-24],EAX

        base = base * sz
 00C7 8B 45 D4                        MOV EAX,[EBP-44]
 00CA F7 6D E8                        IMUL WORD [EBP-24]
 00CD 89 45 D4                        MOV [EBP-44],EAX
        limit = (limit + 1) * sz
 00D0 8B 45 D0                        MOV EAX,[EBP-48]
 00D3 40                              INC EAX
 00D4 F7 6D E8                        IMUL WORD [EBP-24]
 00D7 89 45 D0                        MOV [EBP-48],EAX

        *mov_ edx,limit
 00DA 8B 55 D0                        MOV EDX,[EBP-48]
        *mov_ eax,base
 00DD 8B 45 D4                        MOV EAX,[EBP-44]

        %return
 00E0 C9                              LEAVE
 00E1 C3                              RET
    %end

{-----------------------------------------------------------------------------}
%endoffile
      _TEXT  ENDS
      CONST  SEGMENT WORD PUBLIC 'CONST'
      CONST  ENDS
      _TEXT  SEGMENT WORD PUBLIC 'CODE'
            ENDS
      DATA  SEGMENT WORD PUBLIC 'DATA'
      DATA    ENDS
              ENDS
      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'
      _SWTAB   ENDS
