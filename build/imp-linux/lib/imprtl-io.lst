         Edinburgh IMP77 Compiler - Version 8.4

   1  
   2      %include "inc.386.registers"
 &  1  %endoflist
 & 10  %endoffile
   3  
   4      %external %routine %spec initialise io system
   5  
   6      %constinteger integersize   = 4
   7      %constinteger realsize      = 4
   8      ! we don't define stringsize as it could be in range 1..255
   9      ! we don't define recordsize as it depends on the record format
   10      %constinteger bytesize      = 1
   11      %constinteger longrealsize  = 8
   12  
   13      ! Curious naming strategy because we don't want to clobber
   14      ! the built-in functions and maps like "integer" or "int"
   15      ! Types extracted from general names
   16      %constinteger      integertype = 1
   17      %constinteger         realtype = 2
   18      %constinteger       stringtype = 3
   19      %constinteger       recordtype = 4
   20      %constinteger         bytetype = 5
   21      %constinteger shortintegertype = 6
   22      %constinteger  longintegertype = 7
   23      %constinteger     longrealtype = 8
   24  
   25      ! Assign the constant values
   26      %constant %integer std null handle = 0
   27      %constant %integer std err handle  = 1
   28      %constant %integer std in handle   = 2
   29      %constant %integer std out handle  = 3
   30  
   31      ! To ensure that the compiler can compile itself
   32      ! We need a minimum number of INPUT/OUTPUT Streams
   33      ! These minimum numbers depend on the depth of %include files
   34      ! for MAX INPUT STREAM
   35      ! The number of output files used by the takeon, pass1, pass2
   36      ! programs will affect the value of MAX OUTPUI STREAM
   37      ! Currently, the bare minimum value for MAX INPUT STREAM is 4
   38      ! Currently, the bare minimum value for MAX OUTPUT STREAM is 3
   39  
   40      ! It is perfectly legal to increase the values of MAX XXX STREAM
   41      ! to be more than the minimum MAX XXX STREAM values given above
   42      %constant %integer MAX INPUT STREAM  = 4
   43      %constant %integer MAX OUTPUT STREAM = 4
   44  
   45      %constant %integer IS INPUT = 0 << 0
   46      %constant %integer IS OUTPUT = 1 << 0
   47      %constant %integer IS TEXT = 0 << 1
   48      %constant %integer IS BINARY = 1 << 1
   49  
   50      %constant %integer uninitialised = 0
   51      %constant %integer initialised = 1
   52  
   53      %record %format impstream ( %integer lookahead, flags, %string(255) file name, %integer handle )
   54      %record %format impinput ( %integer current stream, 
   55+                                %record(impstream) %array streams(0:MAX INPUT STREAM) )
   56  !    %record %format impinput ( %integer current stream, 
   57  !                               %record(impstream) stream0,stream1,stream2,stream3,stream4 )
   58      %record %format impoutput ( %integer current stream, 
   59+                                 %record(impstream) %array streams(0:MAX OUTPUT STREAM) )
   60  !    %record %format impoutput ( %integer current stream, 
   61  !                                %record(impstream) stream0,stream1,stream2,stream3 )
   62  
   63      %own %record (impinput) in
   64      %own %record (impoutput) out
   65      %own %record (impstream) null stream
   66      %own %record (impstream) error stream
   67  
   68      %own %integer initialised state = uninitialised
   69      %external %integer fileerror %alias "_errno"
   70  
   71      ! This converts an IMP string in-situ to become a C string
   72      ! We just need the address of the IMP string
   73      %routine imptocstring( %string(*) %name impstring )
   74          %integer len,i
   75          %byte %integer %name src
   76  
   77          %if addr( impstring ) # 0 %start
   78              ! Find the length of the IMP format string
   79              len = length( impstring )
   80  
   81              ! Convert to a C format string
   82              ! We do this in one step 0..len-1
   83              ! copying from impstring(i+1) to impstring(i)
   84              ! lastly, store 0 in impstring(len)
   85              %for i = 0,1,len - 1 %cycle
   86                  src == byteinteger( addr( impstring ) + i + 1)
   87                  charno( impstring, i ) = src
   88              %repeat
   89              charno( impstring, len ) = 0
   90          %finish
   91      %end
   92  
   93      %external %predicate need to initialise
   94          %true %if (initialised state = uninitialised)
   95          %false
   96      %end
   97  
   98      %routine initialise stream( %record(impstream) %name s )
   99          s_handle = 0
  100          length(s_file name) = 0
  101          s_flags = 0
  102          s_lookahead = -1
  103      %end
  104  
  105      %routine finalise stream( %record(impstream) %name s )
  106          %if (s_handle # 0) %then close( s_handle )
  107  
  108          initialise stream( s )
  109      %end
  110  
  111      %predicate acceptabletype( %integer type )
  112          %true %if (type = integertype)
  113          %true %if (type = realtype)
  114          %true %if (type = stringtype)
  115          %true %if (type = recordtype)
  116          %true %if (type = bytetype)
  117          %true %if (type = longrealtype)
  118          %false
  119      %end
  120  
  121      %own %string(31) input prompt = "prompt ->"
  122      %own %integer tty needs a prompt = 1
  123  
  124      %external %routine prompt( %string(31) s )
  125          input prompt = s
  126      %end
  127  !------------------------------------------------------------------------------
  128  ! Input routines
  129  !------------------------------------------------------------------------------
  130      %routine initialise input system
  131          %record(impstream)%name streamX
  132          %integer i
  133  
  134          in_current stream = 0
  135  
  136          %for i = 0,1,MAX INPUT STREAM %cycle
  137              streamX == in_streams(i)
  138              initialise stream( streamX )
  139          %repeat
  140          in_streams(0)_handle = get std in handle
  141          in_streams(0)_file name = "stdin" 
  142  
  143  !        streamX == in_stream0
  144  !        initialise stream( streamX )
  145  !        streamX == in_stream1
  146  !        initialise stream( streamX )
  147  !        streamX == in_stream2
  148  !        initialise stream( streamX )
  149  !        streamX == in_stream3
  150  !        initialise stream( streamX )
  151  !        streamX == in_stream4
  152  !        initialise stream( streamX )
  153  !        in_stream0_handle = get std in handle
  154  !        in_stream0_file name = "stdin" 
  155      %end
  156  
  157      %routine terminate input system
  158          %record(impstream)%name streamX
  159          %integer i
  160  
  161          in_current stream = -1
  162  
  163          %for i = 1,1,MAX INPUT STREAM %cycle
  164              streamX == in_streams(i)
  165              finalise stream( streamX )
  166          %repeat
  167  !        streamX == in_stream0
  168  !        finalise stream( streamX )
  169  !        streamX == in_stream1
  170  !        finalise stream( streamX )
  171  !        streamX == in_stream2
  172  !        finalise stream( streamX )
  173  !        streamX == in_stream3
  174  !        finalise stream( streamX )
  175  !        streamX == in_stream4
  176  !        finalise stream( streamX )
  177  
  178      %end
  179  
  180      %external %integer %function readbuffer( %name ptr, %integer count )
  181          %record(impstream)%name streamX
  182          %integer i,actualcount
  183          %integer len,adr,type
  184          %integer itemsz
  185  
  186          len = size of(ptr)
  187          adr = addr(ptr)
  188          type = type of(ptr)
  189  
  190  %if ((DEBUGMODE & dbgio) # 0) %start
  191  debug string("READBUFFER: address(ptr)=".int2ascii(adr,16,0) );  debug newline
  192  debug string("READBUFFER: size of(ptr)=".int2ascii(len,16,0) );  debug newline
  193  debug string("READBUFFER: type of(ptr)=".int2ascii(type,16,0) ); debug newline
  194  debug string("READBUFFER:        count=".itos(count,0) );        debug newline
  195  %finish
  196  
  197          %signal 5,5,type %unless acceptabletype(type)
  198  
  199          ! assume we are reading data into a byte array (or string)
  200          itemsz = -1
  201  
  202          %if (type = integertype)  %then itemsz = integersize
  203          %if (type = realtype)     %then itemsz = realsize
  204          %if (type = stringtype)   %then itemsz = len
  205          %if (type = bytetype)     %then itemsz = bytesize
  206          %if (type = longrealtype) %then itemsz = longrealsize
  207          %if (type = recordtype)   %then itemsz = len
  208  
  209          %if need to initialise %then initialise io system
  210  
  211          ! can't select an invalid stream id (not stdin)
  212          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  213          ! can't select a closed file
  214          streamX == in_streams( in_current stream )
  215  !        %if (in_current stream = 1) %then streamX == in_stream1
  216  !        %if (in_current stream = 2) %then streamX == in_stream2
  217  !        %if (in_current stream = 3) %then streamX == in_stream3
  218  !        %if (in_current stream = 4) %then streamX == in_stream4
  219          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  220  
  221          ! We actually load the buffer as an array of bytes
  222          ! We need the stream handle, count of items space, item size, buffer address
  223          ! Where, count * itemsz = size in bytes of buffer storage
  224          actualcount = readbytes( streamX_handle, count, itemsz, byteinteger( addr(ptr) ) )
  225  
  226          ! If we are storing in an IMP string then we need to convert the stored buffer
  227          ! from C string format (zero start index)  to IMP string format
  228          %if (0 <= len <= 255) %and (type of(ptr) = stringtype) %start
  229              ! It is a string!!
  230              ! Therefore we need to move the chars from n to n+1 location
  231              ! Thus, we can store the IMP string length in location 0 (its expected location)
  232              ! Use actualcount as number of chars in the string
  233              ! JDM should check that actualcount < count else buffer overflow
  234              %for i=actualcount-1,-1,0 %cycle
  235                  charno( string(addr(ptr)), i + 1 ) = charno( string(addr(ptr)), i )
  236              %repeat
  237              charno( string(addr(ptr)),0 ) = actualcount
  238          %finish
  239  
  240          %result = actualcount
  241      %end
  242  
  243      %external %integer %function input stream
  244          %if need to initialise %then initialise io system
  245  
  246          %result = in_current stream
  247      %end
  248  
  249      %external %routine reset input
  250          %record(impstream)%name streamX
  251  
  252          %if need to initialise %then initialise io system
  253  
  254          ! can't select an invalid stream id (not stdin)
  255          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  256          ! can't select a closed file
  257          streamX == in_streams( in_current stream )
  258  !        %if (in_current stream = 1) %then streamX == in_stream1
  259  !        %if (in_current stream = 2) %then streamX == in_stream2
  260  !        %if (in_current stream = 3) %then streamX == in_stream3
  261  !        %if (in_current stream = 4) %then streamX == in_stream4
  262  
  263          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  264  
  265          file rewind( streamX_handle )
  266      %end
  267  
  268      %external %routine seek input( %integer displacement, pos )
  269          %record(impstream)%name streamX
  270  
  271          %if need to initialise %then initialise io system
  272  
  273          ! can't select an invalid stream id (not stdin)
  274          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  275          ! can't select a closed file
  276          streamX == in_streams( in_current stream )
  277  !        %if (in_current stream = 1) %then streamX == in_stream1
  278  !        %if (in_current stream = 2) %then streamX == in_stream2
  279  !        %if (in_current stream = 3) %then streamX == in_stream3
  280  !        %if (in_current stream = 4) %then streamX == in_stream4
  281  
  282          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  283  
  284          %if (0 <= pos <= 2) %then file seek( streamX_handle, displacement, pos )
  285      %end
  286  
  287      %external %integer %function tell input
  288          %record(impstream)%name streamX
  289  
  290          %if need to initialise %then initialise io system
  291  
  292          ! can't select an invalid stream id (not stdin)
  293          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  294          ! can't select a closed file
  295          streamX == in_streams( in_current stream )
  296  !        %if (in_current stream = 1) %then streamX == in_stream1
  297  !        %if (in_current stream = 2) %then streamX == in_stream2
  298  !        %if (in_current stream = 3) %then streamX == in_stream3
  299  !        %if (in_current stream = 4) %then streamX == in_stream4
  300  
  301          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  302  
  303          %result = tell( streamX_handle )
  304      %end
  305  
  306      %external %string(255) %function input name
  307          %record(impstream)%name streamX
  308          %string(255) name
  309  
  310          %if need to initialise %then initialise io system
  311  
  312          ! can't select an invalid stream id
  313          %signal 9, 9 %unless (0 <= in_current stream <= MAX INPUT STREAM)
  314          ! can't select a closed file
  315          streamX == in_streams( in_current stream )
  316  !        %if (in_current stream = 0) %then streamX == in_stream0
  317  !        %if (in_current stream = 1) %then streamX == in_stream1
  318  !        %if (in_current stream = 2) %then streamX == in_stream2
  319  !        %if (in_current stream = 3) %then streamX == in_stream3
  320  !        %if (in_current stream = 4) %then streamX == in_stream4
  321  
  322          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  323  
  324          name = streamX_file name
  325  
  326          %result = name
  327      %end
  328  
  329      %external %routine select input( %integer stream id )
  330          %record(impstream)%name streamX
  331  
  332          %if need to initialise %then initialise io system
  333  
  334          ! can't select an invalid stream id
  335          %signal 9, 9 %unless (0 <= stream id <= MAX INPUT STREAM)
  336          ! can't select a closed file
  337          streamX == in_streams( stream id )
  338  !        %if (stream id = 0) %then streamX == in_stream0
  339  !        %if (stream id = 1) %then streamX == in_stream1
  340  !        %if (stream id = 2) %then streamX == in_stream2
  341  !        %if (stream id = 3) %then streamX == in_stream3
  342  !        %if (stream id = 4) %then streamX == in_stream4
  343  
  344          %signal 9, 4, stream id %unless (streamX_handle # 0)
  345  
  346          in_current stream = stream id;
  347      %end
  348  
  349      %external %routine close input
  350          %record(impstream)%name streamX
  351  
  352          %if need to initialise %then initialise io system
  353  
  354          ! can't close terminal input
  355          ! can't close an already closed file
  356          %if (0 < in_current stream <= MAX INPUT STREAM ) %start
  357              streamX == in_streams( in_current stream )
  358  !            %if (in_current stream = 1) %then streamX == in_stream1
  359  !            %if (in_current stream = 2) %then streamX == in_stream2
  360  !            %if (in_current stream = 3) %then streamX == in_stream3
  361  !            %if (in_current stream = 4) %then streamX == in_stream4
  362  
  363              %if (streamX_handle # 0) %start
  364                  close( streamX_handle )
  365                  initialise stream( streamX )
  366              %finish
  367          %finish
  368      %end
  369  
  370      %external %routine open input( %integer stream  id, %string(255) file name )
  371          %record(impstream)%name streamX
  372          %integer handle
  373          %integer flags = IS INPUT ! IS TEXT
  374          %string(4) mode = "r"
  375          %string(255) xxx
  376          %string(4) yyy
  377  
  378          %if need to initialise %then initialise io system
  379  
  380          ! Error out if streamid not in legal range
  381          %signal 9, 9, stream id %unless (0 < stream id <= MAX INPUT STREAM )
  382  
  383          ! If file not open
  384          streamX == in_streams( stream id )
  385  !        %if (stream id = 1) %then streamX == in_stream1
  386  !        %if (stream id = 2) %then streamX == in_stream2
  387  !        %if (stream id = 3) %then streamX == in_stream3
  388  !        %if (stream id = 4) %then streamX == in_stream4
  389  
  390          %if (streamX_handle = 0) %start
  391  
  392              xxx = filename
  393              yyy = mode
  394  
  395              ! Tweak xxx,yyy to be C strings
  396              ! Why? because we are sending them to a C function expecting C strings
  397              imptocstring( xxx )
  398              imptocstring( yyy )
  399  
  400              handle = openfile( addr(yyy), addr(xxx) )
  401  
  402              %if (handle = 0) %start
  403  
  404  %if ((DEBUGMODE & dbgio) # 0) %start
  405  debugstring("OPENINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  406  debugnewline
  407  %finish
  408                  %signal 9, 2, get error
  409              %else
  410  
  411  %if ((DEBUGMODE & dbgio) # 0) %start
  412  debugstring("OPENINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  413  debugnewline
  414  %finish
  415                  streamX == in_streams( stream id )
  416  !                %if (stream id = 1) %then streamX == in_stream1
  417  !                %if (stream id = 2) %then streamX == in_stream2
  418  !                %if (stream id = 3) %then streamX == in_stream3
  419  !                %if (stream id = 4) %then streamX == in_stream4
  420  
  421                  streamX_handle = handle
  422                  streamX_file name = file name
  423                  streamX_flags = flags
  424              %finish
  425          %finish
  426      %end
  427  
  428      %external %routine open binary input( %integer stream  id, %string(255) file name )
  429          %record(impstream)%name streamX
  430          %integer handle
  431          %integer flags = IS INPUT ! IS BINARY
  432          %string(4) mode = "rb"
  433          %string(255) xxx
  434          %string(4) yyy
  435  
  436          %if need to initialise %then initialise io system
  437  
  438          %signal 9, 9, stream id %unless (0 < stream id <= MAX INPUT STREAM )
  439  
  440          ! If file not open
  441          streamX == in_streams( stream id )
  442  !        %if (stream id = 1) %then streamX == in_stream1
  443  !        %if (stream id = 2) %then streamX == in_stream2
  444  !        %if (stream id = 3) %then streamX == in_stream3
  445  !        %if (stream id = 4) %then streamX == in_stream4
  446  
  447          %if (streamX_handle = 0) %start
  448  
  449              xxx = filename
  450              yyy = mode
  451  
  452              ! Tweak xxx,yyy to be C strings
  453              ! Why? because we are sending them to a C function expecting C strings
  454              imptocstring( xxx )
  455              imptocstring( yyy )
  456  
  457              handle = openfile( addr(yyy), addr(xxx) )
  458  
  459              %if (handle = 0) %start
  460  
  461  %if ((DEBUGMODE & dbgio) # 0) %start
  462  debugstring("OPENBINARYINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  463  debugnewline
  464  %finish
  465                  %signal 9, 2, get error
  466              %else
  467  
  468  %if ((DEBUGMODE & dbgio) # 0) %start
  469  debugstring("OPENBINARYINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  470  debugnewline
  471  %finish
  472                  streamX == in_streams( stream id )
  473  !                %if (stream id = 1) %then streamX == in_stream1
  474  !                %if (stream id = 2) %then streamX == in_stream2
  475  !                %if (stream id = 3) %then streamX == in_stream3
  476  !                %if (stream id = 4) %then streamX == in_stream4
  477  
  478                  streamX_handle = handle
  479                  streamX_file name = file name
  480                  streamX_flags = flags
  481              %finish
  482          %finish
  483      %end
  484  
  485      %external %integer %function next symbol
  486          %record(impstream)%name streamX
  487          %integer ch,i
  488  
  489          %if need to initialise %then initialise io system
  490  
  491          %signal 9, 9, in_current stream %unless (0 <= in_current stream <= MAX INPUT STREAM )
  492  
  493          streamX == in_streams( in_current stream )
  494  !        %if (in_current stream = 0) %then streamX == in_stream0
  495  !        %if (in_current stream = 1) %then streamX == in_stream1
  496  !        %if (in_current stream = 2) %then streamX == in_stream2
  497  !        %if (in_current stream = 3) %then streamX == in_stream3
  498  !        %if (in_current stream = 4) %then streamX == in_stream4
  499  
  500          %signal 9, 4, in_current stream %unless (streamX_handle # 0)
  501  
  502          ! Check to see if we already have a lookahead char (actually integer)
  503          %if (streamX_lookahead < 0) %start
  504              %if (in_current stream = 0) %start
  505                  %if (tty needs a prompt # 0) %start
  506                      tty needs a prompt = 0;
  507  
  508                      %for i = 1,1,length( input prompt ) %cycle
  509                          put char( error stream_handle, charno( input prompt, i ) )
  510                      %repeat
  511  
  512                  %finish
  513              %finish
  514  
  515              ch = get char ( streamX_handle )
  516              ! remember ch for future use
  517              streamX_lookahead = ch
  518  
  519              ! NL => we should prompt next time
  520              %if (in_current stream = 0) %and (ch = nl) %then tty needs a prompt = 1;
  521  
  522              ! Are we attempting to read after the end of file
  523              %signal 9,0, in_current stream %if (ch < 0)        
  524  
  525          %finish
  526          
  527          %result = streamX_lookahead
  528      %end
  529  
  530      %external %routine read symbol( %integer %name ch )
  531          %record(impstream)%name streamX
  532  
  533          %if need to initialise %then initialise io system
  534  
  535          ch = next symbol
  536          streamX == in_streams( in_current stream )
  537  !        %if (in_current stream = 0) %then streamX == in_stream0
  538  !        %if (in_current stream = 1) %then streamX == in_stream1
  539  !        %if (in_current stream = 2) %then streamX == in_stream2
  540  !        %if (in_current stream = 3) %then streamX == in_stream3
  541  !        %if (in_current stream = 4) %then streamX == in_stream4
  542  
  543          streamX_lookahead = -1
  544  
  545          ! Are we attempting to read after the end of file
  546          %signal 9,1, in_current stream %if (ch < 0)        
  547  
  548      %end
  549  !------------------------------------------------------------------------------
  550  ! Output routines
  551  !------------------------------------------------------------------------------
  552      %routine initialise output system
  553          %record(impstream)%name streamX
  554  
  555          %integer i
  556  
  557          out_current stream = 0
  558  
  559          %for i = 0,1,MAX OUTPUT STREAM %cycle
  560              streamX == out_streams(i)
  561              initialise stream( streamX )
  562          %repeat
  563  !        streamX = out_stream0
  564  !        initialise stream( streamX )
  565  !        streamX = out_stream1
  566  !        initialise stream( streamX )
  567  !        streamX = out_stream2
  568  !        initialise stream( streamX )
  569  !        streamX = out_stream3
  570  !        initialise stream( streamX )
  571  
  572          streamX == out_streams(0)
  573  !        streamx == out_stream0
  574  
  575          streamX_handle = get std out handle
  576          streamX_file name = "stdout"
  577          streamX_flags = IS OUTPUT ! IS TEXT
  578  
  579          ! Don't forget to initialise the debug output stream
  580          streamX == error stream
  581          initialise stream( streamX )
  582          streamX_handle = get std err handle
  583          streamX_file name = "stderr"
  584          streamX_flags = IS OUTPUT ! IS TEXT
  585      %end
  586  
  587      %routine terminate output system
  588          %record(impstream)%name streamX
  589          %integer i
  590  
  591          out_current stream = -1
  592  
  593          %for i = 1,1,MAX OUTPUT STREAM %cycle
  594              streamX == out_streams(i)
  595              finalise stream( streamX )
  596          %repeat
  597  !        streamX == out_stream1
  598  !        finalise stream( streamX )
  599  !        streamX == out_stream2
  600  !        finalise stream( streamX )
  601  !        streamX == out_stream3
  602  !        finalise stream( streamX )
  603      %end
  604  
  605      %external %routine debug symbol( %integer c )
  606          %if need to initialise %then initialise io system
  607  
  608          %if (error stream_handle # 0) %then put char( error stream_handle, c )
  609      %end
  610  
  611      %external %routine debug real( %long %real d )
  612          %if need to initialise %then initialise io system
  613  
  614          %if (error stream_handle # 0) %then put double( error stream_handle, d )
  615      %end
  616  
  617      %external %integer %function writebuffer( %name ptr, %integer count )
  618          %record(impstream)%name streamX
  619          %integer len,adr,type
  620          %integer itemsz
  621          %integer i
  622          %integer res
  623  
  624          len = size of(ptr)
  625          adr = addr(ptr)
  626          type = type of(ptr)
  627  
  628  %if ((DEBUGMODE & dbgio) # 0) %start
  629  debug string("READBUFFER: address(ptr)=".int2ascii(adr,16,0) );  debug newline
  630  debug string("READBUFFER: size of(ptr)=".int2ascii(len,16,0) );  debug newline
  631  debug string("READBUFFER: type of(ptr)=".int2ascii(type,16,0) ); debug newline
  632  debug string("READBUFFER:        count=".itos(count,0) );        debug newline
  633  %finish
  634  
  635          ! check if we can write a valid data type
  636          %signal 5,5,type %unless acceptabletype(type) %and (len = count)
  637  
  638          ! assume we are reading data into a byte array (or string)
  639          itemsz = -1
  640  
  641          %if (type = integertype)  %then itemsz = integersize
  642          %if (type = realtype)     %then itemsz = realsize
  643          %if (type = stringtype)   %then itemsz = len
  644          %if (type = bytetype)     %then itemsz = bytesize
  645          %if (type = longrealtype) %then itemsz = longrealsize
  646          %if (type = recordtype)   %then itemsz = len
  647  
  648          %if need to initialise %then initialise io system
  649  
  650          ! can't select an invalid stream id (not stdout)
  651          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  652          ! can't select a closed file
  653          streamX == out_streams( out_current stream )
  654  !        %if (out_current stream = 1) %then streamX == out_stream1
  655  !        %if (out_current stream = 2) %then streamX == out_stream2
  656  !        %if (out_current stream = 3) %then streamX == out_stream3
  657  
  658          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  659  
  660          ! We actually load the buffer as an array of bytes
  661          ! We need the stream handle, count of items space, item size, buffer address
  662          ! Where, count * itemsz = size in bytes of buffer storage
  663          %result = writebytes( streamX_handle, count, itemsz, byteinteger( addr(ptr) ) )
  664      %end
?RES unused
?I unused
  665  
  666      %external %integer %function output stream
  667          %if need to initialise %then initialise io system
  668  
  669          %result = out_current stream
  670      %end
  671  
  672      %external %routine reset output
  673          %record(impstream)%name streamX
  674  
  675          %if need to initialise %then initialise io system
  676  
  677          ! can't select an invalid stream id (not stdout)
  678          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  679          ! can't select a closed file
  680          streamX == out_streams( out_current stream )
  681  !        %if (out_current stream = 1) %then streamX == out_stream1
  682  !        %if (out_current stream = 2) %then streamX == out_stream2
  683  !        %if (out_current stream = 3) %then streamX == out_stream3
  684  
  685          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  686  
  687          file rewind( streamX_handle )
  688      %end
  689  
  690      %external %routine seek output( %integer displacement, pos )
  691          %record(impstream)%name streamX
  692  
  693          %if need to initialise %then initialise io system
  694  
  695          ! can't select an invalid stream id (not stdout)
  696          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  697          ! can't select a closed file
  698          streamX == out_streams( out_current stream )
  699  !        %if (out_current stream = 1) %then streamX == out_stream1
  700  !        %if (out_current stream = 2) %then streamX == out_stream2
  701  !        %if (out_current stream = 3) %then streamX == out_stream3
  702  
  703          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  704  
  705          %if (0 <= pos <= 2) %start
  706              file seek( streamX_handle, displacement, pos )
  707          %finish
  708      %end
  709  
  710      %external %integer %function tell output
  711          %record(impstream)%name streamX
  712  
  713          %if need to initialise %then initialise io system
  714  
  715          ! can't select an invalid stream id (not stdout)
  716          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  717          ! can't select a closed file
  718          streamX == out_streams( out_current stream )
  719  !        %if (out_current stream = 1) %then streamX == out_stream1
  720  !        %if (out_current stream = 2) %then streamX == out_stream2
  721  !        %if (out_current stream = 3) %then streamX == out_stream3
  722  
  723          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  724  
  725          %result = tell( streamX_handle )
  726      %end
  727  
  728      %external %string(255) %function output name
  729          %record(impstream)%name streamX
  730  
  731          %if need to initialise %then initialise io system
  732  
  733          ! can't select an invalid stream id
  734          %signal 9, 9 %unless (0 <= out_current stream <= MAX OUTPUT STREAM)
  735          ! can't select a closed file
  736          streamX == out_streams( out_current stream )
  737  !        %if (out_current stream = 0) %then streamX == out_stream0
  738  !        %if (out_current stream = 1) %then streamX == out_stream1
  739  !        %if (out_current stream = 2) %then streamX == out_stream2
  740  !        %if (out_current stream = 3) %then streamX == out_stream3
  741  
  742          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  743  
  744          %result = streamX_file name
  745      %end
  746  
  747      %external %routine select output( %integer stream id )
  748          %record(impstream)%name streamX
  749  
  750          %if need to initialise %then initialise io system
  751  
  752          ! can't select an invalid stream id
  753          %signal 9, 9 %unless (0 <= stream id <= MAX OUTPUT STREAM)
  754  
  755          ! can't select a closed file
  756          streamX == out_streams( stream id )
  757  !        %if (stream id = 0) %then streamX == out_stream0
  758  !        %if (stream id = 1) %then streamX == out_stream1
  759  !        %if (stream id = 2) %then streamX == out_stream2
  760  !        %if (stream id = 3) %then streamX == out_stream3
  761  
  762          %signal 9, 5, stream id %unless (streamX_handle # 0)
  763  
  764          out_current stream = stream id
  765      %end
  766  
  767      %external %routine close output
  768          %record(impstream)%name streamX
  769  
  770          %if need to initialise %then initialise io system
  771  
  772          ! can't close terminal output
  773          ! can't close an already closed file
  774          %if (0 < out_current stream <= MAX OUTPUT STREAM ) %start
  775              streamX == out_streams( out_current stream )
  776  !            %if (out_current stream = 1) %then streamX == out_stream1
  777  !            %if (out_current stream = 2) %then streamX == out_stream2
  778  !            %if (out_current stream = 3) %then streamX == out_stream3
  779  
  780              %if (streamX_handle # 0) %start
  781                  close( streamX_handle )
  782                  initialise stream( streamX )
  783              %finish
  784          %finish
  785      %end
  786  
  787      %external %routine open output( %integer stream  id, %string(255) file name )
  788          %record(impstream)%name streamX
  789          %integer handle
  790          %integer flags = IS OUTPUT ! IS TEXT
  791          %string(4) mode = "w"
  792          %string(255) xxx
  793          %string(4) yyy
  794  
  795          %if need to initialise %then initialise io system
  796  
  797          ! Error out if streamid not in legal range
  798          %signal 9, 9, stream id %unless (0 < stream id <= MAX OUTPUT STREAM )
  799  
  800          ! If file not open
  801          streamX == out_streams( stream id )
  802  !        %if (stream id = 1) %then streamX == out_stream1
  803  !        %if (stream id = 2) %then streamX == out_stream2
  804  !        %if (stream id = 3) %then streamX == out_stream3
  805  
  806          %if (streamX_handle = 0) %start
  807              xxx = filename
  808              yyy = mode
  809  
  810              ! Tweak xxx,yyy to be C strings
  811              ! Why? because we are sending them to a C function expecting C strings
  812              imptocstring( xxx )
  813              imptocstring( yyy )
  814  
  815              handle = openfile( addr(yyy), addr(xxx) )
  816  
  817              %if (handle = 0) %start
  818  
  819  %if ((DEBUGMODE & dbgio) # 0) %start
  820  debugstring("OPENOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  821  debugnewline
  822  %finish
  823                  %signal 9, 2, get error
  824              %else
  825  
  826  %if ((DEBUGMODE & dbgio) # 0) %start
  827  debugstring("OPENOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  828  debugnewline
  829  %finish
  830                  streamX_handle = handle
  831                  streamX_file name = file name
  832                  streamX_flags = flags
  833              %finish
  834          %finish
  835      %end
  836  
  837      %external %routine open binary output( %integer stream  id, %string(255) file name )
  838          %record(impstream)%name streamX
  839          %integer handle
  840          %integer flags = IS OUTPUT ! IS BINARY
  841          %string(4) mode = "wb"
  842          %string(255) xxx
  843          %string(4) yyy
  844  
  845          %if need to initialise %then initialise io system
  846  
  847          %signal 9, 9, stream id %unless (0 < stream id <= MAX OUTPUT STREAM )
  848  
  849          ! If file not open
  850          streamX == out_streams( stream id )
  851  !        %if (stream id = 1) %then streamX == out_stream1
  852  !        %if (stream id = 2) %then streamX == out_stream2
  853  !        %if (stream id = 3) %then streamX == out_stream3
  854  
  855          %if (streamX_handle = 0) %start
  856              xxx = filename
  857              yyy = mode
  858  
  859              ! Tweak xxx,yyy to be C strings
  860              ! Why? because we are sending them to a C function expecting C strings
  861              imptocstring( xxx )
  862              imptocstring( yyy )
  863  
  864              handle = openfile( addr(yyy), addr(xxx) )
  865  
  866              %if (handle = 0) %start
  867  
  868  %if ((DEBUGMODE & dbgio) # 0) %start
  869  debugstring("OPENBINARYOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  870  debugnewline
  871  %finish
  872                  %signal 9, 2, get error
  873              %else
  874  
  875  %if ((DEBUGMODE & dbgio) # 0) %start
  876  debugstring("OPENBINARYOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  877  debugnewline
  878  %finish
  879                  streamX_handle = handle
  880                  streamX_file name = file name
  881                  streamX_flags = flags
  882              %finish
  883          %finish
  884      %end
  885  
  886      %external %routine flush output
  887          %record(impstream)%name streamX
  888  
  889          %if need to initialise %then initialise io system
  890  
  891          ! only interrogate actual opened files (including stdout)
  892          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  893  
  894          streamX == out_streams( out_current stream )
  895  !        %if (out_current stream = 0) %then streamX == out_stream0
  896  !        %if (out_current stream = 1) %then streamX == out_stream1
  897  !        %if (out_current stream = 2) %then streamX == out_stream2
  898  !        %if (out_current stream = 3) %then streamX == out_stream3
  899  
  900          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  901  
  902          flush( streamX_handle )
  903      %end
  904  
  905      %external %routine print symbol( %integer c )
  906          %record(impstream)%name streamX
  907  
  908          %if need to initialise %then initialise io system
  909  
  910          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  911  
  912          streamX == out_streams( out_current stream )
  913  !        %if (out_current stream = 0) %then streamX == out_stream0
  914  !        %if (out_current stream = 1) %then streamX == out_stream1
  915  !        %if (out_current stream = 2) %then streamX == out_stream2
  916  !        %if (out_current stream = 3) %then streamX == out_stream3
  917  
  918          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  919  
  920          ! Not sure what the official IMP behaviour is for output on a closed file.
  921          ! We choose to silently ignore it...
  922          ! check file open before writing?
  923          %if (streamX_handle # 0) %start
  924              put char( streamX_handle, c)
  925              %if (c = nl) %then flush output 
  926          %finish
  927      %end
  928  
  929      %external %routine print real( %long %real d )
  930          %record(impstream)%name streamX
  931  
  932          %if need to initialise %then initialise io system
  933  
  934          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  935  
  936          streamX == out_streams( out_current stream )
  937  !        %if (out_current stream = 0) %then streamX == out_stream0
  938  !        %if (out_current stream = 1) %then streamX == out_stream1
  939  !        %if (out_current stream = 2) %then streamX == out_stream2
  940  !        %if (out_current stream = 3) %then streamX == out_stream3
  941  
  942          %signal 9, 5, out_current stream %unless (streamX_handle # 0)
  943  
  944          ! Not sure what the official IMP behaviour is for output on a closed file.
  945          ! We choose to silently ignore it...
  946          ! check file open before writing?
  947          %if (streamX_handle # 0) %then put double( streamX_handle, d)
  948      %end
  949  !------------------------------------------------------------------------------
  950  ! Initialisation routines
  951  !------------------------------------------------------------------------------
  952      %external %routine initialise io system
  953          %integer i
  954  
  955          null stream_handle = 0
  956          null stream_file name = "null"
  957  
  958          initialise input system
  959          initialise output system
  960  
  961          initialised state = initialised
  962      %end
?I unused
  963  
  964      %external %routine terminate io system
  965          terminate input system
  966          terminate output system
  967  
  968          initialised state = uninitialised
  969      %end
  970  
  971      %routine parse input list( %string(255) list )
  972          %string(255) x,a,c,mode,file
  973          %integer streamid
  974  
  975          x = list
  976          streamid = 1
  977          %while length(x) > 0 %cycle
  978  
  979              %exit %unless (1 <= streamid <= MAX INPUT STREAM)
  980  
  981              ! split the comma separated list
  982              length(a) = 0
  983              length(c) = 0
  984              x->a.(",").c
  985  
  986              %exit %unless length(a) > 0
  987  
  988              file = a
  989              length(mode) = 0
  990              %if (charno(a,length(a)) = 'b') %and (charno(a,length(a) - 1 ) = ':') %start
  991                  length(file) = length(file) - 2
  992                  mode = ":b"
  993              %finish
  994  
  995              %exit %unless length( file ) > 0
  996  
  997              %if length(mode) = 0 %start
  998                  open input( streamid, file )
  999              %finish %else %start
  1000                  open binary input( streamid, file )
  1001              %finish
  1002                  
  1003              x = c
  1004              streamid = streamid + 1
  1005          %repeat
  1006      %end
  1007  
  1008      %routine parse output list( %string(255) list )
  1009          %string(255) x,a,c,mode,file
  1010          %integer streamid
  1011  
  1012          x = list
  1013          streamid = 1
  1014          %while length(x) > 0 %cycle
  1015  
  1016              %exit %unless (1 <= streamid <= MAX OUTPUT STREAM)
  1017  
  1018              ! split the comma separated list
  1019              length(a) = 0
  1020              length(c) = 0
  1021              x->a.(",").c
  1022  
  1023              %exit %unless length(a) > 0
  1024  
  1025              file = a
  1026              length(mode) = 0
  1027              %if (charno(a,length(a)) = 'b') %and (charno(a,length(a) - 1 ) = ':') %start
  1028                  length(file) = length(file) - 2
  1029                  mode = ":b"
  1030              %finish
  1031  
  1032              %exit %unless length( file ) > 0
  1033  
  1034              %if length(mode) = 0 %start
  1035                  open output( streamid, file )
  1036              %finish %else %start
  1037                  open binary output( streamid, file )
  1038              %finish
  1039                  
  1040              x = c
  1041              streamid = streamid + 1
  1042          %repeat
  1043      %end
  1044  
  1045      %external %integer %function split io list ( %string(255) io list )
  1046          %string(255) s,a,b,c
  1047  
  1048          s = io list
  1049          length(a) = 0
  1050          b = tostring(FILE SEP)
  1051          length(c) = 0
  1052  
  1053          s -> a.(b).c
  1054  
  1055          %if length( a ) > 0 %then parse input list( a )
  1056          %if length( c ) > 0 %then parse output list( c )
  1057  
  1058          %result = 0
  1059      %end
  1060  
  1061  %endoffile

  591 Statements compiled
