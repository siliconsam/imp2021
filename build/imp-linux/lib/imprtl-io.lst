         Edinburgh IMP77 Compiler - Version 8.4

   1  
   2      %include "inc.386.registers"
 &  1  %endoflist
 & 10  %endoffile
   3  
   4      %external %routine %spec initialise io system
   5  
   6      %constinteger integersize   = 4
   7      %constinteger realsize      = 4
   8      ! we don't define stringsize as it could be in range 1..255
   9      ! we don't define recordsize as it depends on the record format
   10      %constinteger bytesize      = 1
   11      %constinteger longrealsize  = 8
   12  
   13      ! Curious naming strategy because we don't want to clobber
   14      ! the built-in functions and maps like "integer" or "int"
   15      ! Types extracted from general names
   16      %constinteger      integertype = 1
   17      %constinteger         realtype = 2
   18      %constinteger       stringtype = 3
   19      %constinteger       recordtype = 4
   20      %constinteger         bytetype = 5
   21      %constinteger shortintegertype = 6
   22      %constinteger  longintegertype = 7
   23      %constinteger     longrealtype = 8
   24  
   25      ! Assign the constant values
   26      %constant %integer std null handle = 0
   27      %constant %integer std err handle  = 1
   28      %constant %integer std in handle   = 2
   29      %constant %integer std out handle  = 3
   30  
   31      ! To ensure that the compiler can compile itself
   32      ! We need a minimum number of INPUT/OUTPUT Streams
   33      ! These minimum numbers depend on the depth of %include files
   34      ! for MAX INPUT STREAM
   35      ! The number of output files used by the takeon, pass1, pass2
   36      ! programs will affect the value of MAX OUTPUI STREAM
   37      ! Currently, the bare minimum value for MAX INPUT STREAM is 4
   38      ! Currently, the bare minimum value for MAX OUTPUT STREAM is 3
   39  
   40      ! It is perfectly legal to increase the values of MAX XXX STREAM
   41      ! to be more than the minimum MAX XXX STREAM values given above
   42      %constant %integer MAX INPUT STREAM  = 4
   43      %constant %integer MAX OUTPUT STREAM = 4
   44  
   45      %constant %integer IS INPUT = 0 << 0
   46      %constant %integer IS OUTPUT = 1 << 0
   47      %constant %integer IS TEXT = 0 << 1
   48      %constant %integer IS BINARY = 1 << 1
   49  
   50      %constant %integer uninitialised = 0
   51      %constant %integer initialised = 1
   52  
   53      %record %format impstream ( %integer empty,lookahead, flags, %string(255) file name, %integer handle )
   54      %record %format impinput ( %integer current stream, 
   55+                                %record(impstream) %array streams(0:MAX INPUT STREAM) )
   56      %record %format impoutput ( %integer current stream, 
   57+                                 %record(impstream) %array streams(0:MAX OUTPUT STREAM) )
   58  
   59      %own %record (impinput) in
   60      %own %record (impoutput) out
   61      %own %record (impstream) null stream
   62      %own %record (impstream) error stream
   63  
   64      %own %integer initialised state = uninitialised
   65      %external %integer fileerror %alias "_errno"
   66  
   67      %own %integer eof flag = 1
   68  
   69      !--------------------------------------------------------------------------
   70      %external %routine allow eof event
   71          eof flag = 1
   72      %end
   73  
   74      !--------------------------------------------------------------------------
   75      %external %routine block eof event
   76          eof flag = 0
   77      %end
   78  
   79      !--------------------------------------------------------------------------
   80      ! This converts an IMP string in-situ to become a C string
   81      ! We just need the address of the IMP string
   82      %routine imptocstring( %string(*) %name impstring )
   83          %integer len,i
   84          %byte %integer %name src
   85  
   86          %if addr( impstring ) # 0 %start
   87              ! Find the length of the IMP format string
   88              len = length( impstring )
   89  
   90              ! Convert to a C format string
   91              ! We do this in one step 0..len-1
   92              ! copying from impstring(i+1) to impstring(i)
   93              ! lastly, store 0 in impstring(len)
   94              %for i = 0,1,len - 1 %cycle
   95                  src == byteinteger( addr( impstring ) + i + 1)
   96                  charno( impstring, i ) = src
   97              %repeat
   98              charno( impstring, len ) = 0
   99          %finish
  100      %end
  101  
  102      !--------------------------------------------------------------------------
  103      %external %predicate need to initialise
  104          %true %if (initialised state = uninitialised)
  105          %false
  106      %end
  107  
  108      !--------------------------------------------------------------------------
  109      %routine initialise stream( %record(impstream) %name s )
  110          s_handle = 0
  111          length(s_file name) = 0
  112          s_flags = 0
  113          s_lookahead = -1
  114          s_empty = 1
  115      %end
  116  
  117      !--------------------------------------------------------------------------
  118      %routine finalise stream( %record(impstream) %name s )
  119          %if (s_handle # 0) %then close( s_handle )
  120  
  121          initialise stream( s )
  122      %end
  123  
  124      !--------------------------------------------------------------------------
  125      %predicate acceptabletype( %integer type )
  126          %true %if (type = integertype)
  127          %true %if (type = realtype)
  128          %true %if (type = stringtype)
  129          %true %if (type = recordtype)
  130          %true %if (type = bytetype)
  131          %true %if (type = longrealtype)
  132          %false
  133      %end
  134  
  135      %own %string(31) input prompt = "prompt ->"
  136      %own %integer tty needs a prompt = 1
  137  
  138      !--------------------------------------------------------------------------
  139      %external %routine prompt( %string(31) s )
  140          input prompt = s
  141      %end
  142  
  143  !------------------------------------------------------------------------------
  144  ! Input routines
  145  !------------------------------------------------------------------------------
  146  
  147      !--------------------------------------------------------------------------
  148      %routine initialise input system
  149          %record(impstream)%name streamX
  150          %integer i
  151  
  152          in_current stream = 0
  153  
  154          %for i = 0,1,MAX INPUT STREAM %cycle
  155              streamX == in_streams(i)
  156              initialise stream( streamX )
  157          %repeat
  158          in_streams(0)_handle = get std in handle
  159          in_streams(0)_file name = "stdin" 
  160      %end
  161  
  162      !--------------------------------------------------------------------------
  163      %routine terminate input system
  164          %record(impstream)%name streamX
  165          %integer i
  166  
  167          in_current stream = -1
  168  
  169          %for i = 1,1,MAX INPUT STREAM %cycle
  170              streamX == in_streams(i)
  171              finalise stream( streamX )
  172          %repeat
  173      %end
  174  
  175      !--------------------------------------------------------------------------
  176      %external %integer %function readbuffer( %name ptr, %integer count )
  177          %record(impstream)%name streamX
  178          %integer i,actualcount
  179          %integer len,adr,type
  180          %integer itemsz
  181  
  182          len = size of(ptr)
  183          adr = addr(ptr)
  184          type = type of(ptr)
  185  
  186  %if ((DEBUGMODE & dbgio) # 0) %start
  187  debug string("READBUFFER: address(ptr)=".int2ascii(adr,16,0) );  debug newline
  188  debug string("READBUFFER: size of(ptr)=".int2ascii(len,16,0) );  debug newline
  189  debug string("READBUFFER: type of(ptr)=".int2ascii(type,16,0) ); debug newline
  190  debug string("READBUFFER:        count=".itos(count,0) );        debug newline
  191  %finish
  192  
  193          %signal 5,5,type %unless acceptabletype(type)
  194  
  195          ! assume we are reading data into a byte array (or string)
  196          itemsz = -1
  197  
  198          %if (type = integertype)  %then itemsz = integersize
  199          %if (type = realtype)     %then itemsz = realsize
  200          %if (type = stringtype)   %then itemsz = len
  201          %if (type = bytetype)     %then itemsz = bytesize
  202          %if (type = longrealtype) %then itemsz = longrealsize
  203          %if (type = recordtype)   %then itemsz = len
  204  
  205          %if need to initialise %then initialise io system
  206  
  207          ! can't select an invalid stream id (not stdin)
  208          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  209          ! can't select a closed file
  210          streamX == in_streams( in_current stream )
  211  
  212          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  213  
  214          ! We actually load the buffer as an array of bytes
  215          ! We need the stream handle, count of items space, item size, buffer address
  216          ! Where, count * itemsz = size in bytes of buffer storage
  217          actualcount = readbytes( streamX_handle, count, itemsz, byteinteger( addr(ptr) ) )
  218  
  219          ! If we are storing in an IMP string then we need to convert the stored buffer
  220          ! from C string format (zero start index)  to IMP string format
  221          %if (0 <= len <= 255) %and (type of(ptr) = stringtype) %start
  222              ! It is a string!!
  223              ! Therefore we need to move the chars from n to n+1 location
  224              ! Thus, we can store the IMP string length in location 0 (its expected location)
  225              ! Use actualcount as number of chars in the string
  226              ! JDM should check that actualcount < count else buffer overflow
  227              %for i=actualcount-1,-1,0 %cycle
  228                  charno( string(addr(ptr)), i + 1 ) = charno( string(addr(ptr)), i )
  229              %repeat
  230              charno( string(addr(ptr)),0 ) = actualcount
  231          %finish
  232  
  233          %result = actualcount
  234      %end
  235  
  236      !--------------------------------------------------------------------------
  237      %external %integer %function input stream
  238          %if need to initialise %then initialise io system
  239  
  240          %result = in_current stream
  241      %end
  242  
  243      !--------------------------------------------------------------------------
  244      %external %routine reset input
  245          %record(impstream)%name streamX
  246  
  247          %if need to initialise %then initialise io system
  248  
  249          ! can't select an invalid stream id (not stdin)
  250          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  251          ! can't select a closed file
  252          streamX == in_streams( in_current stream )
  253  
  254          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  255  
  256          file rewind( streamX_handle )
  257      %end
  258  
  259      !--------------------------------------------------------------------------
  260      %external %routine seek input( %integer displacement, pos )
  261          %record(impstream)%name streamX
  262  
  263          %if need to initialise %then initialise io system
  264  
  265          ! can't select an invalid stream id (not stdin)
  266          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  267          ! can't select a closed file
  268          streamX == in_streams( in_current stream )
  269  
  270          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  271  
  272          %if (0 <= pos <= 2) %then file seek( streamX_handle, displacement, pos )
  273      %end
  274  
  275      !--------------------------------------------------------------------------
  276      %external %integer %function tell input
  277          %record(impstream)%name streamX
  278  
  279          %if need to initialise %then initialise io system
  280  
  281          ! can't select an invalid stream id (not stdin)
  282          %signal 9, 9 %unless (0 < in_current stream <= MAX INPUT STREAM)
  283          ! can't select a closed file
  284          streamX == in_streams( in_current stream )
  285  
  286          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  287  
  288          %result = tell( streamX_handle )
  289      %end
  290  
  291      !--------------------------------------------------------------------------
  292      %external %string(255) %function input name
  293          %record(impstream)%name streamX
  294          %string(255) name
  295  
  296          %if need to initialise %then initialise io system
  297  
  298          ! can't select an invalid stream id
  299          %signal 9, 9 %unless (0 <= in_current stream <= MAX INPUT STREAM)
  300          ! can't select a closed file
  301          streamX == in_streams( in_current stream )
  302  
  303          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  304  
  305          name = streamX_file name
  306  
  307          %result = name
  308      %end
  309  
  310      !--------------------------------------------------------------------------
  311      %external %routine select input( %integer stream id )
  312          %record(impstream)%name streamX
  313  
  314          %if need to initialise %then initialise io system
  315  
  316          ! can't select an invalid stream id
  317          %signal 9, 9 %unless (0 <= stream id <= MAX INPUT STREAM)
  318          ! can't select a closed file
  319          streamX == in_streams( stream id )
  320  
  321          %signal 9, 4, stream id %if (streamX_handle = 0)
  322  
  323          in_current stream = stream id
  324      %end
  325  
  326      !--------------------------------------------------------------------------
  327      %external %routine close input
  328          %record(impstream)%name streamX
  329  
  330          %if need to initialise %then initialise io system
  331  
  332          ! can't close terminal input
  333          ! can't close an already closed file
  334          %if (0 < in_current stream <= MAX INPUT STREAM ) %start
  335              streamX == in_streams( in_current stream )
  336  
  337              %if (streamX_handle # 0) %start
  338                  close( streamX_handle )
  339                  initialise stream( streamX )
  340              %finish
  341          %finish
  342      %end
  343  
  344      !--------------------------------------------------------------------------
  345      %external %routine open input( %integer stream  id, %string(255) file name )
  346          %record(impstream)%name streamX
  347          %integer handle
  348          %integer flags = IS INPUT ! IS TEXT
  349          %string(4) mode = "r"
  350          %string(255) xxx
  351          %string(4) yyy
  352  
  353          %if need to initialise %then initialise io system
  354  
  355          ! Error out if streamid not in legal range
  356          %signal 9, 9, stream id %unless (0 < stream id <= MAX INPUT STREAM )
  357  
  358          ! If file not open
  359          streamX == in_streams( stream id )
  360  
  361          %if (streamX_handle = 0) %start
  362  
  363              xxx = filename
  364              yyy = mode
  365  
  366              ! Tweak xxx,yyy to be C strings
  367              ! Why? because we are sending them to a C function expecting C strings
  368              imptocstring( xxx )
  369              imptocstring( yyy )
  370  
  371              handle = openfile( addr(yyy), addr(xxx) )
  372  
  373              %if (handle = 0) %start
  374  
  375  %if ((DEBUGMODE & dbgio) # 0) %start
  376  debugstring("OPENINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  377  debugnewline
  378  %finish
  379                  %signal 9, 2, get error
  380              %else
  381  
  382  %if ((DEBUGMODE & dbgio) # 0) %start
  383  debugstring("OPENINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  384  debugnewline
  385  %finish
  386                  streamX == in_streams( stream id )
  387  
  388                  streamX_handle = handle
  389                  streamX_file name = file name
  390                  streamX_flags = flags
  391              %finish
  392          %finish
  393      %end
  394  
  395      !--------------------------------------------------------------------------
  396      %external %routine open binary input( %integer stream  id, %string(255) file name )
  397          %record(impstream)%name streamX
  398          %integer handle
  399          %integer flags = IS INPUT ! IS BINARY
  400          %string(4) mode = "rb"
  401          %string(255) xxx
  402          %string(4) yyy
  403  
  404          %if need to initialise %then initialise io system
  405  
  406          %signal 9, 9, stream id %unless (0 < stream id <= MAX INPUT STREAM )
  407  
  408          ! If file not open
  409          streamX == in_streams( stream id )
  410  
  411          %if (streamX_handle = 0) %start
  412  
  413              xxx = filename
  414              yyy = mode
  415  
  416              ! Tweak xxx,yyy to be C strings
  417              ! Why? because we are sending them to a C function expecting C strings
  418              imptocstring( xxx )
  419              imptocstring( yyy )
  420  
  421              handle = openfile( addr(yyy), addr(xxx) )
  422  
  423              %if (handle = 0) %start
  424  
  425  %if ((DEBUGMODE & dbgio) # 0) %start
  426  debugstring("OPENBINARYINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  427  debugnewline
  428  %finish
  429                  %signal 9, 2, get error
  430              %else
  431  
  432  %if ((DEBUGMODE & dbgio) # 0) %start
  433  debugstring("OPENBINARYINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  434  debugnewline
  435  %finish
  436                  streamX == in_streams( stream id )
  437  
  438                  streamX_handle = handle
  439                  streamX_file name = file name
  440                  streamX_flags = flags
  441              %finish
  442          %finish
  443      %end
  444  
  445      !--------------------------------------------------------------------------
  446      %external %integer %function next symbol
  447          %record(impstream)%name streamX
  448          %integer ch,i
  449  
  450          %if need to initialise %then initialise io system
  451  
  452          %signal 9, 9, in_current stream %unless (0 <= in_current stream <= MAX INPUT STREAM )
  453  
  454          streamX == in_streams( in_current stream )
  455  
  456          %signal 9, 4, in_current stream %if (streamX_handle = 0)
  457  
  458          ! Check to see if we already have a lookahead char (actually integer)
  459          %if (streamX_empty = 1) %start
  460              %if (in_current stream = 0) %start
  461                  %if (tty needs a prompt # 0) %start
  462                      tty needs a prompt = 0;
  463  
  464                      %for i = 1,1,length( input prompt ) %cycle
  465                          put char( error stream_handle, charno( input prompt, i ) )
  466                      %repeat
  467  
  468                  %finish
  469              %finish
  470  
  471              ! remember ch for future use
  472              streamX_lookahead = get char ( streamX_handle )
  473              streamX_empty = 0
  474  
  475              ! NL => we should prompt next time
  476              %if (in_current stream = 0) %and (ch = nl) %then tty needs a prompt = 1;
  477  
  478              ! Are we attempting to read after the end of file
  479              %signal 9,0, in_current stream %if (eof flag = 1) %and (streamX_lookahead < 0)
  480  
  481          %finish
  482  
  483          streamX_empty = 0
  484          %result = streamX_lookahead
  485      %end
  486  
  487      !--------------------------------------------------------------------------
  488      %external %routine read symbol( %integer %name ch )
  489          %record(impstream)%name streamX
  490  
  491          %if need to initialise %then initialise io system
  492  
  493          streamX == in_streams( in_current stream )
  494          streamX_lookahead = next symbol
  495  
  496          ! Are we attempting to read after the end of file
  497          %signal 9,1, in_current stream %if (eof flag = 1) %and (streamX_lookahead < 0)
  498  
  499          ! indicate we need to read the next char in the input stream
  500          ! on the next call to either next symbol, read symbol
  501          streamX_empty = 1
  502          ch = streamX_lookahead
  503  
  504      %end
  505  
  506      !--------------------------------------------------------------------------
  507      %external %routine skipsymbol
  508          %integer trash
  509  
  510          readsymbol(trash)
  511      %end
  512  
  513  !------------------------------------------------------------------------------
  514  ! Output routines
  515  !------------------------------------------------------------------------------
  516  
  517      !--------------------------------------------------------------------------
  518      %routine initialise output system
  519          %record(impstream)%name streamX
  520  
  521          %integer i
  522  
  523          out_current stream = 0
  524  
  525          %for i = 0,1,MAX OUTPUT STREAM %cycle
  526              streamX == out_streams(i)
  527              initialise stream( streamX )
  528          %repeat
  529  
  530          streamX == out_streams(0)
  531  
  532          streamX_handle = get std out handle
  533          streamX_file name = "stdout"
  534          streamX_flags = IS OUTPUT ! IS TEXT
  535  
  536          ! Don't forget to initialise the debug output stream
  537          streamX == error stream
  538          initialise stream( streamX )
  539          streamX_handle = get std err handle
  540          streamX_file name = "stderr"
  541          streamX_flags = IS OUTPUT ! IS TEXT
  542      %end
  543  
  544      !--------------------------------------------------------------------------
  545      %routine terminate output system
  546          %record(impstream)%name streamX
  547          %integer i
  548  
  549          out_current stream = -1
  550  
  551          %for i = 1,1,MAX OUTPUT STREAM %cycle
  552              streamX == out_streams(i)
  553              finalise stream( streamX )
  554          %repeat
  555      %end
  556  
  557      !--------------------------------------------------------------------------
  558      %external %routine debug symbol( %integer c )
  559          %if need to initialise %then initialise io system
  560  
  561          %if (error stream_handle # 0) %then put char( error stream_handle, c )
  562      %end
  563  
  564      !--------------------------------------------------------------------------
  565      %external %routine debug real( %long %real d )
  566          %if need to initialise %then initialise io system
  567  
  568          %if (error stream_handle # 0) %then put double( error stream_handle, d )
  569      %end
  570  
  571      !--------------------------------------------------------------------------
  572      %external %integer %function writebuffer( %name ptr, %integer count )
  573          %record(impstream)%name streamX
  574          %integer len,adr,type
  575          %integer itemsz
  576          %integer i
  577          %integer res
  578  
  579          len = size of(ptr)
  580          adr = addr(ptr)
  581          type = type of(ptr)
  582  
  583  %if ((DEBUGMODE & dbgio) # 0) %start
  584  debug string("READBUFFER: address(ptr)=".int2ascii(adr,16,0) );  debug newline
  585  debug string("READBUFFER: size of(ptr)=".int2ascii(len,16,0) );  debug newline
  586  debug string("READBUFFER: type of(ptr)=".int2ascii(type,16,0) ); debug newline
  587  debug string("READBUFFER:        count=".itos(count,0) );        debug newline
  588  %finish
  589  
  590          ! check if we can write a valid data type
  591          %signal 5,5,type %unless acceptabletype(type) %and (len = count)
  592  
  593          ! assume we are reading data into a byte array (or string)
  594          itemsz = -1
  595  
  596          %if (type = integertype)  %then itemsz = integersize
  597          %if (type = realtype)     %then itemsz = realsize
  598          %if (type = stringtype)   %then itemsz = len
  599          %if (type = bytetype)     %then itemsz = bytesize
  600          %if (type = longrealtype) %then itemsz = longrealsize
  601          %if (type = recordtype)   %then itemsz = len
  602  
  603          %if need to initialise %then initialise io system
  604  
  605          ! can't select an invalid stream id (not stdout)
  606          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  607          ! can't select a closed file
  608          streamX == out_streams( out_current stream )
  609  
  610          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  611  
  612          ! We actually load the buffer as an array of bytes
  613          ! We need the stream handle, count of items space, item size, buffer address
  614          ! Where, count * itemsz = size in bytes of buffer storage
  615          %result = writebytes( streamX_handle, count, itemsz, byteinteger( addr(ptr) ) )
  616      %end
?RES unused
?I unused
  617  
  618      !--------------------------------------------------------------------------
  619      %external %integer %function output stream
  620          %if need to initialise %then initialise io system
  621  
  622          %result = out_current stream
  623      %end
  624  
  625      !--------------------------------------------------------------------------
  626      %external %routine reset output
  627          %record(impstream)%name streamX
  628  
  629          %if need to initialise %then initialise io system
  630  
  631          ! can't select an invalid stream id (not stdout)
  632          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  633          ! can't select a closed file
  634          streamX == out_streams( out_current stream )
  635  
  636          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  637  
  638          file rewind( streamX_handle )
  639      %end
  640  
  641      !--------------------------------------------------------------------------
  642      %external %routine seek output( %integer displacement, pos )
  643          %record(impstream)%name streamX
  644  
  645          %if need to initialise %then initialise io system
  646  
  647          ! can't select an invalid stream id (not stdout)
  648          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  649          ! can't select a closed file
  650          streamX == out_streams( out_current stream )
  651  
  652          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  653  
  654          %if (0 <= pos <= 2) %start
  655              file seek( streamX_handle, displacement, pos )
  656          %finish
  657      %end
  658  
  659      !--------------------------------------------------------------------------
  660      %external %integer %function tell output
  661          %record(impstream)%name streamX
  662  
  663          %if need to initialise %then initialise io system
  664  
  665          ! can't select an invalid stream id (not stdout)
  666          %signal 9, 9 %unless (0 < out_currentstream <= MAX OUTPUT STREAM)
  667          ! can't select a closed file
  668          streamX == out_streams( out_current stream )
  669  
  670          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  671  
  672          %result = tell( streamX_handle )
  673      %end
  674  
  675      !--------------------------------------------------------------------------
  676      %external %string(255) %function output name
  677          %record(impstream)%name streamX
  678  
  679          %if need to initialise %then initialise io system
  680  
  681          ! can't select an invalid stream id
  682          %signal 9, 9 %unless (0 <= out_current stream <= MAX OUTPUT STREAM)
  683          ! can't select a closed file
  684          streamX == out_streams( out_current stream )
  685  
  686          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  687  
  688          %result = streamX_file name
  689      %end
  690  
  691      !--------------------------------------------------------------------------
  692      %external %routine select output( %integer stream id )
  693          %record(impstream)%name streamX
  694  
  695          %if need to initialise %then initialise io system
  696  
  697          ! can't select an invalid stream id
  698          %signal 9, 9 %unless (0 <= stream id <= MAX OUTPUT STREAM)
  699  
  700          ! can't select a closed file
  701          streamX == out_streams( stream id )
  702  
  703          %signal 9, 5, stream id %if (streamX_handle = 0)
  704  
  705          out_current stream = stream id
  706      %end
  707  
  708      !--------------------------------------------------------------------------
  709      %external %routine close output
  710          %record(impstream)%name streamX
  711  
  712          %if need to initialise %then initialise io system
  713  
  714          ! can't close terminal output
  715          ! can't close an already closed file
  716          %if (0 < out_current stream <= MAX OUTPUT STREAM ) %start
  717              streamX == out_streams( out_current stream )
  718  
  719              %if (streamX_handle # 0) %start
  720                  close( streamX_handle )
  721                  initialise stream( streamX )
  722              %finish
  723          %finish
  724      %end
  725  
  726      !--------------------------------------------------------------------------
  727      %external %routine open output( %integer stream  id, %string(255) file name )
  728          %record(impstream)%name streamX
  729          %integer handle
  730          %integer flags = IS OUTPUT ! IS TEXT
  731          %string(4) mode = "w"
  732          %string(255) xxx
  733          %string(4) yyy
  734  
  735          %if need to initialise %then initialise io system
  736  
  737          ! Error out if streamid not in legal range
  738          %signal 9, 9, stream id %unless (0 < stream id <= MAX OUTPUT STREAM )
  739  
  740          ! If file not open
  741          streamX == out_streams( stream id )
  742  
  743          %if (streamX_handle = 0) %start
  744              xxx = filename
  745              yyy = mode
  746  
  747              ! Tweak xxx,yyy to be C strings
  748              ! Why? because we are sending them to a C function expecting C strings
  749              imptocstring( xxx )
  750              imptocstring( yyy )
  751  
  752              handle = openfile( addr(yyy), addr(xxx) )
  753  
  754              %if (handle = 0) %start
  755  
  756  %if ((DEBUGMODE & dbgio) # 0) %start
  757  debugstring("OPENOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  758  debugnewline
  759  %finish
  760                  %signal 9, 2, get error
  761              %else
  762  
  763  %if ((DEBUGMODE & dbgio) # 0) %start
  764  debugstring("OPENOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  765  debugnewline
  766  %finish
  767                  streamX_handle = handle
  768                  streamX_file name = file name
  769                  streamX_flags = flags
  770              %finish
  771          %finish
  772      %end
  773  
  774      !--------------------------------------------------------------------------
  775      %external %routine open binary output( %integer stream  id, %string(255) file name )
  776          %record(impstream)%name streamX
  777          %integer handle
  778          %integer flags = IS OUTPUT ! IS BINARY
  779          %string(4) mode = "wb"
  780          %string(255) xxx
  781          %string(4) yyy
  782  
  783          %if need to initialise %then initialise io system
  784  
  785          %signal 9, 9, stream id %unless (0 < stream id <= MAX OUTPUT STREAM )
  786  
  787          ! If file not open
  788          streamX == out_streams( stream id )
  789  
  790          %if (streamX_handle = 0) %start
  791              xxx = filename
  792              yyy = mode
  793  
  794              ! Tweak xxx,yyy to be C strings
  795              ! Why? because we are sending them to a C function expecting C strings
  796              imptocstring( xxx )
  797              imptocstring( yyy )
  798  
  799              handle = openfile( addr(yyy), addr(xxx) )
  800  
  801              %if (handle = 0) %start
  802  
  803  %if ((DEBUGMODE & dbgio) # 0) %start
  804  debugstring("OPENBINARYOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
  805  debugnewline
  806  %finish
  807                  %signal 9, 2, get error
  808              %else
  809  
  810  %if ((DEBUGMODE & dbgio) # 0) %start
  811  debugstring("OPENBINARYOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
  812  debugnewline
  813  %finish
  814                  streamX_handle = handle
  815                  streamX_file name = file name
  816                  streamX_flags = flags
  817              %finish
  818          %finish
  819      %end
  820  
  821      !--------------------------------------------------------------------------
  822      %external %routine flush output
  823          %record(impstream)%name streamX
  824  
  825          %if need to initialise %then initialise io system
  826  
  827          ! only interrogate actual opened files (including stdout)
  828          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  829  
  830          streamX == out_streams( out_current stream )
  831  
  832          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  833  
  834          flush( streamX_handle )
  835      %end
  836  
  837      !--------------------------------------------------------------------------
  838      %external %routine print symbol( %integer c )
  839          %record(impstream)%name streamX
  840  
  841          %if need to initialise %then initialise io system
  842  
  843          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  844  
  845          streamX == out_streams( out_current stream )
  846  
  847          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  848  
  849          ! Not sure what the official IMP behaviour is for output on a closed file.
  850          ! We choose to silently ignore it...
  851          ! check file open before writing?
  852          %if (streamX_handle # 0) %start
  853              put char( streamX_handle, c)
  854              %if (c = nl) %then flush output 
  855          %finish
  856      %end
  857  
  858      !--------------------------------------------------------------------------
  859      %external %routine print real( %long %real d )
  860          %record(impstream)%name streamX
  861  
  862          %if need to initialise %then initialise io system
  863  
  864          %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAX OUTPUT STREAM )
  865  
  866          streamX == out_streams( out_current stream )
  867  
  868          %signal 9, 5, out_current stream %if (streamX_handle = 0)
  869  
  870          ! Not sure what the official IMP behaviour is for output on a closed file.
  871          ! We choose to silently ignore it...
  872          ! check file open before writing?
  873          %if (streamX_handle # 0) %then put double( streamX_handle, d)
  874      %end
  875  
  876  !------------------------------------------------------------------------------
  877  ! Initialisation routines
  878  !------------------------------------------------------------------------------
  879  
  880      !--------------------------------------------------------------------------
  881      %external %routine initialise io system
  882          %integer i
  883  
  884          null stream_handle = 0
  885          null stream_file name = "null"
  886  
  887          initialise input system
  888          initialise output system
  889  
  890          initialised state = initialised
  891      %end
?I unused
  892  
  893      !--------------------------------------------------------------------------
  894      %external %routine terminate io system
  895          terminate input system
  896          terminate output system
  897  
  898          initialised state = uninitialised
  899      %end
  900  
  901      !--------------------------------------------------------------------------
  902      %routine parse input list( %string(255) list )
  903          %string(255) x,a,c,mode,file
  904          %integer streamid
  905  
  906          x = list
  907          streamid = 1
  908          %while length(x) > 0 %cycle
  909  
  910              %exit %unless (1 <= streamid <= MAX INPUT STREAM)
  911  
  912              ! split the comma separated list
  913              length(a) = 0
  914              length(c) = 0
  915              x->a.(",").c
  916  
  917              %exit %unless length(a) > 0
  918  
  919              file = a
  920              length(mode) = 0
  921              %if (charno(a,length(a)) = 'b') %and (charno(a,length(a) - 1 ) = ':') %start
  922                  length(file) = length(file) - 2
  923                  mode = ":b"
  924              %finish
  925  
  926              %exit %unless length( file ) > 0
  927  
  928              %if length(mode) = 0 %start
  929                  open input( streamid, file )
  930              %finish %else %start
  931                  open binary input( streamid, file )
  932              %finish
  933                  
  934              x = c
  935              streamid = streamid + 1
  936          %repeat
  937      %end
  938  
  939      !--------------------------------------------------------------------------
  940      %routine parse output list( %string(255) list )
  941          %string(255) x,a,c,mode,file
  942          %integer streamid
  943  
  944          x = list
  945          streamid = 1
  946          %while length(x) > 0 %cycle
  947  
  948              %exit %unless (1 <= streamid <= MAX OUTPUT STREAM)
  949  
  950              ! split the comma separated list
  951              length(a) = 0
  952              length(c) = 0
  953              x->a.(",").c
  954  
  955              %exit %unless length(a) > 0
  956  
  957              file = a
  958              length(mode) = 0
  959              %if (charno(a,length(a)) = 'b') %and (charno(a,length(a) - 1 ) = ':') %start
  960                  length(file) = length(file) - 2
  961                  mode = ":b"
  962              %finish
  963  
  964              %exit %unless length( file ) > 0
  965  
  966              %if length(mode) = 0 %start
  967                  open output( streamid, file )
  968              %finish %else %start
  969                  open binary output( streamid, file )
  970              %finish
  971                  
  972              x = c
  973              streamid = streamid + 1
  974          %repeat
  975      %end
  976  
  977      !--------------------------------------------------------------------------
  978      %external %integer %function split io list ( %string(255) io list )
  979          %string(255) s,a,b,c
  980  
  981          s = io list
  982          length(a) = 0
  983          b = tostring(FILE SEP)
  984          length(c) = 0
  985  
  986          s -> a.(b).c
  987  
  988          %if length( a ) > 0 %then parse input list( a )
  989          %if length( c ) > 0 %then parse output list( c )
  990  
  991          %result = 0
  992      %end
  993  
  994  %endoffile

  605 Statements compiled
