{----------------------------------------------------------------------------}
    %external %routine newline
 0000                      L1000  EQU $
 0000 C8 00 00 01                           ENTER 0000,1
        printsymbol(nl)
 0004 6A 0A                                 PUSH 10
 0006 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0009 83 C4 04                              ADD ESP,4
    %end
 000C C9                                    LEAVE
 000D C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine space
 000E                      L1001  EQU $
 000E C8 00 00 01                           ENTER 0000,1
        printsymbol(' ')
 0012 6A 20                                 PUSH 32
 0014 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0017 83 C4 04                              ADD ESP,4
    %end
 001A C9                                    LEAVE
 001B C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine newlines( %integer count )
 001C                      L1002  EQU $
 001C C8 00 00 01                           ENTER 0000,1
        %while count > 0 %cycle
 0020                      L1003  EQU $
 0020 8B 45 08                              MOV EAX,[EBP+8]
 0023 3D 00 00 00 00                        CMP EAX,0
 0028 7E 00                                 JLE L1004
            printsymbol(nl)
 002A 6A 0A                                 PUSH 10
 002C E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 002F 83 C4 04                              ADD ESP,4
            count = count - 1
 0032 FF 4D 08                              DEC WORD [EBP+8]
        %repeat
 0035 EB 00                                 JMP L1003
 0037                      L1004  EQU $
    %end
 0037 C9                                    LEAVE
 0038 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine spaces(%integer count)
 0039                      L1005  EQU $
 0039 C8 00 00 01                           ENTER 0000,1
        %while count > 0 %cycle
 003D                      L1006  EQU $
 003D 8B 45 08                              MOV EAX,[EBP+8]
 0040 3D 00 00 00 00                        CMP EAX,0
 0045 7E 00                                 JLE L1007
            printsymbol(' ')
 0047 6A 20                                 PUSH 32
 0049 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 004C 83 C4 04                              ADD ESP,4
            count = count - 1
 004F FF 4D 08                              DEC WORD [EBP+8]
        %repeat
 0052 EB 00                                 JMP L1006
 0054                      L1007  EQU $
    %end
 0054 C9                                    LEAVE
 0055 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine printstring( %string(255) s)
 0056                      L1008  EQU $
 0056 C8 00 00 01                           ENTER 0000,1
        %integer l, i

        l = length(s)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 005A 31 C0                                 XOR EAX,EAX
 005C 8A 45 08                              MOV AL,[EBP+8]
 005F 89 45 F8                              MOV [EBP-8],EAX

        %for i = 1, 1, l %cycle
 0062 8B 45 F8                              MOV EAX,[EBP-8]
 0065 89 45 F0                              MOV [EBP-16],EAX
 0068 C7 45 F4 00 00 00 00                  MOV LONG [EBP-12],0
 006F                      L1009  EQU $
 006F 8B 45 F4                              MOV EAX,[EBP-12]
 0072 3B 45 F0                              CMP EAX,[EBP-16]
 0075 74 00                                 JE L1010
 0077 40                                    INC EAX
 0078 89 45 F4                              MOV [EBP-12],EAX
            printsymbol(charno(s, i))
                                      Generating CODE for 'CHARNO' (MACRO 12)
 007B 8D 45 08                              LEA EAX,[EBP+8]
 007E 03 45 F4                              ADD EAX,[EBP-12]
                                      CALL 'CHARNO' (MACRO 12)
 0081 8A 00                                 MOV AL,[EAX]
 0083 25 FF 00 00 00                        AND EAX,255
 0088 50                                    PUSH EAX
 0089 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 008C 83 C4 04                              ADD ESP,4
        %repeat
 008F EB 00                                 JMP L1009
 0091                      L1010  EQU $
    %end
 0091 C9                                    LEAVE
 0092 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %string(255) %function sub string(%string(255) s, %integer from, to)
 0093                      L1011  EQU $
 0093 C8 00 00 01                           ENTER 0000,1
        %integer get, put
        %string(255) temp

        ! Do some defensive error checking first
        %signal 6, 2, from %unless 0 <= from <= length(s)
 0097 8B 45 10                              MOV EAX,[EBP+16]
 009A 3D 00 00 00 00                        CMP EAX,0
 009F 7C 00                                 JL L1012
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 00A1 31 C9                                 XOR ECX,ECX
 00A3 8A 4D 14                              MOV CL,[EBP+20]
 00A6 39 C8                                 CMP EAX,ECX
 00A8 7E 00                                 JLE L1013
 00AA                      L1012  EQU $
 00AA B8 2C 00 00 00                        MOV EAX,44
 00AF 50                                    PUSH EAX
 00B0 B8 06 00 00 00                        MOV EAX,6
 00B5 50                                    PUSH EAX
 00B6 B8 02 00 00 00                        MOV EAX,2
 00BB 50                                    PUSH EAX
 00BC 8B 45 10                              MOV EAX,[EBP+16]
 00BF 50                                    PUSH EAX
 00C0 E8 0B 00                              CALL '_IMPSIGNAL' (EXTERN 11)
 00C3 83 C4 10                              ADD ESP,16
 00C6                      L1013  EQU $
        %signal 6, 2, to   %unless 0 <= to   <= length(s)
 00C6 8B 45 0C                              MOV EAX,[EBP+12]
 00C9 3D 00 00 00 00                        CMP EAX,0
 00CE 7C 00                                 JL L1014
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 00D0 31 C9                                 XOR ECX,ECX
 00D2 8A 4D 14                              MOV CL,[EBP+20]
 00D5 39 C8                                 CMP EAX,ECX
 00D7 7E 00                                 JLE L1015
 00D9                      L1014  EQU $
 00D9 B8 2D 00 00 00                        MOV EAX,45
 00DE 50                                    PUSH EAX
 00DF B8 06 00 00 00                        MOV EAX,6
 00E4 50                                    PUSH EAX
 00E5 B8 02 00 00 00                        MOV EAX,2
 00EA 50                                    PUSH EAX
 00EB 8B 45 0C                              MOV EAX,[EBP+12]
 00EE 50                                    PUSH EAX
 00EF E8 0B 00                              CALL '_IMPSIGNAL' (EXTERN 11)
 00F2 83 C4 10                              ADD ESP,16
 00F5                      L1015  EQU $
        %signal 5, 3       %unless from <= to
 00F5 8B 45 10                              MOV EAX,[EBP+16]
 00F8 3B 45 0C                              CMP EAX,[EBP+12]
 00FB 7E 00                                 JLE L1016
 00FD B8 2E 00 00 00                        MOV EAX,46
 0102 50                                    PUSH EAX
 0103 B8 05 00 00 00                        MOV EAX,5
 0108 50                                    PUSH EAX
 0109 B8 03 00 00 00                        MOV EAX,3
 010E 50                                    PUSH EAX
 010F 31 C0                                 XOR EAX,EAX
 0111 50                                    PUSH EAX
 0112 E8 0B 00                              CALL '_IMPSIGNAL' (EXTERN 11)
 0115 83 C4 10                              ADD ESP,16
 0118                      L1016  EQU $

        ! We don't use string operations, and instead hand-poke
        ! the characters, relying on the compiler primitive map
        ! functions to plant efficient code

        length(temp) = (to - from) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0118 8B 45 0C                              MOV EAX,[EBP+12]
 011B 2B 45 10                              SUB EAX,[EBP+16]
 011E 40                                    INC EAX
 011F 88 85 F4 FE FF FF                     MOV [EBP-268],AL
        put = 1
 0125 C7 45 F4 01 00 00 00                  MOV LONG [EBP-12],1
        get = from
 012C 8B 45 10                              MOV EAX,[EBP+16]
 012F 89 45 F8                              MOV [EBP-8],EAX
        %while get <= to %cycle
 0132                      L1017  EQU $
 0132 8B 45 F8                              MOV EAX,[EBP-8]
 0135 3B 45 0C                              CMP EAX,[EBP+12]
 0138 7F 00                                 JG L1018
            charno(temp, put) = charno(s, get)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 013A 8D 85 F4 FE FF FF                     LEA EAX,[EBP-268]
 0140 03 45 F4                              ADD EAX,[EBP-12]
                                      CALL 'CHARNO' (MACRO 12)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0143 8D 4D 14                              LEA ECX,[EBP+20]
 0146 03 4D F8                              ADD ECX,[EBP-8]
                                      CALL 'CHARNO' (MACRO 12)
 0149 8A 11                                 MOV DL,[ECX]
 014B 88 10                                 MOV [EAX],DL
            put = put + 1
 014D FF 45 F4                              INC WORD [EBP-12]
            get = get + 1
 0150 FF 45 F8                              INC WORD [EBP-8]
        %repeat
 0153 EB 00                                 JMP L1017
 0155                      L1018  EQU $

        %result = temp
 0155 8B 45 08                              MOV EAX,[EBP+8]
 0158 50                                    PUSH EAX
 0159 8D 8D F4 FE FF FF                     LEA ECX,[EBP-268]
 015F 51                                    PUSH ECX
 0160 68 FF 00 00 00                        PUSH 255
 0165 E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 0168 83 C4 0C                              ADD ESP,12
 016B C9                                    LEAVE
 016C C3                                    RET
    %end
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine To Lower(%string(*)%name s)
 016D                      L1019  EQU $
 016D C8 00 00 01                           ENTER 0000,1
        %integer i
        %byte %name p

        %for i=1,1,length(s) %cycle
                                      Generating CODE for 'LENGTH' (MACRO 11)
 0171 8B 45 08                              MOV EAX,[EBP+8]
                                      CALL 'LENGTH' (MACRO 11)
 0174 8A 00                                 MOV AL,[EAX]
 0176 25 FF 00 00 00                        AND EAX,255
 017B 89 45 F0                              MOV [EBP-16],EAX
 017E C7 45 F8 00 00 00 00                  MOV LONG [EBP-8],0
 0185                      L1020  EQU $
 0185 8B 45 F8                              MOV EAX,[EBP-8]
 0188 3B 45 F0                              CMP EAX,[EBP-16]
 018B 74 00                                 JE L1021
 018D 40                                    INC EAX
 018E 89 45 F8                              MOV [EBP-8],EAX
            p == charno(s,i)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0191 8B 45 08                              MOV EAX,[EBP+8]
 0194 03 45 F8                              ADD EAX,[EBP-8]
                                      CALL 'CHARNO' (MACRO 12)
 0197 89 45 F4                              MOV [EBP-12],EAX
            %if 'A' <= p <= 'Z' %then p = p + ('a'-'A')
 019A 8B 75 F4                              MOV ESI,[EBP-12]
 019D 31 C0                                 XOR EAX,EAX
 019F 8A 06                                 MOV AL,[ESI]
 01A1 3D 41 00 00 00                        CMP EAX,65
 01A6 7C 00                                 JL L1022
 01A8 3D 5A 00 00 00                        CMP EAX,90
 01AD 7F 00                                 JG L1022
 01AF 8B 7D F4                              MOV EDI,[EBP-12]
 01B2 80 07 20                              ADD BYTE [EDI],32
 01B5                      L1022  EQU $
        %repeat
 01B5 EB 00                                 JMP L1020
 01B7                      L1021  EQU $
    %end
 01B7 C9                                    LEAVE
 01B8 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %routine To Upper(%string(*)%name s)
 01B9                      L1023  EQU $
 01B9 C8 00 00 01                           ENTER 0000,1
        %integer i
        %byte %name p

        %for i=1,1,length(s) %cycle
                                      Generating CODE for 'LENGTH' (MACRO 11)
 01BD 8B 45 08                              MOV EAX,[EBP+8]
                                      CALL 'LENGTH' (MACRO 11)
 01C0 8A 00                                 MOV AL,[EAX]
 01C2 25 FF 00 00 00                        AND EAX,255
 01C7 89 45 F0                              MOV [EBP-16],EAX
 01CA C7 45 F8 00 00 00 00                  MOV LONG [EBP-8],0
 01D1                      L1024  EQU $
 01D1 8B 45 F8                              MOV EAX,[EBP-8]
 01D4 3B 45 F0                              CMP EAX,[EBP-16]
 01D7 74 00                                 JE L1025
 01D9 40                                    INC EAX
 01DA 89 45 F8                              MOV [EBP-8],EAX
            p == charno(s,i)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 01DD 8B 45 08                              MOV EAX,[EBP+8]
 01E0 03 45 F8                              ADD EAX,[EBP-8]
                                      CALL 'CHARNO' (MACRO 12)
 01E3 89 45 F4                              MOV [EBP-12],EAX
            %if 'a' <= p <= 'z' %then p = p - ('a'-'A')
 01E6 8B 5D F4                              MOV EBX,[EBP-12]
 01E9 31 C0                                 XOR EAX,EAX
 01EB 8A 03                                 MOV AL,[EBX]
 01ED 3D 61 00 00 00                        CMP EAX,97
 01F2 7C 00                                 JL L1026
 01F4 3D 7A 00 00 00                        CMP EAX,122
 01F9 7F 00                                 JG L1026
 01FB 8B 75 F4                              MOV ESI,[EBP-12]
 01FE 80 2E 20                              SUB BYTE [ESI],32
 0201                      L1026  EQU $
        %repeat
 0201 EB 00                                 JMP L1024
 0203                      L1025  EQU $
    %end
 0203 C9                                    LEAVE
 0204 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %string(255) %function trim(%string(255) s, %integer max)
 0205                      L1027  EQU $
 0205 C8 00 00 01                           ENTER 0000,1

        ! Do some defensive error checking first
        %signal 6, 2, max %if max < 0
 0209 8B 45 0C                              MOV EAX,[EBP+12]
 020C 3D 00 00 00 00                        CMP EAX,0
 0211 7D 00                                 JGE L1028
 0213 B8 5A 00 00 00                        MOV EAX,90
 0218 50                                    PUSH EAX
 0219 B8 06 00 00 00                        MOV EAX,6
 021E 50                                    PUSH EAX
 021F B8 02 00 00 00                        MOV EAX,2
 0224 50                                    PUSH EAX
 0225 8B 45 0C                              MOV EAX,[EBP+12]
 0228 50                                    PUSH EAX
 0229 E8 0B 00                              CALL '_IMPSIGNAL' (EXTERN 11)
 022C 83 C4 10                              ADD ESP,16
 022F                      L1028  EQU $

        ! tweak our parameter and return it
        %if length(s) > max %then length(s) = max
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 022F 31 C0                                 XOR EAX,EAX
 0231 8A 45 10                              MOV AL,[EBP+16]
 0234 3B 45 0C                              CMP EAX,[EBP+12]
 0237 7E 00                                 JLE L1029
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0239 8B 45 0C                              MOV EAX,[EBP+12]
 023C 88 45 10                              MOV [EBP+16],AL
 023F                      L1029  EQU $

        %result = s
 023F 8B 45 08                              MOV EAX,[EBP+8]
 0242 50                                    PUSH EAX
 0243 8D 4D 10                              LEA ECX,[EBP+16]
 0246 51                                    PUSH ECX
 0247 68 FF 00 00 00                        PUSH 255
 024C E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 024F 83 C4 0C                              ADD ESP,12
 0252 C9                                    LEAVE
 0253 C3                                    RET
    %end
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %string(255) %function int2ascii( %integer nn, base, places )
 0254                      L1030  EQU $
 0254 C8 00 00 01                           ENTER 0000,1

        %own %string(36) basechar = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        %string(255) reversed, human
        %integer n, np, r, i, negative;

        ! Validate the number base
        ! Since basechar has from 1 to 36 characters,
        !   we can only output numbers to base 2 thru 36.
        ! Of course if we add more characters then ...
        ! NB a number to base 1 cannot sensibly be displayed
        %if (base < 2) %then base = 10
 0258 8B 45 10                              MOV EAX,[EBP+16]
 025B 3D 02 00 00 00                        CMP EAX,2
 0260 7D 00                                 JGE L1031
 0262 C7 45 10 0A 00 00 00                  MOV LONG [EBP+16],10
 0269                      L1031  EQU $
        %if (base > 36) %then base = 10
 0269 8B 45 10                              MOV EAX,[EBP+16]
 026C 3D 24 00 00 00                        CMP EAX,36
 0271 7E 00                                 JLE L1032
 0273 C7 45 10 0A 00 00 00                  MOV LONG [EBP+16],10
 027A                      L1032  EQU $

        length(reversed) = 0
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 027A C6 85 FC FE FF FF 00                  MOV BYTE [EBP-260],0
        n = nn
 0281 8B 45 14                              MOV EAX,[EBP+20]
 0284 89 85 F8 FD FF FF                     MOV [EBP-520],EAX
        %if (n = 0) %start
 028A 8B 85 F8 FD FF FF                     MOV EAX,[EBP-520]
 0290 3D 00 00 00 00                        CMP EAX,0
 0295 75 00                                 JNE L1033
            r = 0
 0297 C7 85 F0 FD FF FF 00 00 00 00         MOV LONG [EBP-528],0
            ! string index starts at 1 - but r starts from 0
            ! so if r = 0 we want char 1 in the "basechar" string etc...
            length(reversed) = length(reversed) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 02A1 FE 85 FC FE FF FF                     INC BYTE [EBP-260]
            charno(reversed,length(reversed)) = charno(basechar,r + 1)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 02A7 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 02AD 31 C9                                 XOR ECX,ECX
 02AF 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 02B5 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 02B7 8B 8D F0 FD FF FF                     MOV ECX,[EBP-528]
 02BD 41                                    INC ECX
                                      Generating CODE for 'CHARNO' (MACRO 12)
 02BE 81 C1 00 00 00 00                     ADD ECX,DATA+0
                                      CALL 'CHARNO' (MACRO 12)
 02C4 8A 11                                 MOV DL,[ECX]
 02C6 88 10                                 MOV [EAX],DL
        %else
 02C8 EB 00                                 JMP L1034
 02CA                      L1033  EQU $
            ! Now to avoid problems with -MAXINT
            %if (n > 0) %start
 02CA 8B 85 F8 FD FF FF                     MOV EAX,[EBP-520]
 02D0 3D 00 00 00 00                        CMP EAX,0
 02D5 7E 00                                 JLE L1035
                negative = 0
 02D7 C7 85 E8 FD FF FF 00 00 00 00         MOV LONG [EBP-536],0
                n = -n
 02E1 F7 9D F8 FD FF FF                     NEG WORD [EBP-520]
            %else
 02E7 EB 00                                 JMP L1036
 02E9                      L1035  EQU $
                negative = 1
 02E9 C7 85 E8 FD FF FF 01 00 00 00         MOV LONG [EBP-536],1
            %finish
 02F3                      L1036  EQU $

            %while (n < 0) %cycle
 02F3                      L1037  EQU $
 02F3 8B 85 F8 FD FF FF                     MOV EAX,[EBP-520]
 02F9 3D 00 00 00 00                        CMP EAX,0
 02FE 7D 00                                 JGE L1038
                np = n // base
 0300 8B 85 F8 FD FF FF                     MOV EAX,[EBP-520]
 0306 99                                    CWD
 0307 F7 7D 10                              IDIV WORD [EBP+16]
 030A 89 85 F4 FD FF FF                     MOV [EBP-524],EAX
                r = (np * base) - n
 0310 8B 85 F4 FD FF FF                     MOV EAX,[EBP-524]
 0316 F7 6D 10                              IMUL WORD [EBP+16]
 0319 2B 85 F8 FD FF FF                     SUB EAX,[EBP-520]
 031F 89 85 F0 FD FF FF                     MOV [EBP-528],EAX
                ! string index starts at 1 - but r starts from 0
                ! so if r = 0 we want char 1 in the "basechar" string etc...
                length(reversed) = length(reversed) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0325 FE 85 FC FE FF FF                     INC BYTE [EBP-260]
                charno(reversed,length(reversed)) = charno(basechar,r + 1)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 032B 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 0331 31 C9                                 XOR ECX,ECX
 0333 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 0339 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 033B 8B 8D F0 FD FF FF                     MOV ECX,[EBP-528]
 0341 41                                    INC ECX
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0342 81 C1 00 00 00 00                     ADD ECX,DATA+0
                                      CALL 'CHARNO' (MACRO 12)
 0348 8A 11                                 MOV DL,[ECX]
 034A 88 10                                 MOV [EAX],DL
                n = np
 034C 8B 85 F4 FD FF FF                     MOV EAX,[EBP-524]
 0352 89 85 F8 FD FF FF                     MOV [EBP-520],EAX
            %repeat
 0358 EB 00                                 JMP L1037
 035A                      L1038  EQU $

            %if (negative > 0) %start
 035A 8B 85 E8 FD FF FF                     MOV EAX,[EBP-536]
 0360 3D 00 00 00 00                        CMP EAX,0
 0365 7E 00                                 JLE L1039
                length(reversed) = length(reversed) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0367 FE 85 FC FE FF FF                     INC BYTE [EBP-260]
                charno(reversed,length(reversed)) = '-'
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 036D 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 0373 31 C9                                 XOR ECX,ECX
 0375 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 037B 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 037D C6 00 2D                              MOV BYTE [EAX],45
            %finish
 0380                      L1039  EQU $
        %finish
 0380                      L1034  EQU $

        ! Now we adjust Places, also slightly mysteriously
        %if places <= 0 %then places = -places %else places = places + 1
 0380 8B 45 0C                              MOV EAX,[EBP+12]
 0383 3D 00 00 00 00                        CMP EAX,0
 0388 7F 00                                 JG L1040
 038A F7 5D 0C                              NEG WORD [EBP+12]
 038D EB 00                                 JMP L1041
 038F                      L1040  EQU $
 038F FF 45 0C                              INC WORD [EBP+12]
 0392                      L1041  EQU $

        ! Pad out the digits with blank spaces if places more than actual number of 'digits'
        %if (places > length(reversed)) %start
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0392 8B 45 0C                              MOV EAX,[EBP+12]
 0395 31 C9                                 XOR ECX,ECX
 0397 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 039D 39 C8                                 CMP EAX,ECX
 039F 7E 00                                 JLE L1042
            %while length(reversed) < places %cycle
 03A1                      L1043  EQU $
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 03A1 31 C0                                 XOR EAX,EAX
 03A3 8A 85 FC FE FF FF                     MOV AL,[EBP-260]
 03A9 3B 45 0C                              CMP EAX,[EBP+12]
 03AC 7D 00                                 JGE L1044
                length(reversed) = length(reversed) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 03AE FE 85 FC FE FF FF                     INC BYTE [EBP-260]
                charno(reversed,length(reversed)) = ' '
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 03B4 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 03BA 31 C9                                 XOR ECX,ECX
 03BC 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 03C2 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 03C4 C6 00 20                              MOV BYTE [EAX],32
            %repeat
 03C7 EB 00                                 JMP L1043
 03C9                      L1044  EQU $
        %finish
 03C9                      L1042  EQU $

        ! Now reverse the digits for human readability.
        length(human) = 0
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 03C9 C6 85 FC FD FF FF 00                  MOV BYTE [EBP-516],0
        %for i = length(reversed), -1, 1 %cycle
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 03D0 31 C0                                 XOR EAX,EAX
 03D2 8A 85 FC FE FF FF                     MOV AL,[EBP-260]
 03D8 40                                    INC EAX
 03D9 89 85 EC FD FF FF                     MOV [EBP-532],EAX
 03DF                      L1045  EQU $
 03DF 8B 85 EC FD FF FF                     MOV EAX,[EBP-532]
 03E5 3D 01 00 00 00                        CMP EAX,1
 03EA 74 00                                 JE L1046
 03EC 48                                    DEC EAX
 03ED 89 85 EC FD FF FF                     MOV [EBP-532],EAX
            length(human) = length(human) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 03F3 FE 85 FC FD FF FF                     INC BYTE [EBP-516]
            charno(human,length(human)) = charno( reversed, i )
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 03F9 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 03FF 31 C9                                 XOR ECX,ECX
 0401 8A 8D FC FD FF FF                     MOV CL,[EBP-516]
 0407 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0409 8D 8D FC FE FF FF                     LEA ECX,[EBP-260]
 040F 03 8D EC FD FF FF                     ADD ECX,[EBP-532]
                                      CALL 'CHARNO' (MACRO 12)
 0415 8A 11                                 MOV DL,[ECX]
 0417 88 10                                 MOV [EAX],DL
        %repeat
 0419 EB 00                                 JMP L1045
 041B                      L1046  EQU $

        %result = human
 041B 8B 45 08                              MOV EAX,[EBP+8]
 041E 50                                    PUSH EAX
 041F 8D 8D FC FD FF FF                     LEA ECX,[EBP-516]
 0425 51                                    PUSH ECX
 0426 68 FF 00 00 00                        PUSH 255
 042B E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 042E 83 C4 0C                              ADD ESP,12
 0431 C9                                    LEAVE
 0432 C3                                    RET
    %end
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    ! format the number to the given number base
    ! and prefix by the number base expressed in base 10
    %external %string(255) %function formatNumber( %integer n,base,places)
 0433                      L1047  EQU $
 0433 C8 00 00 01                           ENTER 0000,1
        %string(255) s,x
        %integer i

        %if base = 10 %start
 0437 8B 45 10                              MOV EAX,[EBP+16]
 043A 3D 0A 00 00 00                        CMP EAX,10
 043F 75 00                                 JNE L1048
            x = int2ascii( n, base, places)
 0441 FF 75 14                              PUSH WORD [EBP+20]
 0444 FF 75 10                              PUSH WORD [EBP+16]
 0447 FF 75 0C                              PUSH WORD [EBP+12]
 044A 8D 85 F8 FC FF FF                     LEA EAX,[EBP-776]
 0450 50                                    PUSH EAX
 0451 E8 00 00                              CALL 'INT2ASCII' (INTERNAL L1030 )
 0454 83 C4 10                              ADD ESP,16
 0457 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 045D 50                                    PUSH EAX
 045E 8D 8D F8 FC FF FF                     LEA ECX,[EBP-776]
 0464 51                                    PUSH ECX
 0465 68 FF 00 00 00                        PUSH 255
 046A E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 046D 83 C4 0C                              ADD ESP,12
        %else
 0470 EB 00                                 JMP L1049
 0472                      L1048  EQU $
            s = int2ascii( n, base, 0)
 0472 FF 75 14                              PUSH WORD [EBP+20]
 0475 FF 75 10                              PUSH WORD [EBP+16]
 0478 6A 00                                 PUSH 0
 047A 8D 85 F8 FC FF FF                     LEA EAX,[EBP-776]
 0480 50                                    PUSH EAX
 0481 E8 00 00                              CALL 'INT2ASCII' (INTERNAL L1030 )
 0484 83 C4 10                              ADD ESP,16
 0487 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 048D 50                                    PUSH EAX
 048E 8D 8D F8 FC FF FF                     LEA ECX,[EBP-776]
 0494 51                                    PUSH ECX
 0495 68 FF 00 00 00                        PUSH 255
 049A E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 049D 83 C4 0C                              ADD ESP,12
            x = int2ascii( base, 10, places - length(s)  - 1 )
 04A0 FF 75 10                              PUSH WORD [EBP+16]
 04A3 6A 0A                                 PUSH 10
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 04A5 8B 45 0C                              MOV EAX,[EBP+12]
 04A8 31 C9                                 XOR ECX,ECX
 04AA 8A 8D FC FE FF FF                     MOV CL,[EBP-260]
 04B0 29 C8                                 SUB EAX,ECX
 04B2 48                                    DEC EAX
 04B3 50                                    PUSH EAX
 04B4 8D 85 F8 FC FF FF                     LEA EAX,[EBP-776]
 04BA 50                                    PUSH EAX
 04BB E8 00 00                              CALL 'INT2ASCII' (INTERNAL L1030 )
 04BE 83 C4 10                              ADD ESP,16
 04C1 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 04C7 50                                    PUSH EAX
 04C8 8D 8D F8 FC FF FF                     LEA ECX,[EBP-776]
 04CE 51                                    PUSH ECX
 04CF 68 FF 00 00 00                        PUSH 255
 04D4 E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 04D7 83 C4 0C                              ADD ESP,12

            length(x) = length(x) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 04DA FE 85 FC FD FF FF                     INC BYTE [EBP-516]
            charno(x,length(x)) = '_'
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 04E0 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 04E6 31 C9                                 XOR ECX,ECX
 04E8 8A 8D FC FD FF FF                     MOV CL,[EBP-516]
 04EE 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 04F0 C6 00 5F                              MOV BYTE [EAX],95
            %for i = 1,1,length(s) %cycle
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 04F3 31 C0                                 XOR EAX,EAX
 04F5 8A 85 FC FE FF FF                     MOV AL,[EBP-260]
 04FB 89 85 F4 FC FF FF                     MOV [EBP-780],EAX
 0501 C7 85 F8 FD FF FF 00 00 00 00         MOV LONG [EBP-520],0
 050B                      L1050  EQU $
 050B 8B 85 F8 FD FF FF                     MOV EAX,[EBP-520]
 0511 3B 85 F4 FC FF FF                     CMP EAX,[EBP-780]
 0517 74 00                                 JE L1051
 0519 40                                    INC EAX
 051A 89 85 F8 FD FF FF                     MOV [EBP-520],EAX
                length(x) = length(x) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0520 FE 85 FC FD FF FF                     INC BYTE [EBP-516]
                charno(x,length(x)) = charno(s,i)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0526 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 052C 31 C9                                 XOR ECX,ECX
 052E 8A 8D FC FD FF FF                     MOV CL,[EBP-516]
 0534 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0536 8D 8D FC FE FF FF                     LEA ECX,[EBP-260]
 053C 03 8D F8 FD FF FF                     ADD ECX,[EBP-520]
                                      CALL 'CHARNO' (MACRO 12)
 0542 8A 11                                 MOV DL,[ECX]
 0544 88 10                                 MOV [EAX],DL
            %repeat
 0546 EB 00                                 JMP L1050
 0548                      L1051  EQU $
        %finish
 0548                      L1049  EQU $

        %result = x
 0548 8B 45 08                              MOV EAX,[EBP+8]
 054B 50                                    PUSH EAX
 054C 8D 8D FC FD FF FF                     LEA ECX,[EBP-516]
 0552 51                                    PUSH ECX
 0553 68 FF 00 00 00                        PUSH 255
 0558 E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 055B 83 C4 0C                              ADD ESP,12
 055E C9                                    LEAVE
 055F C3                                    RET
    %end
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    %external %string(255) %function I to S(%integer n, places)
 0560                      L1052  EQU $
 0560 C8 00 00 01                           ENTER 0000,1
        %string(255) s
	
        s = int2ascii( n, 10, places )
 0564 FF 75 10                              PUSH WORD [EBP+16]
 0567 6A 0A                                 PUSH 10
 0569 FF 75 0C                              PUSH WORD [EBP+12]
 056C 8D 85 FC FD FF FF                     LEA EAX,[EBP-516]
 0572 50                                    PUSH EAX
 0573 E8 00 00                              CALL 'INT2ASCII' (INTERNAL L1030 )
 0576 83 C4 10                              ADD ESP,16
 0579 8D 85 FC FE FF FF                     LEA EAX,[EBP-260]
 057F 50                                    PUSH EAX
 0580 8D 8D FC FD FF FF                     LEA ECX,[EBP-516]
 0586 51                                    PUSH ECX
 0587 68 FF 00 00 00                        PUSH 255
 058C E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 058F 83 C4 0C                              ADD ESP,12

        %result = s
 0592 8B 45 08                              MOV EAX,[EBP+8]
 0595 50                                    PUSH EAX
 0596 8D 8D FC FE FF FF                     LEA ECX,[EBP-260]
 059C 51                                    PUSH ECX
 059D 68 FF 00 00 00                        PUSH 255
 05A2 E8 03 00                              CALL '_IMPSTRCPY' (EXTERN 3)
 05A5 83 C4 0C                              ADD ESP,12
 05A8 C9                                    LEAVE
 05A9 C3                                    RET
    %end
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    ! Write an integer on the current output stream, to
    ! occupy PLACES character spaces on the page.
    ! Nominally based on PrintString(I to S(n, places))
    ! This version doesn't use strings though, and is
    ! therefore smaller and quicker.  It builds the
    ! characters "backwards" in an array
    %external %routine Write(%integer n, places)
 05AA                      L1053  EQU $
 05AA C8 00 00 01                           ENTER 0000,1
        %string(32) ch;      ! Enough room for a 32 bit integer, plus sign
        %integer new, digit, sign, i

        length(ch) = 0
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 05AE C6 45 DB 00                           MOV BYTE [EBP-37],0
        ! First collect the digits
        %if n = 0 %start
 05B2 8B 45 0C                              MOV EAX,[EBP+12]
 05B5 3D 00 00 00 00                        CMP EAX,0
 05BA 75 00                                 JNE L1054
            length(ch) = length(ch) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 05BC FE 45 DB                              INC BYTE [EBP-37]
            charno(ch,length(ch)) = '0'
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 05BF 8D 45 DB                              LEA EAX,[EBP-37]
 05C2 31 C9                                 XOR ECX,ECX
 05C4 8A 4D DB                              MOV CL,[EBP-37]
 05C7 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 05C9 C6 00 30                              MOV BYTE [EAX],48
            sign = 0
 05CC C7 45 CC 00 00 00 00                  MOV LONG [EBP-52],0
        %else
 05D3 EB 00                                 JMP L1055
 05D5                      L1054  EQU $
            sign = 1
 05D5 C7 45 CC 01 00 00 00                  MOV LONG [EBP-52],1
            ! we make everything negative to avoid the -ve MaxInt wrap problem
            %if n > 0 %start
 05DC 8B 45 0C                              MOV EAX,[EBP+12]
 05DF 3D 00 00 00 00                        CMP EAX,0
 05E4 7E 00                                 JLE L1056
                sign = 0
 05E6 C7 45 CC 00 00 00 00                  MOV LONG [EBP-52],0
                n = -n
 05ED F7 5D 0C                              NEG WORD [EBP+12]
            %finish
 05F0                      L1056  EQU $

            %while n # 0 %cycle
 05F0                      L1057  EQU $
 05F0 8B 45 0C                              MOV EAX,[EBP+12]
 05F3 3D 00 00 00 00                        CMP EAX,0
 05F8 74 00                                 JE L1058
                new = n // 10
 05FA 8B 45 0C                              MOV EAX,[EBP+12]
 05FD 99                                    CWD
 05FE F7 3D 00 00 00 00                     IDIV WORD [COT+0000]
 0604 89 45 D4                              MOV [EBP-44],EAX
                digit = (new * 10) - n
 0607 8B 45 D4                              MOV EAX,[EBP-44]
 060A F7 2D 00 00 00 00                     IMUL WORD [COT+0000]
 0610 2B 45 0C                              SUB EAX,[EBP+12]
 0613 89 45 D0                              MOV [EBP-48],EAX
                length(ch) = length(ch) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0616 FE 45 DB                              INC BYTE [EBP-37]
                charno(ch,length(ch)) = digit+'0'
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0619 8D 45 DB                              LEA EAX,[EBP-37]
 061C 31 C9                                 XOR ECX,ECX
 061E 8A 4D DB                              MOV CL,[EBP-37]
 0621 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 0623 8B 4D D0                              MOV ECX,[EBP-48]
 0626 83 C1 30                              ADD ECX,48
 0629 88 08                                 MOV [EAX],CL
                n = new
 062B 8B 45 D4                              MOV EAX,[EBP-44]
 062E 89 45 0C                              MOV [EBP+12],EAX
            %repeat
 0631 EB 00                                 JMP L1057
 0633                      L1058  EQU $
        %finish
 0633                      L1055  EQU $

        ! Now deal with the sign, taking into account the slightly
        ! idiosyncratic behaviour on positive numbers
        %if sign # 0 %start
 0633 8B 45 CC                              MOV EAX,[EBP-52]
 0636 3D 00 00 00 00                        CMP EAX,0
 063B 74 00                                 JE L1059
            length(ch) = length(ch) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 063D FE 45 DB                              INC BYTE [EBP-37]
            charno(ch,length(ch)) = '-'
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 0640 8D 45 DB                              LEA EAX,[EBP-37]
 0643 31 C9                                 XOR ECX,ECX
 0645 8A 4D DB                              MOV CL,[EBP-37]
 0648 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 064A C6 00 2D                              MOV BYTE [EAX],45
        %else
 064D EB 00                                 JMP L1060
 064F                      L1059  EQU $
            %if places > 0 %start
 064F 8B 45 08                              MOV EAX,[EBP+8]
 0652 3D 00 00 00 00                        CMP EAX,0
 0657 7E 00                                 JLE L1061
                length(ch) = length(ch) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0659 FE 45 DB                              INC BYTE [EBP-37]
                charno(ch,length(ch)) = ' '
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 065C 8D 45 DB                              LEA EAX,[EBP-37]
 065F 31 C9                                 XOR ECX,ECX
 0661 8A 4D DB                              MOV CL,[EBP-37]
 0664 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 0666 C6 00 20                              MOV BYTE [EAX],32
            %finish
 0669                      L1061  EQU $
        %finish
 0669                      L1060  EQU $

        ! Now we adjust Places, also slightly mysteriously
        %if places <= 0 %then places = -places %else places = places + 1
 0669 8B 45 08                              MOV EAX,[EBP+8]
 066C 3D 00 00 00 00                        CMP EAX,0
 0671 7F 00                                 JG L1062
 0673 F7 5D 08                              NEG WORD [EBP+8]
 0676 EB 00                                 JMP L1063
 0678                      L1062  EQU $
 0678 FF 45 08                              INC WORD [EBP+8]
 067B                      L1063  EQU $

        ! The array at CH now contains the characters (backwards)
        ! and the character count is in NEXT

        %while places > length(ch) %cycle
 067B                      L1064  EQU $
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 067B 8B 45 08                              MOV EAX,[EBP+8]
 067E 31 C9                                 XOR ECX,ECX
 0680 8A 4D DB                              MOV CL,[EBP-37]
 0683 39 C8                                 CMP EAX,ECX
 0685 7E 00                                 JLE L1065
            length(ch) = length(ch) + 1
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 0687 FE 45 DB                              INC BYTE [EBP-37]
            charno(ch,length(ch)) = ' '
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
                                      Generating CODE for 'CHARNO' (MACRO 12)
 068A 8D 45 DB                              LEA EAX,[EBP-37]
 068D 31 C9                                 XOR ECX,ECX
 068F 8A 4D DB                              MOV CL,[EBP-37]
 0692 01 C8                                 ADD EAX,ECX
                                      CALL 'CHARNO' (MACRO 12)
 0694 C6 00 20                              MOV BYTE [EAX],32
            places = places - 1
 0697 FF 4D 08                              DEC WORD [EBP+8]
        %repeat
 069A EB 00                                 JMP L1064
 069C                      L1065  EQU $

        %for i=length(ch),-1,1 %cycle
                                      Generating CODE for 'LENGTH' (MACRO 11)
                                      CALL 'LENGTH' (MACRO 11)
 069C 31 C0                                 XOR EAX,EAX
 069E 8A 45 DB                              MOV AL,[EBP-37]
 06A1 40                                    INC EAX
 06A2 89 45 C8                              MOV [EBP-56],EAX
 06A5                      L1066  EQU $
 06A5 8B 45 C8                              MOV EAX,[EBP-56]
 06A8 3D 01 00 00 00                        CMP EAX,1
 06AD 74 00                                 JE L1067
 06AF 48                                    DEC EAX
 06B0 89 45 C8                              MOV [EBP-56],EAX
            print symbol( charno(ch,i))
                                      Generating CODE for 'CHARNO' (MACRO 12)
 06B3 8D 45 DB                              LEA EAX,[EBP-37]
 06B6 03 45 C8                              ADD EAX,[EBP-56]
                                      CALL 'CHARNO' (MACRO 12)
 06B9 8A 00                                 MOV AL,[EAX]
 06BB 25 FF 00 00 00                        AND EAX,255
 06C0 50                                    PUSH EAX
 06C1 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 06C4 83 C4 04                              ADD ESP,4
        %repeat
 06C7 EB 00                                 JMP L1066
 06C9                      L1067  EQU $

    %end
 06C9 C9                                    LEAVE
 06CA C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    ! Print a floating point number out, along the lines of
    ! +/-nnn.nnn@+/-nn, to occupy Places character spaces.
    ! Note - there's a bug in this code such that it does not
    ! round the number properly.  EG 3.999999999 to 4 places
    ! should be 4.00 but we print 3.99

    %external %routine print(%longreal x, %integer places)
 06CB                      L1068  EQU $
 06CB C8 00 00 01                           ENTER 0000,1
        %integer exponent, digit, point, printexpo

        %if x = 0 %start
 06CF DD 45 0C                              FLD QWORD [EBP+12]
 06D2 D9 EE                                 FLDZ
 06D4 DE D9                                 FCOMPP ST(1),ST
 06D6 DF E0                                 FSTSW AX
 06D8 9E                                    SAHF
 06D9 75 00                                 JNE L1069
            printsymbol('0')
 06DB 6A 30                                 PUSH 48
 06DD E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 06E0 83 C4 04                              ADD ESP,4
            printsymbol('.')
 06E3 6A 2E                                 PUSH 46
 06E5 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 06E8 83 C4 04                              ADD ESP,4
            printsymbol('0')
 06EB 6A 30                                 PUSH 48
 06ED E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 06F0 83 C4 04                              ADD ESP,4
            %while places > 3 %cycle
 06F3                      L1070  EQU $
 06F3 8B 45 08                              MOV EAX,[EBP+8]
 06F6 3D 03 00 00 00                        CMP EAX,3
 06FB 7E 00                                 JLE L1071
                printsymbol('0')
 06FD 6A 30                                 PUSH 48
 06FF E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0702 83 C4 04                              ADD ESP,4
                places = places - 1
 0705 FF 4D 08                              DEC WORD [EBP+8]
            %repeat
 0708 EB 00                                 JMP L1070
 070A                      L1071  EQU $
            %return
 070A C9                                    LEAVE
 070B C3                                    RET
        %finish
 070C                      L1069  EQU $

        %if x < 0 %then printsymbol('-') %and x = -x %and places = places - 1
 070C DD 45 0C                              FLD QWORD [EBP+12]
 070F D9 EE                                 FLDZ
 0711 DE D9                                 FCOMPP ST(1),ST
 0713 DF E0                                 FSTSW AX
 0715 9E                                    SAHF
 0716 76 00                                 JBE L1072
 0718 6A 2D                                 PUSH 45
 071A E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 071D 83 C4 04                              ADD ESP,4
 0720 DD 45 0C                              FLD QWORD [EBP+12]
 0723 D9 E0                                 FCHS ST(0),ST
 0725 DD 5D 0C                              FSTP QWORD [EBP+12]
 0728 FF 4D 08                              DEC WORD [EBP+8]
 072B                      L1072  EQU $

        %if places < 3 %then places = 3
 072B 8B 45 08                              MOV EAX,[EBP+8]
 072E 3D 03 00 00 00                        CMP EAX,3
 0733 7D 00                                 JGE L1073
 0735 C7 45 08 03 00 00 00                  MOV LONG [EBP+8],3
 073C                      L1073  EQU $
   
        exponent = 0
 073C C7 45 F8 00 00 00 00                  MOV LONG [EBP-8],0
        printexpo = 0
 0743 C7 45 EC 00 00 00 00                  MOV LONG [EBP-20],0

        %while x < 1 %cycle
 074A                      L1074  EQU $
 074A DD 45 0C                              FLD QWORD [EBP+12]
 074D DB 05 04 00 00 00                     FILD [COT+0004]
 0753 DE D9                                 FCOMPP ST(1),ST
 0755 DF E0                                 FSTSW AX
 0757 9E                                    SAHF
 0758 76 00                                 JBE L1075
            x = x * 10
 075A DD 45 0C                              FLD QWORD [EBP+12]
 075D DB 05 00 00 00 00                     FILD [COT+0000]
 0763 DE C9                                 FMULP ST(1),ST
 0765 DD 5D 0C                              FSTP QWORD [EBP+12]
            exponent = exponent - 1
 0768 FF 4D F8                              DEC WORD [EBP-8]
        %repeat
 076B EB 00                                 JMP L1074
 076D                      L1075  EQU $

        %while x >= 10 %cycle
 076D                      L1076  EQU $
 076D DD 45 0C                              FLD QWORD [EBP+12]
 0770 DB 05 00 00 00 00                     FILD [COT+0000]
 0776 DE D9                                 FCOMPP ST(1),ST
 0778 DF E0                                 FSTSW AX
 077A 9E                                    SAHF
 077B 77 00                                 JA L1077
            x = x / 10
 077D DD 45 0C                              FLD QWORD [EBP+12]
 0780 DB 05 00 00 00 00                     FILD [COT+0000]
 0786 DE F9                                 FDIVP ST(1),ST
 0788 DD 5D 0C                              FSTP QWORD [EBP+12]
            exponent = exponent + 1
 078B FF 45 F8                              INC WORD [EBP-8]
        %repeat
 078E EB 00                                 JMP L1076
 0790                      L1077  EQU $

        ! Now X is between 1.0 and 9.99 and exponent is set accordingly
        ! If the exponent is "large" we will use scientific notation
        point = places - 2;     ! for useful digits after the "0."
 0790 8B 45 08                              MOV EAX,[EBP+8]
 0793 2D 02 00 00 00                        SUB EAX,2
 0798 89 45 F0                              MOV [EBP-16],EAX
        %if exponent >= places %or exponent < -point %start
 079B 8B 45 F8                              MOV EAX,[EBP-8]
 079E 3B 45 08                              CMP EAX,[EBP+8]
 07A1 7D 00                                 JGE L1078
 07A3 8B 45 F0                              MOV EAX,[EBP-16]
 07A6 F7 D8                                 NEG EAX
 07A8 8B 4D F8                              MOV ECX,[EBP-8]
 07AB 39 C1                                 CMP ECX,EAX
 07AD 7D 00                                 JGE L1079
 07AF                      L1078  EQU $
            printexpo = exponent
 07AF 8B 45 F8                              MOV EAX,[EBP-8]
 07B2 89 45 EC                              MOV [EBP-20],EAX
            exponent = 0
 07B5 C7 45 F8 00 00 00 00                  MOV LONG [EBP-8],0
            places = places - 2
 07BC 83 6D 08 02                           SUB LONG [EBP+8],2
        %finish
 07C0                      L1079  EQU $

        ! Now the exponent is small-ish
        %if exponent < 0 %start;      ! 0.nnnn
 07C0 8B 45 F8                              MOV EAX,[EBP-8]
 07C3 3D 00 00 00 00                        CMP EAX,0
 07C8 7D 00                                 JGE L1080
            printsymbol('0')
 07CA 6A 30                                 PUSH 48
 07CC E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 07CF 83 C4 04                              ADD ESP,4
            printsymbol('.')
 07D2 6A 2E                                 PUSH 46
 07D4 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 07D7 83 C4 04                              ADD ESP,4
            places = places - 2
 07DA 83 6D 08 02                           SUB LONG [EBP+8],2

            %while exponent < -1 %cycle
 07DE                      L1081  EQU $
 07DE 8B 45 F8                              MOV EAX,[EBP-8]
 07E1 3D FF FF FF FF                        CMP EAX,-1
 07E6 7D 00                                 JGE L1082
                printsymbol('0')
 07E8 6A 30                                 PUSH 48
 07EA E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 07ED 83 C4 04                              ADD ESP,4
                exponent = exponent + 1
 07F0 FF 45 F8                              INC WORD [EBP-8]
                places = places - 1
 07F3 FF 4D 08                              DEC WORD [EBP+8]
            %repeat
 07F6 EB 00                                 JMP L1081
 07F8                      L1082  EQU $

            point = -1; ! because we've already passed that
 07F8 C7 45 F0 FF FF FF FF                  MOV LONG [EBP-16],-1
        %else;          ! nnn.nnn
 07FF EB 00                                 JMP L1083
 0801                      L1080  EQU $
            point = exponent
 0801 8B 45 F8                              MOV EAX,[EBP-8]
 0804 89 45 F0                              MOV [EBP-16],EAX
        %finish
 0807                      L1083  EQU $

        %while places > 0 %cycle
 0807                      L1084  EQU $
 0807 8B 45 08                              MOV EAX,[EBP+8]
 080A 3D 00 00 00 00                        CMP EAX,0
 080F 7E 00                                 JLE L1085
            digit = int pt(x)
 0811 DD 45 0C                              FLD QWORD [EBP+12]
 0814 83 EC 08                              SUB ESP,8
 0817 89 E7                                 MOV EDI,ESP
 0819 DD 1F                                 FSTP QWORD [EDI]
 081B E8 3F 00                              CALL 'INTPT' (EXTERN 63)
 081E 83 C4 08                              ADD ESP,8
 0821 89 45 F4                              MOV [EBP-12],EAX
            ! Rounding as we go through this loop can "oversize" the digit.  This
            ! of course tells us that we should have printed (eg) 40000 but we
            ! are now stuck with printing 39999
            %if digit > 9 %then digit = 9
 0824 8B 45 F4                              MOV EAX,[EBP-12]
 0827 3D 09 00 00 00                        CMP EAX,9
 082C 7E 00                                 JLE L1086
 082E C7 45 F4 09 00 00 00                  MOV LONG [EBP-12],9
 0835                      L1086  EQU $
            printsymbol(digit + '0')
 0835 8B 45 F4                              MOV EAX,[EBP-12]
 0838 05 30 00 00 00                        ADD EAX,48
 083D 50                                    PUSH EAX
 083E E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0841 83 C4 04                              ADD ESP,4
            x = (x - digit)*10
 0844 DD 45 0C                              FLD QWORD [EBP+12]
 0847 DB 45 F4                              FILD [EBP-12]
 084A DE E9                                 FSUBP ST(1),ST
 084C DB 05 00 00 00 00                     FILD [COT+0000]
 0852 DE C9                                 FMULP ST(1),ST
 0854 DD 5D 0C                              FSTP QWORD [EBP+12]
            %if point = 0 %then printsymbol('.') %and places = places - 1
 0857 8B 45 F0                              MOV EAX,[EBP-16]
 085A 3D 00 00 00 00                        CMP EAX,0
 085F 75 00                                 JNE L1087
 0861 6A 2E                                 PUSH 46
 0863 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0866 83 C4 04                              ADD ESP,4
 0869 FF 4D 08                              DEC WORD [EBP+8]
 086C                      L1087  EQU $
            point = point - 1
 086C FF 4D F0                              DEC WORD [EBP-16]
            places = places - 1
 086F FF 4D 08                              DEC WORD [EBP+8]
        %repeat
 0872 EB 00                                 JMP L1084
 0874                      L1085  EQU $

        %if printexpo # 0 %start
 0874 8B 45 EC                              MOV EAX,[EBP-20]
 0877 3D 00 00 00 00                        CMP EAX,0
 087C 74 00                                 JE L1088
            printsymbol('@')
 087E 6A 40                                 PUSH 64
 0880 E8 2E 00                              CALL 'PRINTSYMBOL' (EXTERN 46)
 0883 83 C4 04                              ADD ESP,4
            write(printexpo, 1)
 0886 FF 75 EC                              PUSH WORD [EBP-20]
 0889 6A 01                                 PUSH 1
 088B E8 00 00                              CALL 'WRITE' (INTERNAL L1053 )
 088E 83 C4 08                              ADD ESP,8
        %finish
 0891                      L1088  EQU $
    %end
 0891 C9                                    LEAVE
 0892 C3                                    RET
{----------------------------------------------------------------------------}
{----------------------------------------------------------------------------}
    ! INTPT - return the integer part of a real.  Note that this is
    ! NOT the same as the built-in primitive "INT" which returns the
    ! nearest integer to the real according to IEEE rounding rules.
    ! Thus, INTPT(1.9) = 1, whereas INT(1.9) = 2.  INTPT uses INT
    ! and then adjusts the rounding to truncate.
    %external %integer %function Int Pt(%longreal x)
 0893                      L1089  EQU $
 0893 C8 00 00 01                           ENTER 0000,1
        %integer i

        i = int(x)
                                      Generating CODE for 'INT' (MACRO 13)
 0897 DD 45 08                              FLD QWORD [EBP+8]
 089A DB 5D F4                              FISTP [EBP-12]
                                      CALL 'INT' (MACRO 13)
 089D 8B 45 F4                              MOV EAX,[EBP-12]
 08A0 89 45 F8                              MOV [EBP-8],EAX
        %if i # 0 %then %start; ! zero is the easy answer
 08A3 8B 45 F8                              MOV EAX,[EBP-8]
 08A6 3D 00 00 00 00                        CMP EAX,0
 08AB 74 00                                 JE L1090
            x = x - i
 08AD DD 45 08                              FLD QWORD [EBP+8]
 08B0 DB 45 F8                              FILD [EBP-8]
 08B3 DE E9                                 FSUBP ST(1),ST
 08B5 DD 5D 08                              FSTP QWORD [EBP+8]
            %if i > 0 %start; ! correct towards zero - depends which way that is :-)
 08B8 8B 45 F8                              MOV EAX,[EBP-8]
 08BB 3D 00 00 00 00                        CMP EAX,0
 08C0 7E 00                                 JLE L1091
                %if x < 0 %then i = i - 1
 08C2 DD 45 08                              FLD QWORD [EBP+8]
 08C5 D9 EE                                 FLDZ
 08C7 DE D9                                 FCOMPP ST(1),ST
 08C9 DF E0                                 FSTSW AX
 08CB 9E                                    SAHF
 08CC 76 00                                 JBE L1092
 08CE FF 4D F8                              DEC WORD [EBP-8]
 08D1                      L1092  EQU $
            %else
 08D1 EB 00                                 JMP L1093
 08D3                      L1091  EQU $
                %if x > 0 %then i = i + 1
 08D3 DD 45 08                              FLD QWORD [EBP+8]
 08D6 D9 EE                                 FLDZ
 08D8 DE D9                                 FCOMPP ST(1),ST
 08DA DF E0                                 FSTSW AX
 08DC 9E                                    SAHF
 08DD 73 00                                 JAE L1094
 08DF FF 45 F8                              INC WORD [EBP-8]
 08E2                      L1094  EQU $
            %finish
 08E2                      L1093  EQU $
        %finish
 08E2                      L1090  EQU $
        %result = i
 08E2 8B 45 F8                              MOV EAX,[EBP-8]
 08E5 C9                                    LEAVE
 08E6 C3                                    RET
    %end
{----------------------------------------------------------------------------}

%endoffile
      _TEXT  ENDS
      CONST  SEGMENT WORD PUBLIC 'CONST'
 0000 0A 00                                 db 0A,00 ; ..
 0002 00 00                                 db 00,00 ; ..
 0004 01 00                                 db 01,00 ; ..
 0006 00 00                                 db 00,00 ; ..
      CONST  ENDS
      _TEXT  SEGMENT WORD PUBLIC 'CODE'
            ENDS
      DATA  SEGMENT WORD PUBLIC 'DATA'
 0000 24 30                                 db 24,30 ; $0
 0002 31 32                                 db 31,32 ; 12
 0004 33 34                                 db 33,34 ; 34
 0006 35 36                                 db 35,36 ; 56
 0008 37 38                                 db 37,38 ; 78
 000A 39 41                                 db 39,41 ; 9A
 000C 42 43                                 db 42,43 ; BC
 000E 44 45                                 db 44,45 ; DE
 0010 46 47                                 db 46,47 ; FG
 0012 48 49                                 db 48,49 ; HI
 0014 4A 4B                                 db 4A,4B ; JK
 0016 4C 4D                                 db 4C,4D ; LM
 0018 4E 4F                                 db 4E,4F ; NO
 001A 50 51                                 db 50,51 ; PQ
 001C 52 53                                 db 52,53 ; RS
 001E 54 55                                 db 54,55 ; TU
 0020 56 57                                 db 56,57 ; VW
 0022 58 59                                 db 58,59 ; XY
 0024 5A 00                                 db 5A,00 ; Z.
      DATA    ENDS
              ENDS
      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'
      _SWTAB   ENDS
