         Edinburgh IMP77 Compiler - Version 8.4

   1  ! IMP77 compiler  first pass
   2  
   3  !###########################################################
   4  ! This program is a Copyright work.                        #
   5  !                                                          #
   6  ! Over the last 40+ years a long and distinguished list of #
   7  ! institutions, individuals and other entities have made   #
   8  ! contributions to portions of this program and may have a #
   9  ! reasonable claim over rights to certain parts of the     #
   10  ! program.                                                 #
   11  !                                                          #
   12  ! This version is therefore provided for education and     #
   13  ! demonstration purposes only                              #
   14  !###########################################################
   15  
   16  %begin
   17      %conststring(4) version = "8.4"
   18  
   19      !configuration parameters
   20      { minus one represents all bits set for an %integer     }
   21      { %integer could be 16,32,64 bits wide depending on the }
   22      { processor being targeted                              }
   23      { i.e 8086 (16 bits), 80386 (32 bits), i86_64 (64 bits) }
   24      %constinteger minus one    = -1;
   25  ! Wee change needed to cross-compile the compiler when going from 16 bit to 32 bit world
   26  !    %constinteger minus one    = 16_7fff;
   27  
   28      { now to set up various constants }
   29      %constinteger max int      = ((minus one)>>1)//10
   30      %constinteger max dig      = (minus one)>>1-maxint*10
   31      %constinteger byte size    = 8;            !bits per byte
   32      %constinteger max tag      = 800;          !max no. of tags
   33      %constinteger max dict     = 6000;         !max extent of dictionary
   34      %constinteger name bits    = 11;           !size of name table as a power of two
   35      %constinteger max names    = 1<<namebits-1;!table limit (a mask, eg 255)
   36      %owninteger   spare names  = max names
   37      %constinteger lit max      = 50;           !max no. of constants/stat.
   38      %constinteger rec size     = 520;          !size of analysis record
   39      %constinteger dim limit    = 6;            !maximum array dimension
   40  
   41      !symbols
   42      %constinteger ff     = 12;              !form feed
   43      %constinteger marker = '^';             !marker for faults
   44      %constinteger squote = '"';             !string quote
   45      %constinteger cquote = '''';            !character quote
   46  
   47      !streams
   48      %constinteger report = 0,  source = 1
   49      %constinteger object = 1, listing = 2
   50  
   51      !types
   52      %constinteger integer = 1
   53      %constinteger real    = 2
   54      %constinteger stringv = 3
   55      %constinteger record  = 4
   56  
   57      !forms
   58      %constinteger iform = integer<<4+1
   59      %constinteger var = 91
   60      %constinteger const   = 93
   61      %constinteger swit    = 105
   62      %constinteger comment = 22
   63      %constinteger termin  = 20
   64      %constinteger lab     = 3
   65      %constinteger jump    = 54
   66      %constinteger recfm = 4
   67      %constinteger proc  = 7;                     !class for proc
   68  
   69      !phrase entries
   70      %constinteger escdec   = 252
   71      %constinteger escproc  = 253
   72      %constinteger escarray = 254
   73      %constinteger escrec   = 255
   74  
   75      !%recordformat arfm(%shortinteger class,sub,link,ptype,papp,pformat,x,pos);!imp77:
   76      %recordformat arfm(%integer class,sub,link,ptype,papp,pformat,x,pos)
   77  
   78      %recordformat tagfm(%integer app, format, %integer flags, index, text, link)
   79  
   80      !flags
   81      !      *===.===.===.===.===.====.====.====.===.======.======*
   82      !      ! u ! c ! c ! p ! s ! a  ! o  ! pr ! s ! type ! form !
   83      !      ! 1 ! 1 ! 1 ! 1 ! 1 ! 1  ! 1  ! 1  ! 1 !  3   !  4   !
   84      !      *===^===^===^===^===^====^====^====^===^======^======*
   85      !        u   c   c   p   s   a    o    p    s    t      f
   86      !        s   l   o   a   u   n    w    r    p    y      o
   87      !        e   o   n   r   b   a    n    o    e    p      r
   88      !        d   s   s   a   n   m         t    c    e      m
   89      !            e   t   m   a   e     
   90      !            d       s   m
   91      !                        e
   92      !
   93      !                             
   94  
   95      %constinteger used bit   = 2_1000000000000000
   96      %constinteger closed     = 2_0100000000000000
   97      %constinteger const bit  = 2_0010000000000000
   98      %constinteger parameters = 2_0001000000000000
   99      %constinteger subname    = 2_0000100000000000
  100      %constinteger aname      = 2_0000010000000000
  101      %constinteger own bit    = 2_0000001000000000
  102      %constinteger prot       = 2_0000000100000000
  103      %constinteger spec       = 2_0000000010000000
  104  
  105      %constinteger trans bit  = 16_4000
  106      %constinteger error      = 16_8000
  107  
  108      %record(arfm)%array ar(1:rec size)
  109  
  110      %owninteger class        = 0;             !class of atom wanted
  111      %owninteger x            = 0;             !usually last tag
  112      %owninteger atom1        = 0;             !atom class (major)
  113      %owninteger atom2        = 0;             !atom class (minor)
  114      %owninteger subatom      = 0;             !extra info about atom
  115      %owninteger type         = 0
  116      %owninteger app          = 0
  117      %owninteger format       = 0;             !atom info
  118      %integer hash value
  119      %owninteger faulty       = 0;             !fault indicator
  120      %owninteger fault rate   = 0;             !fault rate count
  121      %owninteger lines        = 0;             !current line number
  122      %owninteger text line    = 0;             !starting line for string const
  123      %owninteger margin       = 0;             !statement start margin
  124      %owninteger error margin = 0
  125      %owninteger error sym    = 0
  126      %owninteger column       = 0
  127      %owninteger stats        = 0;             !statements compiled
  128      %owninteger mon pos      = 0;             !flag for diagnose
  129      %owninteger sym          = nl;            !current input symbol
  130      %owninteger symtype      = 0;             !type of current symbol
  131      %owninteger quote        = 0;             !>0 strings, <0 chars
  132      %owninteger end mark     = 0;             !%end flag
  133      %owninteger cont         = ' '
  134      %owninteger csym         = ' ';           !listing continuation marker
  135      %owninteger decl         = 0;             !current declarator flags
  136      %owninteger dim          = 0;             !arrayname dimension
  137      %owninteger spec given   = 0
  138  
  139      %owninteger escape class = 0;             !when and where to escape
  140      %owninteger protection   = 0
  141      %owninteger atom flags   = 0
  142      %owninteger otype        = 0;             !current 'own' type
  143      %owninteger reals ln     = 1;             ! =4 for %REALSLONG
  144      %owninteger last1        = 0;             !previous atom class
  145      %owninteger gen type     = 0
  146      %owninteger ptype        = 0;             !current phrase type
  147      %owninteger papp         = 0;             !current phrase parameters
  148      %owninteger pformat      = 0;             !current phrase format
  149      %owninteger force        = 0;             !force next ptype
  150      %owninteger g            = 0
  151      %owninteger gg           = 0
  152      %owninteger map gg       = 0;             !grammar entries
  153      %owninteger fdef         = 0;             !current format definition
  154      %owninteger this         = -1;            !current recordformat tag
  155      %owninteger nmin         = 0;             !analysis record atom pointer
  156      %owninteger nmax         = 0;             !analysis record phrase pointer
  157      %owninteger rbase        = 0;             !record format definition base
  158      %owninteger dmax         = 1
  159      %owninteger tmin         = max tag;       !upper bound on tags
  160      %owninteger ss           = 0;             !source statement entry
  161      %string(63) include file
  162      %owninteger include list = 0
  163      %owninteger include level= 0
  164      %owninteger include      = 0;             !=0 unused, #0 being used
  165      %owninteger perm         = 1;             !1 = compiling perm, 0 = program
  166      %owninteger progmode     = 0;             !-1 = file, 1 = begin/eop
  167      %owninteger sstype       = 0;             !-1:exec stat
  168                                                ! 0: declaration
  169                                                ! 1: block in
  170                                                ! 2: block out
  171      %owninteger spec mode    = 0;             !>=0: definition
  172                                                ! -1: proc spec
  173                                                ! -2: recordformat
  174      %owninteger ocount       = -1;            !own constants wanted
  175      %owninteger limit        = 0;             !lookup limit
  176      %owninteger copy         = 0;             !duplicate name flag
  177      %owninteger order        = 0;             !out of sequence flag
  178      %owninteger for warn     = 0;             !non-local flag
  179      %owninteger dubious      = 0;             !flag for dubious statements
  180      %owninteger dp           = 1
  181      %owninteger pos1         = 0
  182      %owninteger pos2         = 0;             !error position
  183      %owninteger pos          = 0;             !input line index
  184      %owninteger dimension    = 0;             !current array dimension
  185      %owninteger local        = 0;             !search limit for locals
  186      %owninteger fm base      = 0;             !entry for format decls
  187      %owninteger search base  = 0;             !entry for record_names
  188      %owninteger format list  = 0;             !size of current format list
  189      %integer recid
  190      %ownbyteintegerarray char(0:133) = ;  !input line
  191+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  192+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  193+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  194+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  195+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  196+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  197+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  198+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  199+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  200+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  201+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  202+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  203+     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  204+     10, 10, 10, 10
  205      %integerarray lit pool(0:lit max)
  206      %owninteger lit          = 0;             !current literal (integer)
  207      %owninteger lp           = 0;             !literals pointer
  208      %owninteger block x      = 0;             !block tag
  209      %owninteger list         = 1;             !<= to enable
  210      %owninteger control      = 0
  211      %owninteger diag         = 0;             !diagnose flags
  212      %integerarray hash(0:max names)
  213      %record(tagfm)%array tag(0:max tag)
  214      %integerarray dict(1:max dict)
  215      %byteintegerarray buff(1:512)
  216      %owninteger bp           = 0
  217  
  218      { grammar related constants }
  219      %constinteger max grammar  = 1720
  220      %owninteger gmin       = max grammar               ;! upper bound on grammar
  221      %constinteger manifest = 120, figurative = 130
  222      %constinteger actions  = 180, phrasal    = 200
  223  
  224      %constbyteintegerarray amap(0:15) = %c
  225+        89,   91,   92,  104,   94,   93,  105,  100,  101,  102,  103,  106,  107,  108,  109,   89
  226      !   ?     v     n     l    fm const  swit    rp    fp    mp    pp     a    an    na    nan    ?
  227  
  228      %constbyteintegerarray atoms(0:15) = 89, 1, 1, 10,  9,  1, 10,  7,
  229+                                           7, 7, 7,  4,  1,  4,  1, 89
  230  
  231      !*** start of generated tables ***
  232      %include "i77.tables.imp"
 &  1     %endoflist
 & 340  %endoffile
  233      !***  end  of generated tables ***
  234  
  235      %routine flush buffer( %integer limit )
  236          %integer j
  237          %if bp >= limit %start
  238          %if faulty = 0 %start
  239              selectoutput(object)
  240              %for j = 1, 1, bp %cycle
  241                  printsymbol(buff(j))
  242              %repeat
  243              selectoutput(listing)
  244          %finish
  245          bp = 0
  246          %finish
  247      %end
  248  
  249      %routine add char( %byteinteger ch )
  250          bp = bp + 1
  251          buff(bp) = ch
  252      %end
  253  
  254      %routine op(%integer code, param)
  255          buff(bp+1) = code
  256          buff(bp+2) = param>>8
  257          buff(bp+3) = param
  258          bp = bp+3
  259      %end
  260  
  261      %routine set const(%integer m)
  262          buff(bp+1) = 'N'
  263          buff(bp+5) = m;  m = m>>8
  264          buff(bp+4) = m;  m = m>>8
  265          buff(bp+3) = m;  m = m>>8
  266          buff(bp+2) = m
  267          bp = bp+5
  268      %end
  269  
  270      %routine octal(%integer n)
  271          %integer m
  272          m = n>>3
  273          octal(m) %if m # 0
  274          add char( n&7+'0' )
  275      %end
  276  
  277      %routine hexadecimal(%integer n)
  278          %integer m
  279          m = n>>4
  280          hexadecimal(m) %if m # 0
  281          %if n&15 > 9 %then add char( n&15+'A' ) %else add char( n&15+'0' )
  282      %end
  283  
  284      %routine print ident(%integer p, mode)
  285  
  286          %routine putit(%integer ch)
  287              %if mode = 0 %then %start
  288                  printsymbol(ch)
  289              %else
  290                  add char( ch )
  291              %finish
  292          %end
  293  
  294          %integer k, l
  295          p = tag(p)_text
  296          %if p = 0 %start
  297              putit('?')
  298              %return
  299          %finish
  300          p = p+1;       ! advance to name string
  301          k = dict(p)
  302          l = k & 255;   ! length
  303          %while l > 0 %cycle
  304              putit(k>>8)
  305              l = l-1
  306              p = p+1
  307              k = dict(p)
  308              %exit %if l = 0
  309              putit(k&255)
  310              l = l-1
  311          %repeat
  312      %end
  313  
  314      %routine abandon(%integer n)
  315          %switch reason(0:9)
  316          %integer stream
  317          stream = listing
  318          %cycle
  319              newline %if sym # nl
  320              printsymbol('*');  write(lines,4);  space
  321              ->reason(n)
  322  reason(0):  printstring("compiler error!");          ->more
  323  reason(1):  printstring("switch vector too large");  ->more
  324  reason(2):  printstring("too many names");           ->more
  325  reason(3):  printstring("program too complex");      ->more
  326  reason(4):  printstring("feature not implemented");  ->more
  327  reason(5):  printstring("input ended: ")
  328              %if quote # 0 %start
  329                  %if quote < 0 %then printsymbol(cquote) %else printsymbol(squote)
  330              %else
  331                  printstring("%endof")
  332                  %if progmode >= 0 %then printstring("program") %else printstring("file")
  333              %finish
  334              printstring(" missing?");                ->more
  335  reason(6):  printstring("too many faults!");         ->more
  336  reason(7):  printstring("string constant too long"); ->more
  337  reason(8):  printstring("dictionary full");          ->more
  338  reason(9):  printstring("Included file ".include file." does not exist")
  339  
  340  more:       newline
  341              printstring("***  compilation abandoned ***");  newline
  342              %exit %if stream = report
  343              close output
  344              stream = report
  345              select output(report)
  346          %repeat
  347          !%signal 15,15 %if diag&4096 # 0
  348          %stop
  349      %end
  350  
  351      %routine compile block(%integer level, block tag, dmin, tmax, id)
  352  
  353          %integerfnspec gapp
  354          %routinespec delete names(%integer quiet)
  355          %routinespec analyse
  356          %routinespec compile
  357  
  358          %integer open;    open       = closed;      !zero if can return from proc
  359          %integer dbase;   dbase      = dmax;        !dictionary base
  360          %integer tbase;   tbase      = tmax;        !tag base
  361          %integer tstart;  tstart     = tmax
  362          %integer label;   label      = 4;           !first internal label
  363          %integer access;  access     = 1;           !non-zero if accessible
  364          %integer inhibit; inhibit    = 0;           !non-zero inhibits declaratons
  365  
  366          %integername bflags;      bflags      == tag(block tag)_flags
  367          %integer block type;      block type   = bflags>>4&7
  368          %integer block form;      block form   = bflags&15
  369          %integer block fm;        block fm     = tag(block tag)_format
  370          %integer block otype;     block otype  = otype
  371          %integername block app;   block app   == tag(block tag)_app
  372  
  373          %integer l, new app
  374  
  375          %routine fault(%integer n)
  376              ! -5 : -1  - warnings
  377              !  1 : 22  - errors
  378  
  379              %switch fm(-5:22)
  380              %integer st
  381  
  382              %routine print ss
  383                  %integer s, p
  384                  %return %if pos = 0
  385                  space
  386                  p = 1
  387                  %cycle
  388                      printsymbol(marker) %if p = pos1
  389                      %exit %if p = pos
  390                      s = char(p);  p = p+1
  391                      %exit %if s = nl %or (s='%' %and p = pos)
  392                      %if s < ' ' %start;         !beware of tabs
  393                          %if s = ff %then s = nl %else s = ' '
  394                      %finish
  395                      printsymbol(s)
  396                  %repeat
  397                  pos = 0 %if list <= 0
  398              %end
  399  
  400              pos1 = pos2 %if pos2 > pos1
  401              newline %if sym # nl
  402              st = report
  403              st = listing %if n = -3;              !don't report unused on the console
  404              %cycle
  405                  select output(st)
  406                  %if n < 0 %then printsymbol('?') %and pos1 = 0 %else printsymbol('*')
  407                  %if st # report %start
  408                      %if list <= 0 %and pos1 # 0 %start
  409                          spaces(pos1+margin);  printstring("      ! ")
  410                      %finish
  411                  %finish %else %start
  412                      printstring(include file) %if include # 0
  413                      write(lines, 4);  printsymbol(csym);  space
  414                  %finish
  415                  ->fm(n) %if -5 <= n %and n <= 22
  416                  printstring("fault");  write(n, 2);              ->ps
  417  
  418  fm(-5):         printstring("Dubious statement");  dubious = 0;        ->psd
  419  fm(-4):         printstring("Non-local")
  420                  pos1 = for warn;  for warn = 0;                        ->ps
  421  fm(-3):         print ident(x, 0);  printstring(" unused");            ->nps
  422  fm(-2):         printstring("""}""");                                  ->miss
  423  fm(-1):         printstring("access");                                 ->psd
  424  fm(0):          printstring("form");                                   ->ps
  425  fm(1):          printstring("atom");                                   ->ps
  426  fm(2):          printstring("not declared");                           ->ps
  427  fm(3):          printstring("too complex");                            ->ps
  428  fm(4):          printstring("duplicate ");  Print Ident(x, 0);         ->ps
  429  fm(5):          printstring("type");                                   ->ps
  430  fm(6):          printstring("match");                                  ->psd
  431  fm(7):          printstring("context");                                ->psd
  432  fm(8):          printstring("%cycle");                                 ->miss
  433  fm(9):          printstring("%start");                                 ->miss
  434  fm(10):         printstring("size");  write(lit, 1) %if pos1 = 0;      ->ps
  435  fm(11):         printstring("bounds")
  436                  write(ocount, 1) %unless ocount < 0;                   ->ps
  437  fm(12):         printstring("index");                                  ->ps
  438  fm(13):         printstring("order");                                  ->psd
  439  fm(14):         printstring("not a location");                         ->ps
  440  fm(15):         printstring("%begin");                                 ->miss
  441  fm(16):         printstring("%end");                                   ->miss
  442  fm(17):         printstring("%repeat");                                ->miss
  443  fm(18):         printstring("%finish");                                ->miss
  444  fm(19):         printstring("result");                                 ->miss
  445  fm(20):         printsymbol('"'); print ident(x, 0); printsymbol('"'); ->miss
  446  fm(21):         printstring("context ");  print ident(this, 0);        ->ps
  447  fm(22):         printstring("format");                                 ->ps
  448  
  449  miss:           printstring(" missing");                               ->nps
  450  psd:            pos1 = 0
  451  ps:             print ss
  452  nps:            newline
  453                  %exit %if st = listing
  454                  st = listing
  455              %repeat
  456              %if n >= 0 %start
  457                  !%signal 15,15 %if diag&4096 # 0
  458                  %if n # 13 %start;           !order is fairly safe
  459                      ocount = -1
  460                      gg = 0
  461                      copy = 0;  quote = 0
  462                      search base = 0;  escape class = 0
  463                      gg = 0
  464                  %finish
  465                  faulty = faulty+1
  466     
  467                  !check that there haven't been too many faults
  468     
  469                  fault rate = fault rate+3;  abandon(6) %if fault rate > 30
  470                  fault rate = 3 %if fault rate <= 0
  471              %finish
  472              tbase = tstart
  473              %if list <= 0 %and sym # nl %start
  474                  error margin = column
  475                  error sym = sym;  sym = nl
  476              %finish
  477          %end
  478  
  479          dmin = dmin-1;  dict(dmin) = -1;            !end marker for starts & cycles
  480          abandon(2) %if dmax = dmin
  481  
  482          %if list > 0 %and level > 0 %start
  483              write(lines, 5);  spaces(level*3-1)
  484              %if block tag = 0 %start
  485                  printstring("Begin")
  486              %finish %else %start
  487                  printstring("Procedure ");  print ident(block tag, 0)
  488              %finish
  489              newline
  490          %finish
  491  
  492          !deal with procedure definition (parameters)
  493          %if block tag # 0 %start;                   !proc
  494              analyse;  compile %if ss # 0
  495  
  496              %if block otype # 0 %start;              !external-ish
  497                  %if bflags&spec = 0 %start;           !definition
  498                      %if progmode <= 0 %and level = 1 %then progmode = -1 %else fault(7)
  499                  %finish
  500              %finish
  501  
  502              new app = gapp;                          !generate app grammar
  503              %if spec given # 0 %start;               !definition after spec
  504                  fault(6) %if new app # block app;     !different from spec
  505              %finish
  506              block app = new app;                     !use the latest
  507  
  508              %if level < 0 %start;                    !not procedure definition
  509                  delete names(0)
  510                  %return
  511              %finish
  512          %finish %else %start
  513              open = 0;                                !can return from a block?
  514          %finish
  515  
  516          %cycle
  517              analyse
  518              %if ss # 0 %start
  519                  compile
  520                  fault(-5) %if dubious # 0
  521                  flush buffer( 128 )                    ;! flush if bp >= 128
  522                  %if sstype > 0 %start;                 !block in or out
  523                      %exit %if sstype = 2;               !out
  524                      compile block(spec mode, block x, dmin, tmax, id)
  525                      %exit %if ss < 0;                   !endofprogram
  526                  %finish
  527              %finish
  528          %repeat
  529          %if list > 0 %and level > 0 %start
  530              write(lines, 5);  spaces(level*3-1)
  531              printstring("End")
  532              newline
  533          %finish
  534          delete names(0)
  535          %return
  536  
  537          ! generate app grammar (backwards)
  538          %integerfn gapp
  539              %constinteger comma = 140;               !psep
  540              %routinespec set cell(%integer g, tt)
  541              %routinespec class(%record(tagfm)%name v)
  542              %record(tagfm)%name v
  543              %integer p, link, tp, c, ap, t
  544  
  545              %result = 0 %if tmax = local;            !no app needed
  546  
  547              p = gmax1;  link = 0;  t = tmax
  548  
  549              %cycle
  550                  v == tag(t);  t = t-1
  551                  class(v);                             ! deduce class from tag
  552                  %if c < 0 %start;                     ! insert %PARAM
  553                      c = -c
  554                      set cell(196, tp)
  555                      tp = -1
  556                  %finish
  557                  set cell(c, tp)
  558                  %exit %if t = local;                  ! end of parameters
  559                  set cell(comma, -1);                  ! add the separating comma
  560              %repeat
  561              abandon(3) %if gmax > gmin
  562  
  563              %result = link
  564  
  565              %routine set cell(%integer g, tt)
  566                  ! add the cell to the grammar, combining common tails
  567                  %while p # gmax %cycle
  568                      p = p+1
  569                      %if glink(p) = link %and gram(p) = g %start
  570                          %if tt < 0 %or (gram(p+1) = tt %and glink(p+1)=ap) %start
  571                              link = p;                    ! already there
  572                              %return
  573                          %finish
  574                      %finish
  575                  %repeat
  576  
  577                  !add a new cell
  578                  gmax = gmax+1
  579                  gram(gmax) = g
  580                  glink(gmax) = link
  581                  link = gmax
  582  
  583                  %if tt >= 0 %start;             ! set type cell
  584                      gmax = gmax+1
  585                      gram(gmax) = tt
  586                      glink(gmax) = ap
  587                  %finish
  588                  p = gmax
  589  
  590              %end
  591  
  592              %routine class(%record(tagfm)%name v)
  593                  %constinteger err    = 89
  594                  %constinteger rtp    = 100
  595                  %constinteger fnp    = 101
  596                  %constinteger mapp   = 102
  597                  %constinteger predp  = 103
  598                  %constintegerarray class map(0:15) = %c
  599+                           err,1764, 247, err(4), -rtp, -fnp, -mapp, -predp, err, 214,
  600+                 !         err,1764, 247, err(4), -rtp, -fnp, -mapp, -predp, err, 214,
  601+                           err, 229, err
  602                  !         err, 229, err
  603                  %integer tags, type, form
  604  
  605                  ap = 0
  606                  tags = v_flags
  607                  type = tags>>4&7;  form = tags&15
  608                  tp = v_format<<3!type
  609                  c = class map(form)
  610                  c = 208 %and tp = 0 %if type = 0 %and form = 2;  !%name
  611                  ap = v_app %if tags&parameters # 0
  612              %end
  613          %end
  614  
  615          %routine delete names(%integer quiet)
  616              %integer flags
  617              %record(tagfm)%name tx
  618  
  619              %while tmax > tbase %cycle
  620                  x = tmax;  tmax = tmax-1
  621                  tx == tag(x)
  622                  flags = tx_flags
  623                  fault(20) %if flags&spec # 0 %and flags&own bit = 0
  624                  !{spec with no definition & not external}
  625                  %if flags&used bit = 0 %and level >= 0 %and list <= 0 %start
  626                      fault(-3) %if quiet = 0;          !unused
  627                  %finish
  628                  dict(tx_text) = tx_link
  629              %repeat
  630          %end
  631  
  632          %routine analyse
  633              %constinteger order bits = 16_3000, order bit = 16_1000
  634              %constinteger escape     = 16_1000
  635              %integer strp, mark, flags, prot err, k, s, c
  636              %owninteger key = 0
  637              %integer node
  638              %integername z
  639              %record(arfm)%name arp
  640              %switch act(actions:phrasal), paction(0:15)
  641  
  642              %routine trace analysis
  643                  !diagnostic trace routine (diagnose&1 # 0)
  644                  %integer a
  645  
  646                  %routine show(%integer a)
  647                      %if 0 < a %and a < 130 %start
  648                          space
  649                          printstring(text(a))
  650                      %finish %else write(a, 3)
  651                  %end
  652  
  653                  %owninteger la1=0, la2=0, lsa=0, lt=0
  654                  newline %if mon pos # pos %and sym # nl
  655                  mon pos = pos
  656                  write(g, 3)
  657                  space
  658                  printstring(text(class))
  659                  printsymbol('"') %if gg&trans bit # 0
  660                  a = gg>>8&15
  661                  %if a # 0 %start
  662                      printsymbol('{')
  663                      write(a, 0)
  664                      printsymbol('}')
  665                  %finish
  666                  %if atom1 # la1 %or atom2 # la2 %or lsa # subatom %or lt # type %start
  667                      printstring(" [")
  668                      la1 = atom1
  669                      show(la1)
  670                      la2 = atom2
  671                      show(la2)
  672                      lsa = subatom
  673                      write(lsa, 3)
  674                      lt = type
  675                      write(lt, 5)
  676                      printsymbol(']')
  677                  %finish
  678                  newline
  679              %end
  680  
  681              %routine get sym
  682                  readsymbol(sym)
  683                  abandon(5) %if sym < 0
  684                  pos = pos+1 %if pos # 133
  685                  char(pos) = sym
  686                  printsymbol(sym) %if list <= 0
  687                  column = column+1
  688              %end
  689  
  690              %routine read sym
  691                  %owninteger Last = 0
  692                  %constbyteintegerarray mapped(0:127) = %c
  693+                   0,  0,  0,  0,   0,  0,  0,  0,    0,  0, 10,  0,   3,  0,  0,  0,
  694+                   0,  0,  0,  0,   0,  0,  0,  0,    0,  0,  0,  0,   0,  0,  0,  0,
  695+                   0,'!','"','#', '$',  1,'&', 39,  '(',')','*','+', ',','-','.','/',
  696+                 '0','1','2','3', '4','5','6','7',  '8','9',':',';', '<','=','>','?',
  697+                 '@','A','B','C', 'D','E','F','G',  'H','I','J','K', 'L','M','N','O',
  698+                 'P','Q','R','S', 'T','U','V','W',  'X','Y','Z','[', '\',']','^','_',
  699+                 '`','A','B','C', 'D','E','F','G',  'H','I','J','K', 'L','M','N','O',
  700+                 'P','Q','R','S', 'T','U','V','W',  'X','Y','Z', 2 , '|','}','~',  0
  701  
  702                  !!   0 = space
  703                  !!   1 = %
  704                  !!   2 = {
  705                  !!   3 = ff
  706                  !!   other values represent themselves
  707  
  708                  %if sym = nl %start
  709  s1:                 lines = lines+1
  710                      printsymbol(end mark) %if end mark # 0
  711  s11:                pos = 0;  pos1 = 0;  pos2 = 0;  margin = 0;  column = 0
  712                      Last = 0
  713                      end mark = 0
  714                      %if list <= 0 %start
  715                          %if include # 0 %start
  716                              printstring(" &");  write(lines, -4)
  717                          %finish %else  write(lines, 5)
  718                          csym = cont;  printsymbol(csym)
  719                          space
  720                          %if error margin # 0 %start
  721                              lines = lines-1
  722                              spaces(error margin)
  723                              error margin = 0
  724                              %if error sym # 0 %start
  725                                  printsymbol(error sym)
  726                                  pos = 1;  char(1) = error sym
  727                                  sym = error sym;  error sym = 0
  728                                  ->s5
  729                              %finish
  730                          %finish
  731                      %finish
  732  s2:                 symtype = 1
  733                  %finish
  734  s3:             readsymbol(sym)
  735                  abandon(5) %if sym < 0
  736                  pos = pos+1 %if pos # 133
  737                  char(pos) = sym
  738                  printsymbol(sym) %if list <= 0
  739                  column = column+1
  740  s5:             %if sym # nl %start
  741                      Last = Sym
  742                      %return %if quote # 0;                     !dont alter strings
  743                      sym = mapped(sym&127)
  744                      %if sym <= 3 %start;                       !special symbol
  745                          ->s2 %if sym = 0;                       !space (or dubious control)
  746                          symtype = 2 %and ->s3 %if sym = 1;      !%
  747                          cont = '+' %and ->s11 %if sym = 3;      !ff
  748                          !must be {
  749                          %cycle
  750                              get sym
  751                              ->s3 %if sym = '}'
  752                              ->s4 %if sym = nl
  753                          %repeat
  754                      %finish
  755                      key = kdict(sym)
  756                      %if key&3 = 0 %and symtype = 2 %start;            !keyword
  757                          %if sym = 'C' %and nextsymbol = nl %start;     !%c...
  758                              getsym;  cont = '+';  ->s1
  759                          %finish
  760                      %else
  761                          symtype = key&3-2
  762                      %finish
  763                      %return
  764                  %finish
  765  s4:             symtype = quote
  766                  ->S1 %if last = 0 %and Quote = 0
  767                  Cont = '+'
  768              %end
  769  
  770              %integerfn format selected
  771                  format list = tag(format)_app;      !number of names
  772                  %if format list < 0 %start;         !forward ref
  773                      atom1 = error+22
  774                      %result = 0
  775                  %finish
  776                  %if sym = '_' %start
  777                      escape class = esc rec
  778                      search base = tag(format)_format
  779                  %finish
  780                  %result = 1
  781              %end
  782  
  783              %routine code atom(%integer target)
  784                  %integer dbase, da
  785                  %integer base, n, mul, pend quote
  786                  %integer j,k,l, pt
  787  
  788                  %routine lookup(%integer d)
  789                      %integer new name, vid, k1, k2, form
  790                      %record(tagfm)%name t
  791                      %integer new
  792  
  793                      ! twee little function because SKIMP86 can't do string compare properly
  794                      ! returns 1 if the two names are the same, else zero
  795                      %integerfn dict match(%integer ptr1, ptr2)
  796                          %integer len;
  797                          ! start with a cheap check of the length and first character
  798                          %if dict(ptr1) # dict(ptr2) %then %result = 0
  799                          len = dict(ptr1) & 255
  800                          ptr1 = ptr1 + 1
  801                          ptr2 = ptr2 + 1
  802                          len = len - 1
  803                          %while len >= 2 %cycle
  804                              %if dict(ptr1) # dict(ptr2) %then %result = 0
  805                              ptr1 = ptr1 + 1
  806                              ptr2 = ptr2 + 1
  807                              len = len - 2
  808                          %repeat
  809                          ! if the string was odd length, we might need one last byte checked
  810                          %if len = 1 %start
  811                              %if dict(ptr1)&255 # dict(ptr2)&255 %then %result = 0
  812                          %finish
  813                          %result = 1
  814                      %end
  815  
  816                      !first locate the text of the name
  817                      new = dmax+1;     ! points to text of string in dictionary
  818                      k1 = hash value & max names;        ! rather crude hash!
  819  
  820                      %cycle
  821                          newname = hash(k1)
  822                          %exit %if newname = 0;                !not in
  823                          ->in %if dict match(newname+1, new) = 1
  824                          k1 = (k1+1)&max names
  825                      %repeat
  826  
  827                      ! not found
  828                      spare names = spare names-1
  829                      abandon(2) %if spare names <= 0
  830                      hash(k1) = dmax;                               !put it in
  831                      dict(dmax) = -1
  832                      newname = dmax;  dmax = dp;  ->not in
  833  
  834  in:                 search base = rbase %if this >= 0 %and d # 0;  !record elem defn
  835                      %if search base # 0 %start;                    !record subname
  836                          new = -1
  837                          x = search base
  838                          %cycle
  839                              ->not in %if x < format list
  840                              %exit %if tag(x)_text = new name
  841                              x = x-1
  842                          %repeat
  843                      %finish %else %start;                   !hash in for normal names
  844                          x = dict(newname)
  845                          ->not in %if x <= limit;             !wrong level
  846                      %finish
  847  
  848                      subatom = x;                            !name found, extract info
  849                      t == tag(x)
  850                      atom flags = t_flags
  851                      format = t_format;  app = t_app
  852                      protection = atom flags&prot
  853                      type = atom flags>>4&7;  atom1 = amap(atom flags&15)
  854  
  855                      %if diag&8 # 0 %start
  856                          printstring("lookup:")
  857                          write(atom1, 3)
  858                          write(type, 1)
  859                          write(app, 3)
  860                          write(format, 5)
  861                          write(atom flags, 3)
  862                          newline
  863                      %finish
  864  
  865                      %if d = 0 %start;                             !old name wanted
  866                          t_flags = t_flags!used bit
  867                          search base = 0
  868  
  869                          %if atom flags&subname # 0 %and format # 0 %start; !a record
  870                              %return %if format selected = 0
  871                          %finish
  872  
  873                          %if atom flags&parameters # 0 %start;      !proc or array
  874                              %if app = 0 %start;                     !no parameters needed
  875                                  atom2 = atom1
  876                                  atom1 = atom1-4
  877                                  %if 97 <= atom1 %and atom1 <= 98 %start
  878                                      map gg = atom1;  atom1 = var
  879                                  %finish
  880                              %finish %else %start
  881                                  %if sym = '(' %start
  882                                      search base = 0;                  !ignore format for now
  883                                      %if atom1 >= 106 %start;          !arrays
  884                                          app = phrase(app+200)
  885                                          escape class = esc array
  886                                          atom1 = (atom1-106)>>1+91;     !a,an->v  na,nan->n
  887                                      %finish %else %start;             !procedures
  888                                          escape class = esc proc
  889                                          atom1 = atom1-4
  890                                      %finish
  891                                      phrase(200) = app
  892                                  %finish
  893                              %finish
  894                              pos2 = pos;  %return
  895                          %finish
  896  
  897                          !deal with constintegers etc
  898                          %if atom flags&const bit # 0 %and atom1 = var %start
  899                              map gg = const;  atom2 = const
  900                              subatom = -subatom %if type = integer
  901                          %finish
  902                          %return
  903                      %finish
  904                                                                  !new name wanted
  905                      ->not in %if tbase # tstart;                !don't fault proc parm-parm
  906                      %if d = lab+spec+used bit %start
  907                          t_flags = t_flags!used bit
  908                          %return
  909                      %finish
  910                      %if atom flags&spec # 0 %start;            !a spec has been given
  911                          %if d = lab %start;                     !define label
  912                              t_flags = t_Flags-Spec
  913                              %return
  914                          %finish
  915                          %if 7 <= decl&15 %and decl&15 <= 10 %and decl&spec = 0 %start
  916                              !procedure definition after spec
  917                              %if (decl!!atom flags)&2_1111111 = 0 %start;  !correct type?
  918                                  t_flags = t_flags-spec
  919                                  spec given = 1
  920                                  %return
  921                              %finish
  922                              !note that an external procedure must be speced as a
  923                              !non-external procedure.
  924                          %finish
  925                          %if decl&15 = recfm %start;              !recordformat
  926                              t_flags = record<<4+recfm
  927                              t_format = fdef
  928                              %return
  929                          %finish
  930                      %finish
  931                      %return %if last1 = jump %and atom1 = swit
  932                      copy = x %if copy = 0
  933  notin:              app = 0;  vid = 0
  934                      atom1 = error+2
  935  
  936                      %return %if d = 0;                         !old name wanted
  937                      type = d>>4&7;  form = d&15;  atom1 = amap(form)
  938  
  939                      %if this < 0 %start;                       !normal scope
  940                          new = newname
  941                          tmax = tmax+1;  x = tmax
  942                      %finish %else %start;                      !recordformat scope
  943                          new = -1
  944                          recid = recid-1;  vid = recid
  945                          tmin = tmin-1;  x = tmin
  946                          format list = tmin
  947                      %finish
  948  
  949                      %if 11 <= form %and form <= 14 %start;               !arrays
  950                          dim = 1 %if dim = 0;                    !set dim for owns
  951                          app = dim
  952                      %finish
  953  
  954                      d = d!used bit %if (otype > 2 %and d&spec = 0) %or perm # 0 %or Level = Include Level
  955  
  956                      !external definitions need not be used in the file in which
  957                      !they are defined, so inhibit a useless unused warning.
  958  
  959                      t == tag(x)
  960                      %if form = lab %start
  961                          id = id+1;  vid = id
  962                      %finish
  963                      t_index = vid
  964                      t_text   = new name
  965                      t_flags = d
  966                      t_app    = app
  967                      t_format = fdef;  format = fdef
  968                      subatom = x
  969  
  970                      %if new >= 0 %start;                             !insert into hash table
  971                          t_link = dict(new);  dict(new) = x
  972                          %if gmin = max grammar %start;                !proc param params
  973                              tmin = tmin-1;  subatom = tmin
  974                              tag(tmin) = t
  975                          %finish
  976                      %finish
  977                      abandon(3) %if tmax >= tmin
  978                  %end
?K2 unused
  979  
  980  top:            pos1 = pos
  981                  subatom = 0;  pend quote = 0;  atom flags = 0
  982  
  983                  !app and format must be left for assigning to papp & pformat
  984                  ->name %if symtype = -2;               ! letter
  985                  ->number %if symtype < 0;              ! digit
  986                  %if symtype = 0 %start
  987                      atom1 = termin;  atom2 = 0
  988                      %return
  989                  %finish
  990                  %if symtype # 2 %start;                ! catch keywords here
  991                      ->text %if quote # 0;              ! completion of text
  992                      ->strings %if sym = squote;        ! start of string
  993                      ->symbols %if sym = cquote;        ! start of symbol
  994                      ->number %if sym = '.' %and '0' <= nextsymbol %and nextsymbol <= '9'
  995                  %finish
  996  
  997                  ! locate atom in fixed dict
  998                  k = key>>2;  read sym
  999                  %cycle
  1000                      j = kdict(k)
  1001                      %exit %if j&16_4000 # 0
  1002                      %if j&127 # sym %or symtype < 0 %start
  1003                          ->err %unless j < 0
  1004                          k = k+1
  1005                      %finish %else %start
  1006                          l = j>>7&127;  read sym
  1007                          %if j > 0 %start
  1008                              %if l # 0 %start
  1009                                  ->err %if l # sym %or symtype < 0
  1010                                  read sym
  1011                              %finish
  1012                              l = 1
  1013                          %finish
  1014                          k = k+l
  1015                      %finish
  1016                  %repeat
  1017                  atom1 = j&127
  1018                  %if atom1 = 0 %start;                  ! comma
  1019                      atom1 = 19;  subatom = 19;  atom2 = 0
  1020                      %if sym = nl %start
  1021                          %return %if ocount >= 0
  1022  
  1023                          ! special action needs to be taken with <comma nl> as
  1024                          ! const array lists can be enormous
  1025                          read sym
  1026                      %finish
  1027                      %return
  1028                  %finish
  1029                  atom2 = j>>7&127
  1030                  subatom = kdict(k+1)&16_3fff
  1031                  !!!!!cont = ' '
  1032                  %return
  1033  
  1034                  ! report an error. adjust the error marker (pos1) to point
  1035                  ! to the faulty character in an atom, but care needs to be taken
  1036                  ! to prevent misleading reports in cases like ...?????
  1037  
  1038  err:            atom1 = error+1;  atom2 = 0
  1039                  pos1 = pos %if pos-pos1 > 2
  1040                  %return
  1041  
  1042                  ! take care with strings and symbol constants.
  1043                  ! make sure the constant is valid here before sucking it in
  1044                  ! (and potentially loosing many lines)
  1045  
  1046  symbols:        atom1 = var;  atom2 = const;  type = integer
  1047                  map gg = const;  protection = prot
  1048                  subatom = lp;  abandon(3) %if lp >= lit max
  1049                  quote = \pend quote
  1050                  %return
  1051  
  1052                  ! an integer constant is acceptable so get it in and
  1053                  ! get the next atom
  1054  chars:          n = 0;  cont = cquote
  1055                  %cycle
  1056                      read sym
  1057                      %if sym = cquote %start
  1058                          %exit %if nextsymbol # cquote
  1059                          read sym
  1060                      %finish
  1061                      %if n&(\((-1)>>byte size)) # 0 %start; ! overflow
  1062                          pos1 = pos;  atom1 = error+10;  %return
  1063                      %finish
  1064                      ->err %if quote = 0
  1065                      n = n<<byte size+sym
  1066                      quote = quote+1
  1067                  %repeat
  1068                  quote = 0;  cont = ' '
  1069                  readsym %if sym # nl
  1070                  lit pool(lp) = n;  lp = lp+1
  1071                  ->top
  1072  
  1073                  !sniff the grammar before getting the string
  1074  strings:        atom1 = var;  atom2 = const;  type = stringv
  1075                  subatom = strp!16_4000
  1076                  map gg = const;  protection = prot
  1077                  quote = subatom
  1078                  text line = lines;                     ! in case of errors
  1079                  %return
  1080  
  1081                  ! a string constant is ok here, so pull it in and get
  1082                  ! the next atom
  1083                  ! ABD - temp variable to help pack bytes into words
  1084                  %integer flipflop
  1085  
  1086  text:           ->chars %if quote < 0;                 ! character consts
  1087                  l = strp;                              ! point to beginning
  1088                  k = 0;                                 ! length so far
  1089                  flipflop = 0;                          ! space for the length is up the spout
  1090  
  1091                  %cycle
  1092                      cont = squote;  quote = 1
  1093                      %cycle
  1094                          read sym
  1095                          %if sym = squote %start;       ! terminator?
  1096                              %exit %if nextsymbol # squote; ! yes ->
  1097                              read sym;                  ! skip quote
  1098                          %finish
  1099                          %if flipflop >= 0 %start
  1100                              glink(strp) = sym<<8 + flipflop
  1101                              strp = strp+1
  1102                              flipflop = -1
  1103                          %else
  1104                              flipflop = sym
  1105                          %finish
  1106                          k = k+1
  1107                          lines = text line %and abandon(7) %if k > 255; ! too many chars
  1108                      %repeat
  1109                      %if flipflop >=0 %start;           ! tail-end charlie
  1110                          glink(strp) = flipflop
  1111                          strp = strp+1
  1112                      %finish
  1113                      glink(l) = glink(l)!k;             ! plug in length
  1114  
  1115                      quote = 0;  cont = ' ';  read sym
  1116                      code atom(target)
  1117                      %return %unless atom1 = 48 %and sym = squote; ! fold "???"."+++"
  1118                  %repeat
  1119  
  1120                  %routine get(%integer limit)
  1121                      %integer s, shift
  1122                      shift = 0
  1123                      %if base # 10 %start
  1124                          %if base = 16 %start
  1125                              shift = 4
  1126                          %finish %else %start
  1127                              %if base = 8 %start
  1128                                  shift = 3
  1129                              %finish %else %start
  1130                                  %if base = 2 %start
  1131                                      shift = 1
  1132                                  %finish
  1133                              %finish
  1134                          %finish
  1135                      %finish
  1136                      n = 0
  1137                      %cycle
  1138                          %if symtype = -1 %start;       ! digit
  1139                              s = sym-'0'
  1140                          %finish %else %start
  1141                              %if symtype < 0 %start;    ! letter
  1142                                  s = sym-'A'+10
  1143                              %finish %else %start
  1144                                  %return
  1145                              %finish
  1146                          %finish
  1147                          %return %if s >= limit
  1148                          pt = pt+1;  glink(pt) = sym
  1149                          %if base = 10 %start;          ! check overflow
  1150                              %if n >= max int %and (s > max dig %or n > max int) %start
  1151                                  !too big for an integer,
  1152                                  !so call it a real
  1153                                  base = 0;  type = real;  n = 0
  1154                              %finish
  1155                          %finish
  1156                          %if shift = 0 %start
  1157                              n = n*base+s
  1158                          %finish %else %start
  1159                              n = n<<shift+s
  1160                          %finish
  1161                          read sym
  1162                      %repeat
  1163                  %end
  1164  
  1165  number:         base = 10
  1166  bxk:            atom1 = var;  atom2 = const;  type = integer;  subatom = lp
  1167                  map gg = const;  protection = prot
  1168                  abandon(3) %if lp >= lit max
  1169                  pt = strp;  mul = 0
  1170                  %cycle
  1171                      get(base)
  1172                      %exit %unless sym = '_' %and base # 0 %and pend quote = 0; ! change of base
  1173                      pt = pt+1;  glink(pt) = '_'
  1174                      read sym
  1175                      base = n
  1176                  %repeat
  1177  
  1178                  %if pend quote # 0 %start
  1179                      ->err %if sym # cquote
  1180                      readsym
  1181                  %finish
  1182                  %if sym = '.' %start;                  ! a real constant
  1183                      pt = pt+1;  glink(pt) = '.'
  1184                      read sym
  1185                      type = real;  n = base;  base = 0;  get(n)
  1186                  %finish
  1187  
  1188                  %if sym = '@' %start;                  ! an exponent
  1189                      pt = pt+1;  glink(pt) = '@';  k = pt
  1190                      readsym
  1191                      type = integer;  base = 10
  1192                      %if sym = '-' %start
  1193                          read sym;  get(10);  n = -n
  1194                      %finish %else %start
  1195                          get(10)
  1196                      %finish
  1197                      pt = k+1;  glink(pt) = lp;  litpool(lp) = n;  lp = lp+1
  1198                      atom1 = error+10 %if base = 0
  1199                      type = real;                       ! exponents force the type
  1200                  %finish
  1201  
  1202                  %if type = real %start
  1203                      glink(strp) = pt-strp;             ! store the length (difference)
  1204                      subatom = (strp)!16_2000;  strp = pt+1
  1205                  %finish %else %start
  1206                      litpool(lp) = n
  1207                      lp = lp+1
  1208                  %finish
  1209                  %return
  1210  
  1211  name:           atom1 = 0 %and %return %if 27 <= target %and target <= 41
  1212                  hash value = 0
  1213  
  1214                  ! ABD changed to remove dependency on direct addressing
  1215                  dp = dmax+1
  1216                  dbase = dp
  1217                  n = 0
  1218                  dict(dp) = 0
  1219                  %cycle
  1220                      hash value = hash value+(hash value+sym); ! is this good enough?
  1221                      dict(dp) = dict(dp) ! (sym << 8);
  1222                      n = n+1
  1223                      dp = dp+1
  1224                      read sym
  1225                      %exit %if symtype >= 0
  1226                      dict(dp) = sym;
  1227                      n = n+1
  1228                      read sym
  1229                      %exit %if symtype >= 0
  1230                  %repeat
  1231                  %if sym = cquote %start
  1232                      pend quote = 100
  1233                      ->symbols %if hash value = 'M'
  1234                      read sym
  1235                      %if hash value = 'X' %then base = 16 %and ->bxk
  1236                      %if hash value = 'K' %or hash value = 'O' %then base = 8 %and ->bxk
  1237                      %if hash value = 'B' %then base = 2 %and ->bxk
  1238                      ->err
  1239                  %finish
  1240                  dict(dbase) = dict(dbase)!n
  1241                  %if n&1 = 0 %then dp = dp+1
  1242                  abandon(8) %if dp >= dmin
  1243  
  1244                  atom2 = 90;                            ! ident
  1245                  %if last1 = 0 %and sym = ':' %start;   ! label
  1246                      limit = local;  lookup(lab);  %return
  1247                  %finish
  1248                  %if last1 = jump %start;               ! ->label
  1249                      limit = local;  lookup(lab+spec+used bit);  %return
  1250                  %finish
  1251                  %if decl # 0 %and target = 90 %start;  ! identifier
  1252                      search base = fm base
  1253                      limit = local;  lookup(decl)
  1254                      search base = 0
  1255                  %finish %else %start
  1256                      limit = 0;  lookup(0)
  1257                  %finish
  1258              %end
?DA unused
  1259  
  1260              %integerfn parsed machine code
  1261                  !   *opcode_??????????
  1262                  atom1 = error %and %result=0 %unless symtype = -2; ! starts with letter
  1263                  flush buffer( 128 );                   ! flush if bp >= 128
  1264                  add char( 'w' )
  1265                  %cycle
  1266                      add char( sym ); read sym
  1267                  %repeat %until Sym = '_' %or Symtype = 0; ! pull in letters and digits
  1268                  add char( '_' )
  1269                  %if symtype # 0 %start;                ! not terminator
  1270                      read sym
  1271                      %while symtype # 0 %cycle
  1272                          %if symtype < 0 %start;        ! complex
  1273                              code atom(0);  %result=0 %if atom1&error # 0
  1274                              %if atom2 = const %and type = integer %start
  1275                                  %if subatom < 0 %then set const(tag(-subatom)_format) %else set const(litpool(subatom))
  1276                              %finish %else %if 91 <= atom1 %and atom1 <= 109 %start
  1277                                  %if atom1 = 104 %and Tag(Subatom)_Flags&Closed = 0 %start
  1278                                      This = Subatom;  Atom1 = Error+21
  1279                                      %result = 0
  1280                                  %finish
  1281                                  op(' ', tag(subatom)_index)
  1282                              %finish %else %start
  1283                                  atom1 = error;  %result=0
  1284                              %finish
  1285                          %finish %else %start
  1286                              sym = sym!128 %if symtype = 2      {underline with %}
  1287                              add char( sym ); read sym
  1288                          %finish
  1289                      %repeat
  1290                  %finish
  1291                  add char( ';' )
  1292                  %result=1
  1293              %end
  1294  
  1295              cont = ' ' %if gg = 0
  1296              last1 = 0;  mapgg = 0
  1297              s = 0;  ss = 0;  sstype = -1; fdef = 0
  1298              fm base = 0
  1299              app = 0
  1300  
  1301              ! deal with alignment following an error in one statement
  1302              ! of several on a line
  1303              margin = column;                           ! start of statement
  1304              pos = 0
  1305              strp = gmax+1;  lp = 0
  1306              tbase = tstart;                            ! ??????????????
  1307              local = tbase
  1308  
  1309              %if gg = 0 %or ocount >= 0 %start;         ! data or not continuation(z)
  1310  again:          %while sym type = 0 %cycle;            ! skip redundant terminators
  1311                      c = cont
  1312                      cont = ' ';  cont = '+' %if ocount >= 0
  1313                      read sym
  1314                      cont = c
  1315                  %repeat
  1316                  ->skip %if sym = '!';                  ! comment
  1317                  this = -1
  1318                  code atom(0)
  1319                  %if atom1 = comment %start
  1320  skip:               quote = 1
  1321                      c = cont
  1322                      read sym %and cont = c %while sym # nl; ! skip to end of line
  1323                      quote = 0;  symtype = 0
  1324                      ->again
  1325                  %finish
  1326              %finish
  1327              decl = 0;  mark = 0
  1328              gentype = 0;  force = 0
  1329              dim = 0;  prot err = 0
  1330              node = 0;  nmax = 0;  nmin = rec size+1
  1331              order = 1;  gmin = max grammar+1
  1332              sstype = 0 %and ->more %if gg # 0;         ! continuation
  1333              ptype = 0;  spec given = 0
  1334  
  1335              stats = stats+1;  op('O', lines) %if perm = 0
  1336  
  1337              ->fail1 %if atom1&error # 0;               ! first atom faulty
  1338  
  1339              %if escape class # 0 %start;               ! enter the hard way after
  1340                  g = imp phrase;  sstype = -1;  ->a3
  1341              %finish
  1342  
  1343              g = initial(atom1);                        ! pick up entry point
  1344              %if g = 0 %start;                          ! invalid first atom
  1345                  g = initial(0);  sstype = 0;  ->a3;    ! declarator?
  1346              %finish
  1347              %if g < 0 %start;                          ! phrase imp
  1348                  g = g&255
  1349                  nmax = 1
  1350                  ar(1)_class = 0;  ar(1)_link = 0;  ar(1)_sub = imp phrase
  1351              %finish
  1352  
  1353              gg = gram(g);  class = gg&255;  sstype = gg>>12&3-1
  1354              ->a1
  1355  
  1356  act(194):   ptype = type;  papp = app;  pformat = format;  ->more
  1357  act(196):   k =g+1;  ->a610
  1358  act(188):   k = ar(nmax)_sub+1
  1359  a610:       papp = glink(k)
  1360              k = gram(k)
  1361              ->more %if k = 0;                          ! %name
  1362              ptype = k&7;  pformat = k>>3
  1363  act(183):   k = type;  gentype = k %if gentype = 0 %or k = real
  1364              %if pformat < 0 %start;                    ! general type
  1365                  app = papp;  format = pformat
  1366                  k = real %if ptype = real %and type = integer
  1367                  k = force %and force = 0 %if force # 0
  1368              %finish
  1369              ->fail2 %unless papp = app %and (ptype = k %or ptype = 0)
  1370              ->more %if pformat=format %or pformat = 0 %or format = 0
  1371              ->fail2
  1372  act(197):   arp == ar(nmin)
  1373              k = arp_sub
  1374              ->fail3 %unless block form = k&15
  1375              arp_sub = k>>4
  1376  
  1377              type = block type
  1378              ptype = block type;  pformat = block fm;  papp = app
  1379              pformat = -1 %if ptype # record
  1380              ->more
  1381  act(195):   ->Fail2 %if Type # 0 %and Type # Integer %and Type # Real
  1382              arp == ar(nmin)
  1383              k = arp_sub
  1384              arp_sub = k>>2
  1385              k = k&3
  1386                                                         ! 1 = check integer
  1387                                                         ! 2 = check real
  1388                                                         ! 3 = check real + int
  1389              ->more %if k = 0;                          ! 0 = no action
  1390              %if k = 1 %start
  1391                  force = integer
  1392                  ->more %if type = integer %or type = 0
  1393                  ->fail2
  1394              %finish
  1395              ->fail2 %unless ptype = real %or ptype = 0; ! {or added?}
  1396              force = integer %if k = 3
  1397              ->more
  1398  act(198):   ! %OTHER
  1399              k = gg>>8&15
  1400              %if k = 0 %start;                          ! restore atom
  1401                  atom1 = last1
  1402                  ->more
  1403              %finish
  1404              %if k = 1 %start;                          ! test string
  1405                  ->fail2 %unless type = stringv
  1406                  ->more
  1407              %finish
  1408              %if k = 2 %start;                          ! {fault record comparisons}
  1409                  ->fail2 %if type = record
  1410                  ->more
  1411              %finish
  1412              %if k = 3 %start;                          ! check OWN variable coming
  1413                  code atom(0)
  1414                  ->A7 %if atom flags&own bit = 0
  1415                  ->more
  1416              %finish
  1417              for warn = pos1 %if x <= local;            ! %for TEST
  1418              ->more
  1419  paction(1): %if type = record %then g = phrase(242) %else pformat = -1; ->a3
  1420  paction(2): ptype = real;     pformat = -1;                             ->a3
  1421  paction(3): ptype = stringv;  pformat = -1;                             ->a3
  1422  paction(4): ptype = integer;  pformat = -1;                             ->a3
  1423  paction(5): ->a3 %if ptype = integer
  1424              g = phrase(212) %and pformat=-1 %if ptype = real
  1425              g = phrase(213) %if ptype = stringv
  1426                                                                          ->a3
  1427  paction(6): ptype = gram(ar(nmax)_sub+1)&7;  pformat = -1;              ->a3
  1428  paction(7): ptype=real %if ptype = integer;  pformat = -1;              ->a3
  1429  
  1430  a1:         last1 = class;  atom1 = 0;  s = subatom
  1431  a2:         %if gg&trans bit = 0 %start;               ! insert into analysis record
  1432                  z == node
  1433                  %cycle;                                ! insert cell in order
  1434                      k = z
  1435                      %exit %if gg&order bits = 0 %or k = 0
  1436                      gg = gg-order bit;  z == ar(k)_link
  1437                  %repeat
  1438                  gg = map gg %if map gg # 0 %and gg&255 = var
  1439                  nmin = nmin-1;  ->fail0 %if nmin = nmax
  1440                  z = nmin
  1441                  arp == ar(nmin)
  1442                  arp_sub = s;  arp_class = (gg&255)!mark
  1443                  arp_link = k
  1444              %finish
  1445              mark = 0;  map gg = 0
  1446  more:       g = glink(g);                              ! chain down the grammar
  1447  paction(0):
  1448  a3:         gg = gram(g);  class = gg&255
  1449              trace analysis %if diag&1 # 0
  1450              ->a5 %if class = 0;                        ! end of phrase
  1451  
  1452              %if class < actions %start;                ! not a phrase or an action
  1453                  class = atomic(class) %if class >= figurative
  1454                  ->a2 %if class >= manifest
  1455                  code atom(class) %if atom1 = 0
  1456                  %if escape class # 0 %start;           ! escape to new grammar
  1457                      class = escape class;  escape class = 0
  1458                      g = g+escape
  1459  
  1460                      ! note that following an escape the next item is
  1461                      ! forced to be transparent!
  1462  
  1463  esc:                gg = 0
  1464                      arp == ar(nmax+1)
  1465                      arp_papp = papp;  arp_x = x;  ->a4
  1466                  %finish
  1467  
  1468                  ->a1 %if class = atom1 %or class = atom2
  1469  
  1470  a7:             ->fail1 %if gg >= 0;                   ! no alternative
  1471                  g = g+1
  1472                  ->a3
  1473              %finish
  1474  
  1475              %if class >= phrasal %start;               ! a phrase
  1476  a4:             nmax = nmax+1;  ->fail0 %if nmax = nmin
  1477                  arp == ar(nmax)
  1478                  arp_ptype = ptype
  1479                  arp_pos = pos1
  1480                  arp_pformat = pformat
  1481                  arp_link = gentype
  1482                  arp_class = node
  1483                  arp_sub = g
  1484                  node = 0
  1485                  g = phrase(class)
  1486                  ptype = force %and force = 0 %if force # 0
  1487                  gentype = 0
  1488                  ->paction(gg>>8&15)
  1489              %finish
  1490              ->act(class);                              ! only actions left
  1491  
  1492  a5:         ;! reverse links
  1493              s = 0
  1494              %while node # 0 %cycle
  1495                  z == ar(node)_link
  1496                  k = z;  z = s;  s = node;  node = k
  1497              %repeat
  1498              ss = s
  1499  a6:         %if nmax # 0 %start
  1500                  k = gentype;                           ! type of phrase
  1501                  arp == ar(nmax);  nmax = nmax-1
  1502                  node = arp_class
  1503                  gentype = arp_link
  1504                  ptype = arp_ptype
  1505                  pformat = arp_pformat
  1506                  g = arp_sub
  1507                  %if g&escape # 0 %start
  1508                      g = g-escape
  1509                      papp = arp_papp
  1510                      mark = 255
  1511                      subatom = s
  1512                      ->a3
  1513                  %finish
  1514                  gentype = k %if gentype = 0 %or k = real
  1515                  type = gen type
  1516  
  1517                  k = gg;                                ! exit-point code
  1518                  %cycle
  1519                      gg = gram(g)
  1520                      ->a2 %if k = 0
  1521                      ->fail1 %if gg >= 0;               ! no alternative phrase
  1522                      k = k-order bit
  1523                      g = g+1;                           ! sideways step
  1524                  %repeat
  1525              %finish
  1526  
  1527              Fault(4)  %if copy # 0
  1528              fault(13) %if order = 0
  1529              fault(-4) %if for warn # 0
  1530              pos1 = 0
  1531              fault rate = fault rate-1
  1532              %return
  1533  
  1534  act(193):   gg = 0 %and ->a5 %unless sym = '=' %or sym = '<'; ! cdummy
  1535  act(181):   atom1 = amap(decl&15);                     ! dummy
  1536              ->more
  1537  
  1538  act(182):   class = escdec;  g = glink(g)!escape;      ! an example of ! as an operator
  1539              decl = 0;  otype = 0;  ->esc;              ! decl
  1540  
  1541  act(199):   ;                                          ! compile
  1542              s = 0
  1543              %while node # 0 %cycle
  1544                  z == ar(node)_link
  1545                  k = z;  z = s;  s = node;  node = k
  1546              %repeat
  1547              ss = s
  1548  
  1549              code atom(28) %if quote # 0;               ! expend
  1550              compile;  ->more %if atom1&error = 0
  1551              ->fail1
  1552  
  1553  act(184):   ->fail4 %unless type = integer
  1554              %if subatom < 0 %then lit = tag(-subatom)_format %else lit = lit pool(subatom)
  1555              ->fail4 %if lit # 0
  1556              ->more
  1557  act(185):   ;                                          ! apply parameters
  1558              s = 0
  1559              %while node # 0 %cycle
  1560                  z == ar(node)_link
  1561                  k = z;  z = s;  s = node;  node = k
  1562              %repeat
  1563              ss = s
  1564  
  1565              atom1 = ar(s)_class;  atom2 = 0
  1566              atom1 = var %if atom1 = 97 %or atom1 = 98
  1567              arp == ar(nmax)
  1568              x = arp_x
  1569              pos1 = arp_pos
  1570              pos2 = 0
  1571              app = 0
  1572              format = tag(x)_format
  1573              flags = tag(x)_flags
  1574              type = flags>>4&7
  1575              protection = flags&prot
  1576              protection = 0 %if flags&aname # 0
  1577  
  1578              %if flags&subname # 0 %and format # 0 %start
  1579                  ->fail1 %if format selected = 0
  1580              %finish
  1581  
  1582              ->a6
  1583  
  1584  act(187):   protection = prot;  ->more;                ! %SETPROT
  1585  act(186):   ->More %if protection&prot = 0
  1586              prot err = nmin
  1587              ->A7
  1588  act(191):   k = protection;                            ! %GUARD
  1589              code atom(0)
  1590              protection = k %if atom flags&aname = 0
  1591              ->more
  1592  
  1593  act(192):   ->fail1 %if parsed machine code=0
  1594              ->more
  1595  
  1596  act(189):   k = gapp;                                  ! %GAPP
  1597              delete names(1)
  1598              tmax = tbase;  tbase = gram (gmin);        ! restore tmax
  1599              local= tbase
  1600              gmin = gmin+1
  1601  
  1602              x = ar(ar(nmax)_class)_sub
  1603              tag(x)_app = k;                            ! update app
  1604              ->more
  1605  
  1606  act(190):   gmin = gmin-1;                             ! %LOCAL
  1607              abandon(2) %if gmin <= gmax
  1608              gram (gmin) = tbase;  tbase = tmax
  1609              local = tbase
  1610              ->more
  1611  
  1612              ! errors
  1613  
  1614  fail4:      k = error+10;            ->failed;         ! *size
  1615  fail3:      k = error+7;             ->failed;         ! *context
  1616  fail2:      k = error+5;  pos2 = 0;  ->failed;         ! *type
  1617  fail0:      k = error+3;             ->failed;         ! *too complex
  1618  fail1:      k = atom1;    pos2 = 0
  1619  failed:     %if diag&32 # 0 %start
  1620                  printstring("Atom1 =");      write(atom1, 3)
  1621                  printstring("  Atom2 =");    write(atom2, 3)
  1622                  printstring("  subatom =");  write(subatom, 3); newline
  1623                  printstring("Type =");       write(type, 1)
  1624                  printstring("   Ptype =");   write(ptype, 1);   newline
  1625                  printstring("App =");        write(app, 1)
  1626                  printstring("   Papp =");    write(papp, 1);    newline
  1627                  printstring("Format =");     write(format, 1)
  1628                  printstring("   Pformat ="); write(pformat, 1); newline
  1629                  !%signal 13,15
  1630              %finish
  1631  
  1632              quote = 0 %and readsym %while sym # nl %and sym # ';'
  1633              %if k&error # 0 %start
  1634                  fault(k&255)
  1635              %finish %else %start
  1636                  %if prot err = nmin %then fault(14) %else fault(0)
  1637              %finish
  1638              gg = 0;  ss = 0;  symtype = 0
  1639          %end;                                          ! of analyse
  1640  
  1641          %routine compile
  1642              %constinteger then = 4, else = 8, loop = 16
  1643  
  1644              %switch c(0:actions), litop(1:12)
  1645  
  1646              %constbyteintegerarray operator(1:14) = '[', ']', 'X', '/', '&', '!', '%', '+', '-', '*', 'Q', 'x', '.', 'v'
  1647              %constbyteintegerarray cc(0 : 7) = '#','=',')','<','(','>', 'k','t'
  1648              %constbyteintegerarray anyform(0:15) = 1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1
  1649  
  1650              %constintegerarray decmap(0:15) = %c
  1651+             1,             2,
  1652+             16_100B,       16_100D,       16_140C,      16_140E,
  1653+             3,             4,
  1654+             16_1007,       16_1008,       16_1009,      16_100A,
  1655+             6,             0,             0,            0
  1656              %ownbyteintegerarray cnest(0:15)
  1657              %integer lmode, clab, dupid
  1658              %integer resln
  1659              %owninteger last def = 0
  1660              %owninteger lb, ub
  1661              %integer cp, ord
  1662              %integer next, link, j, k, n, done
  1663              %integer class
  1664              %integer lit2, defs, decs, cident
  1665              %integer pending;  %ownintegerarray pstack(1:40)
  1666              %ownstring(8) name = ""
  1667              %owninteger count = 0
  1668  
  1669              %routine def lab(%integer l)
  1670                  op(':', l)
  1671                  access = 1
  1672              %end
  1673  
  1674              %routine get next
  1675                  %record(arfm)%name p
  1676  gn:             %if next = 0 %start;                   ! end of phrase
  1677                      class = 0 %and %return %if link = 0; ! end of statement
  1678                      p == ar(link)
  1679                      next = p_link
  1680                      link = p_sub
  1681                  %finish
  1682                  %cycle
  1683                      p == ar(next)
  1684                      x = p_sub
  1685                      class = p_class
  1686                      %exit %if class < actions;         ! an atom
  1687                      %if x = 0 %start;                  ! null phrase
  1688                          next = p_link;  ->gn
  1689                      %finish
  1690                      %if p_link # 0 %start;             ! follow a phrase
  1691                          p_sub = link;  link = next
  1692                      %finish
  1693                      next = x
  1694                  %repeat
  1695                  next = p_link
  1696                  %if diag&2 # 0 %start
  1697                      spaces(8-length(name)) %unless length(name) = 0
  1698                      name = text(class)
  1699                      write(x, 2)
  1700                      space
  1701                      printstring(name)
  1702                      space
  1703                      count = count-1
  1704                      %if count <= 0 %start
  1705                          count = 5
  1706                          name = ""
  1707                          newline
  1708                      %finish
  1709                  %finish
  1710              %end
  1711  
  1712              %routine set subs(%integer n)
  1713                  !update the app field in n array descriptors
  1714                  %integer p
  1715                  p = tmax
  1716                  %while n > 0 %cycle
  1717                      !%signal 15,15 %if p < tbase
  1718                      tag(p)_app = dimension
  1719                      p = p-1;  n = n-1
  1720                  %repeat
  1721              %end
  1722  
  1723              %routine set bp
  1724                  !define a constant bound pair from the last stacked constants
  1725                  pending = pending-2
  1726                  lb = pstack(pending+1);  ub = pstack(pending+2)
  1727                  %if ub-lb+1 < 0 %start
  1728                      pos1 = 0;  next = link;  fault(11)
  1729                      ub = lb
  1730                  %finish
  1731                  set const(lb);  set const(ub)
  1732                  add char( 'b' ) %unless class = 146
  1733              %end
  1734  
  1735              %routine compile end(%integer type)
  1736                  ! type = 0:eof, 1:eop, 2:end
  1737                  %if access # 0 %start
  1738                      open = 0
  1739                      fault(19) %if block form > proc;   ! can reach end
  1740                  %finish
  1741  
  1742                  %while dict(dmin) >= 0 %cycle;         ! finishes & repeats
  1743                      fault(17+dict(dmin)&1)
  1744                      dmin = dmin+1
  1745                  %repeat
  1746                  !{delete names(0)}
  1747                  add char( ';' )
  1748                  add char( ';' ) %if type = 1;          ! endofprogram
  1749  
  1750                  bflags = bflags!open;                  ! show if it returns
  1751  
  1752                  def lab(0) %if block tag # 0 %and level # 1; ! for jump around
  1753                  %if type # 2 %start;                   ! eop, eof
  1754                      fault(16) %if level # type;        ! end missing
  1755                  %finish %else %start
  1756                      %if level = 0 %start
  1757                          fault(15);                     ! spurious end
  1758                      %finish
  1759                  %finish
  1760  
  1761                  end mark = 11;               !******Mouses specific******
  1762              %end
  1763  
  1764              %routine def(%integer p)
  1765                  !dump a descriptor
  1766                  %integer t, f, type
  1767                  %record(tagfm)%name v
  1768                  flush buffer( 1 );                     ! flush if bp > 0
  1769                  defs = defs+1
  1770                  v == tag(p)
  1771                  t = 0
  1772                  %unless v_index < 0 %start;            ! no index for subnames
  1773                      id = id+1 %and v_index = id %if v_index = 0
  1774                      last def = v_index
  1775                      t = last def
  1776                  %finish
  1777                  op('$', t)
  1778                  print ident(p, 1);                     ! output the name
  1779                  t = v_flags
  1780                  type = t
  1781                  type = type&(\(7<<4)) %if type&(7<<4) >= 6<<4;!routine & pred
  1782                  op(',', type&2_1111111);               ! type & form
  1783                  f = v_format
  1784                  f = tag(f)_index %if t&16_70 = record<<4
  1785                  f = v_index %if f < 0
  1786                  op(',', f);                            ! format
  1787                  f = otype+t>>4&2_1111000
  1788                  f = f!8 %if class = 125;               ! add spec from %DUP
  1789                  dim = v_app;                           ! dimension
  1790                  dim = 0 %unless 0 < dim %and dim <= dim limit
  1791                  op(',', f+dim<<8);                     ! otype & spec & prot
  1792                  defs = 0 %if t&parameters = 0
  1793                  f = t&15
  1794                  %if v_flags&spec # 0 %start
  1795                      v_flags = v_flags&(\spec) %unless 3 <= f %and f <= 10
  1796                      ocount = -1;                       ! external specs have no constants
  1797                  %finish
  1798                  dimension = 0
  1799                  %if otype = 2 %and (f=2 %or f=12 %or f=14) %start
  1800                      v_flags = v_flags-1;               ! convert to simple
  1801                  %finish
  1802              %end
  1803  
  1804              %routine def s lab(%integer n)
  1805                  ! define a switch label, x defines the switch tag
  1806                  %integer p, l, b, w, bit
  1807                  p = tag(x)_format;                     ! pointer to table
  1808                  l = dict(p);                           ! lower bound
  1809                  %if l <= n %and n <= dict(p+1) %start
  1810                      b = n-l
  1811                      w = b>>4+p
  1812                      bit = 1<<(b&15)
  1813                      %if dict(w+2)&bit # 0 %start;      ! already set
  1814                          fault(4) %if pending # 0
  1815                          %return
  1816                      %finish
  1817                      dict(w+2) = dict(w+2)!bit %if pending # 0
  1818                      set const(n)
  1819                      op('_', tag(x)_index)   
  1820                  %finish %else %start
  1821                      fault(12)
  1822                  %finish
  1823                  access = 1
  1824              %end
  1825  
  1826              %routine call
  1827                  %record(tagfm)%name T
  1828                  t == tag(x)
  1829                  op('@', t_index)
  1830                  access = 0 %if t_flags&closed # 0;     ! never comes back
  1831                  add char( 'E' ) %if t_app = 0;         ! no parameters
  1832              %end
  1833  
  1834              %routine pop def
  1835                  set const(pstack(pending));  pending = pending-1
  1836              %end
  1837  
  1838              %routine pop lit
  1839                  %if pending = 0 %then lit = 0 %else %start
  1840                      lit = pstack(pending);  pending = pending-1
  1841                  %finish
  1842              %end
  1843  
  1844              !conditions & jumps
  1845              %routine push(%integer x)
  1846                  %if cnest(cp)&2 # x %start
  1847                      cnest(cp) = cnest(cp)!1;  x = x+4
  1848                  %finish
  1849                  clab = clab+1 %if cnest(cp)&1 # 0
  1850                  cnest(cp+1) = x;  cp = cp+1
  1851              %end
  1852  
  1853              %routine pop label(%integer mode)
  1854                  lmode = dict(dmin)
  1855                  %if lmode < 0 %or lmode&1 # mode %start
  1856                      fault(mode+8)
  1857                  %finish %else %start
  1858                      dmin = dmin+1;  label = label-3
  1859                  %finish
  1860              %end
  1861  
  1862              %if sstype < 0 %start;                     ! executable statement
  1863                  %if level = 0 %start;                  ! outermost level
  1864                      fault(13);                         ! *order
  1865                  %finish %else %start
  1866                      %if access = 0 %start
  1867                          access = 1;  fault(-1);        ! only a warning
  1868                      %finish
  1869                  %finish
  1870              %finish
  1871  
  1872              %if diag&2 # 0 %start
  1873                  newline %if sym # nl
  1874                  printstring("ss =")
  1875                  write(ss, 1)
  1876                  newline
  1877                  count = 5
  1878                  name = ""
  1879              %finish
  1880  
  1881              next = ss
  1882              pending = 0;  lmode = 0
  1883              link = 0;  decs = 0
  1884              defs = 0;  resln = 0;  done = 0
  1885              ord = level
  1886              ord = 1 %if this >= 0;                     ! recordformat declarations
  1887  c(0):
  1888  top:        %if next # link %start
  1889                  get next;  ->c(class)
  1890              %finish
  1891  
  1892              !all done, tidy up declarations and jumps
  1893              newline %if diag&2 # 0 %and count # 5
  1894  
  1895              %if lmode&(loop!then!else) # 0 %start;     ! pending labels and jumps
  1896                  op('B', label-1) %if lmode&loop # 0;   ! repeat
  1897                  def lab(label)   %if lmode&then # 0;   ! entry from then
  1898                  def lab(label-1) %if lmode&else # 0;   ! entry from else
  1899              %finish
  1900  
  1901              %return %if decs = 0
  1902              atom1 = error %and %return %if atom1 # 0;  ! %integerroutine
  1903              order = ord
  1904              decl = decl&(\15)+decmap(decl&15);         ! construct declarator flags
  1905              atom1 = atoms(decl&15);                    ! generate class
  1906              %if otype # 0 %start;                      ! own, const etc.
  1907                  atom1 = atom1+1 %if atom1 # proc
  1908                  %if otype = 2 %start;                  ! const
  1909                      n = decl&15
  1910                      %if n&1 # 0 %start
  1911                          decl = decl!prot
  1912                          decl = decl!const bit %if decl&2_1111111 = iform
  1913                      %finish
  1914                  %else
  1915                      decl = decl!own bit
  1916                  %finish
  1917              %finish
  1918              sstype = 1 %if sstype = 0 %and atom1 = proc
  1919              atom1 = atom1+1 %if decl&spec # 0;         ! onto spec variant
  1920              ocount = 0 %and cont = '+' %if atom1 = 5;  ! own array
  1921              %if anyform(decl&15) = 0 %start;           ! check meaningful
  1922                  %if decl>>4&7 = record %start
  1923                      this = fdef %if tag(fdef)_flags&spec # 0
  1924                      atom1 = error+21 %if fdef = this;  ! *context for format
  1925                  %finish
  1926                  atom1 = error+10 %if fdef = 0;         ! *size
  1927              %finish
  1928              %return
  1929  
  1930  atop:       access = 0;  ->top
  1931              ! declarators
  1932  c(88):      ;                                          ! rtype
  1933  c(28):      decl = x&(\7);                             ! stype
  1934              fdef = x&7;                                ! precision
  1935              fdef = reals ln %if x&2_1110001 = real<<4+1; ! convert to long
  1936              decs = 1;  ->top
  1937  c(34):      ;                                          ! own
  1938  c(35):      otype = x;  ord = 1;  ->top;               ! external
  1939  c(152):     decl = decl+x<<1;  ->top;                  ! xname
  1940  c(31):      ;                                          ! proc
  1941  c(32):      spec mode = level+1;                       ! fn/map
  1942              decl = decl!prot %if x = 9;                ! function
  1943  c(29):      ord = 1;                                   ! array
  1944              dim = 0
  1945  c(30):      decl = decl+x;                             ! name
  1946              decs = 1
  1947              ->top
  1948  c(27):      lit = 0;                                   ! arrayd
  1949              %if pending # 0 %start
  1950                  pop lit
  1951                  %unless 0<lit %and lit<=dim limit %start
  1952                      atom1 = error + 11;  %return
  1953                  %finish
  1954              %finish
  1955              dim = lit
  1956              decl = decl + x;  decs = 1
  1957              -> top
  1958  c(37):      x = x!subname;                             ! record
  1959  c(36):      lit = 0;                                   ! string
  1960              %if pending # 0 %start
  1961                  pop lit
  1962                  %unless 0 < lit %and lit <= 255 %start; ! max length wrong
  1963                      atom1 = error+10;  %return
  1964                  %finish
  1965              %finish
  1966              fdef = lit;                                ! format or length
  1967  c(33):      decl = x;                                  ! switch
  1968              decs = 1
  1969              ->top
  1970  c(39):      decl = decl!spec;                          ! spec
  1971              ocount = -1;                               ! no initialisation
  1972              spec mode = -1
  1973              ->top
  1974  c(38):      decl = 64+4;                               ! recordformat (spec)
  1975              order = 1
  1976              atom1 = x
  1977              decl = decl!spec %if atom1 = 12;           ! formatspec
  1978              fdef = tmax+1;                             ! format tag
  1979              %return
  1980  c(175):     id = id+1;  tag(x)_index = id;  %return;   ! FSID
  1981  c(41):      decs = 1;  decl = x!spec!closed;  ->top;   ! label
  1982  c(133):     recid = 0;  rbase = tmin-1;                ! fname
  1983              this = x
  1984              fm base = fdef;  format list = tmin
  1985              def(this);                      ->top
  1986  c(148):     fdef = 0 %and ->top %if next = 0;          ! reclb
  1987              get next;                                  ! skip name
  1988              fdef = x
  1989              ->top
  1990  
  1991  c(127):     add char( '}' );             ->top;        ! %POUT
  1992  c(126):     add char( '{' );             ->top;        ! %PIN
  1993  c(174):     set bp;                                    ! rangerb
  1994  c(171):     ;                                          ! fmlb
  1995  c(172):     ;                                          ! fmrb
  1996  c(173):     add char( '~' )
  1997              add char( class-171+'A' );   ->top;        ! fmor
  1998  c(168):     rbase = -rbase;                            ! orrb
  1999              sstype = 0;  spec mode = 0
  2000  
  2001  c(147):     search base = 0;                           ! recrb
  2002              tag(this)_app = tmin
  2003              tag(this)_format = rbase
  2004              ->top
  2005  
  2006  c(45):      add char( 'U' ) %if x = 36;  ->top;        ! sign
  2007  c(46):      add char( '\' );             ->top;        ! uop
  2008  c(47):;                                                ! mod
  2009  c(48):;                                                ! dot
  2010  c(42):;                                                ! op1
  2011  c(43):;                                                ! op2
  2012  c(44):      add char( operator(x) );     ->top;        ! op3
  2013  c(56):      ;                                          ! and
  2014  c(57):      push(x);  ->top;                           ! or
  2015  c(58):      cnest(cp) = cnest(cp)!!2;  ->top;          ! not
  2016  c(138):     x = 128+32+16+4;                           ! csep: treat like %while
  2017  c(59):      ;                                          ! while
  2018  c(60):      %if class = 138 %then op('f', label-1) %else def lab(label-1); ! until
  2019  c(166):     ;                                          ! runtil
  2020  c(62):      lmode = (lmode&(else!loop)) !(x>>3);       ! cword
  2021              clab = label;  cp = 1;  cnest(1) = x&7
  2022              ->top
  2023  c(72):      pop label(0);                              ! repeat
  2024              def lab(label+1) %if lmode&32 # 0;  ->atop
  2025  c(69):      pop label(1);               ->top;         ! finish
  2026  c(163):     ;                                          ! xelse
  2027  c(70):      pop label(1);                              ! finish else ...
  2028              fault(7) %if lmode&3 = 3;                  ! dangling else
  2029  c(68):      lmode = (lmode&else)!3;                    ! ...else...
  2030              %if access # 0 %start
  2031                  op('F', label-1);  lmode = else!3
  2032              %finish
  2033              def lab(label)
  2034              ->top %if next # 0
  2035  c(120):     ;                                          ! %MSTART
  2036  c(67):      ;                                          ! start
  2037  c(71):      ;                                          ! cycle
  2038  stcy:       def lab(label-1) %and lmode = loop %if lmode = 0; ! cycle
  2039              dmin = dmin-1;  abandon(3) %if dmin <= dmax
  2040              dict(dmin) = lmode
  2041              label = label+3
  2042              %return
  2043  
  2044  c(64):      fault(13) %if dict(dmin) >= 0 %or inhibit # 0; ! on event
  2045              inhibit = 1
  2046              n = 0
  2047              n = 16_FFFF %if pending = 0;               ! * = all events
  2048              %while pending > 0 %cycle
  2049                  pop lit;  fault(10) %if lit&(\15) # 0; ! too big
  2050                  j = 1<<lit
  2051                  dubious = 1 %if n&j # 0
  2052                  n = n!j;                               ! construct bit mask
  2053              %repeat
  2054              op('o', n);  op(',', label)
  2055              lmode = then!1;  ->stcy
  2056  
  2057  c(104):     op('J', tag(x)_index);                     ! l
  2058              inhibit = 1;            ->atop
  2059  c(149):     stats = stats-1;                           ! lab
  2060              access = 1;  inhibit = 1
  2061              op('L', tag(x)_index);  ->top
  2062  
  2063  c(63):      j = dmin;  l = label-3;                    ! exit, continue
  2064              %cycle
  2065                  fault(7) %and ->top %if dict(j) < 0
  2066                  %exit %if dict(j)&1 = 0
  2067                  j = j+1;  l = l-3
  2068              %repeat
  2069              l = l+1 %if x = 32;                        ! continue
  2070              op('F', l)
  2071              dict(j) = dict(j)!x;                       ! show given
  2072              ->atop
  2073  
  2074  c(50):      add char( 'C' );          ->cop;           ! acomp
  2075  c(49):
  2076              %if next # 0 %start;                       ! comparator
  2077                  add char( '"' )
  2078                  push(0);                               ! double sided
  2079              %finish %else %start
  2080                  add char( '?' )
  2081              %finish
  2082  
  2083  cop:        x = x!!1 %if cnest(cp)&2 # 0;              ! invert the condition
  2084              j = cp;  l = clab
  2085              %while cnest(j)&4 = 0 %cycle
  2086                  j = j-1;  l = l-cnest(j)&1
  2087              %repeat
  2088              op(cc(x), l)
  2089              def lab(clab+1) %if cnest(cp)&1 # 0
  2090              cp = cp-1
  2091              clab = clab-cnest(cp)&1
  2092              ->top
  2093  
  2094  c(78):      ;                                          ! fresult
  2095  c(79):      ;                                          ! mresult
  2096  c(80):      open = 0;                                  ! return, true, false
  2097  c(82):      access = 0;                                ! stop
  2098  c(89):      ;                                          ! addop
  2099  c(81):      add char( x );              ->top;         ! monitor
  2100  c(65):      pop lit;  op('e', lit);     ->atop;        ! signal
  2101  c(51):      add char( 'S' );            ->top;         ! eq
  2102  c(53):      add char( 'j' );            ->top;         ! jam transfer
  2103  c(52):      add char( 'Z' );            ->top;         ! eqeq
  2104  c(74):      %if level = 0 %start;                      ! begin
  2105                  %if progmode <= 0 %then progmode = 1 %else fault(7)
  2106                  !{Permit BEGIN after external defs}
  2107              %finish
  2108              spec mode = level+1
  2109              block x = 0
  2110              add char( 'H' )
  2111              %return
  2112  c(77):      perm = 0;  lines = 0;  stats = 0;          ! endofperm
  2113              close input
  2114              select input(source)
  2115              list = list-1
  2116              tbase = tmax;  tstart = tmax
  2117              %return
  2118  c(76):      %if include # 0 %and x = 0 %start;         ! end of ...
  2119                  lines = include;  sstype =  0;         ! include
  2120                  close input
  2121                  list = include list
  2122                  include level = 0
  2123                  include = 0;  select input(source);  %return
  2124              %finish
  2125              ss = -1;                                   ! prog/file
  2126  c(75):      compile end(x);  %return;                  ! %end
  2127  
  2128  c(85):      %if x=0 %then control=lit %else %start;    ! control
  2129                  diag = lit&16_3FFF %if lit>>14&3 = 1
  2130              %finish
  2131              op('z'-x, lit)
  2132              ->top
  2133  c(83):      list = list+x-2;   ->top;                  ! %LIST/%endoflist
  2134  c(84):      reals ln = x;      ->top;                  ! %REALS long/normal
  2135  c(86):      %if include # 0 %start;                    ! include "file"
  2136                  fault(7);  %return
  2137              %finish
  2138              get next;                                  ! sconst
  2139              x = x-16_4000
  2140              j = glink(x)
  2141              k = j&255
  2142              !ABD - another little copy loop because SKIMP can't do the string map
  2143              include file = ""
  2144              %cycle
  2145                  k = k-1; %exit %if k < 0
  2146                  include file = include file.tostring(j>>8)
  2147                  x = x+1
  2148                  j = glink(x)
  2149                  k = k-1; %exit %if k < 0
  2150                  include file = include file.tostring(j&255)
  2151              %repeat
  2152              ! include file = string(x-16_4000+stbase)
  2153              ! remove this event block for SKIMP or pre-event IMP versions
  2154              %begin
  2155                  %on 9 %start;  Abandon(9);  %finish
  2156                  open input(3, include file)
  2157              %end
  2158              include = lines;  lines = 0
  2159              include list = list;  include level = level
  2160              select input(3)
  2161              ->top
  2162  
  2163  c(154):     dimension = dimension+1;                   ! dbsep
  2164              fault(11) %if dimension = dim limit+1
  2165              ->top
  2166  c(145):     set bp;                       ->top;       ! crb
  2167  c(146):     set bp;                                    ! rcrb
  2168  c(142):     ;                                          ! bplrb
  2169              dimension = 1 %if dimension = 0
  2170              op('d', dimension);  op(',', defs)
  2171              %if class # 146 %start
  2172                  set subs(defs)
  2173                  fault(13) %if dict(dmin) >= 0 %or inhibit # 0 %or level=0
  2174              %finish
  2175              dimension = 0;  defs = 0
  2176              ->top
  2177  c(128):     id = dupid;  ->top;                        ! EDUP
  2178  c(130):     block x = x
  2179              op('F', 0) %if decl&spec = 0 %and level # 0; ! jump round proc
  2180  c(125):     dupid = id;                                ! %DUP
  2181              %return %if Level < 0;                     ! {spec about}
  2182  c(90):      def(x);  ->top;                            ! ident
  2183  c(131):     ;                                          ! cident
  2184              %if tag(x)_flags&(2_1111111+const bit) = iform+const bit %start
  2185                  tag(x)_format = lit
  2186              %finish %else %start
  2187                  set const(lit) %if pending # 0
  2188                  def(x)
  2189                  op('A', 1)
  2190              %finish
  2191              cident = x
  2192              ->top
  2193  c(124):     dubious = 1 %if tag(cident)_flags&prot # 0; ! %DUBIOUS
  2194              ->top
  2195  c(97):      ;                                          ! f
  2196  c(98):      ;                                          ! m
  2197  c(99):      ;                                          ! p
  2198  c(96):      call;  ->top;                              ! r
  2199  c(165):     ;                                          ! nlab
  2200  c(100):     ;                                          ! rp
  2201  c(101):     ;                                          ! fp
  2202  c(102):     ;                                          ! mp
  2203  c(103):     ;                                          ! pp
  2204  c(91):      ;                                          ! v
  2205  c(92):      ;                                          ! n
  2206  c(106):     ;                                          ! a
  2207  c(107):     ;                                          ! an
  2208  c(108):     ;                                          ! na
  2209  c(109):     ;                                          ! nan
  2210              k = tag(x)_index
  2211              %if k < 0 %then op('n', -k) %else op('@', k)
  2212              ->top
  2213  c(121):     set const(0);                   ->top;     ! special for zero
  2214  c(167):     add char( 'G' );                ->pstr;    ! aconst (alias)
  2215  c(const):   ;                                          ! const
  2216              %if x < 0 %start;                          ! constinteger
  2217                  set const(tag(-x)_format);  ->top
  2218              %finish
  2219              %if x&16_4000 # 0 %start;                  ! strings
  2220                  add char( '''' )
  2221  pstr:           x = x-16_4000
  2222                  j = glink(x)
  2223                  k = j&255
  2224                  add char( k )
  2225                  %cycle
  2226                      k = k-1; ->top %if k < 0
  2227                      add char( j>>8 );
  2228                      x = x+1
  2229                      j = glink(x)
  2230                      k = k-1; ->top %if k < 0
  2231                      add char( j&255 )
  2232                  %repeat
  2233              %finish
  2234              %if x&16_2000 # 0 %start;                  ! real - ABD also string-like, but NOT packed
  2235                  x = x-16_2000
  2236                  k = glink(x)
  2237                  op('D', k);  add char( ',' )
  2238                  %cycle
  2239                      ->top %if k = 0
  2240                      k = k-1
  2241                      x = x+1;  j = glink(x)
  2242                      %if j = '@' %start
  2243                          op('@', litpool(glink(x+1)));  ->top
  2244                      %finish
  2245                      add char( j )
  2246                  %repeat
  2247              %finish
  2248              set const(lit pool(x))
  2249              ->top
  2250  
  2251  c(137):     add char( 'i' );                ->top;     ! asep
  2252  c(141):     add char( 'a' );                ->top;     ! arb
  2253  
  2254              !own arrays
  2255  c(132):     ocount = ub-lb+1
  2256              def(x);                                    ! oident
  2257              dimension = 1;  set subs(1)
  2258              %if next = 0 %start;                       ! no initialisation
  2259                  op('A', ocount) %if ocount > 0
  2260                  ocount = -1
  2261              %finish %else %start;                      ! initialisation given
  2262                  get next
  2263              %finish
  2264              ->top
  2265  c(162):     lit = ocount;  ->ins;                      ! indef
  2266  c(143):     pop lit;                                   ! orb
  2267  ins:        fault(10) %and lit = 0 %if lit < 0
  2268              get next
  2269              ->inst
  2270  c(139):     ;                                          ! osep (x=19)
  2271  c(153):     lit = 1
  2272  inst:       pop def %if pending # 0;                   ! ownt (x=0)
  2273              op('A', lit)
  2274              ocount = ocount-lit
  2275              %if ocount >= 0 %start
  2276                  ->top %if x # 0;                       ! more coming
  2277                  ocount = -1 %and %return %if ocount = 0; ! all done
  2278              %finish
  2279              fault(11);  %return
  2280  
  2281  c(swit):    op('W', tag(x)_index);  inhibit = 1;  ->atop
  2282  c(134):     def(x);                                    ! swid
  2283              n = ub-lb+1
  2284              n = (n+15)>>4;                             ! slots needed (includes zero)
  2285              j = dmax;  dmax = dmax+n+2
  2286              abandon(1) %if dmax >= dmin
  2287              tag(x)_format = j
  2288              dict(j) = lb;  dict(j+1) = ub
  2289              %cycle
  2290                  n = n-1
  2291                  ->top %if n < 0
  2292                  j = j+1;  dict(j+1) = 0
  2293              %repeat
  2294  c(151):     stats = stats-1;                           ! slab
  2295              fault(7) %and %return %if x < tbase
  2296              %if pending # 0 %start;                    ! explicit label
  2297                  def s lab(pstack(1))
  2298              %finish %else %start
  2299                  fault(4) %and %return %if tag(x)_app # 0
  2300                  tag(x)_app = 1
  2301                  n = tag(x)_format
  2302                  %for j = dict(n), 1, dict(n+1) %cycle
  2303                      def s lab(j)
  2304                      flush buffer( 128 );               ! flush if bp >= 128
  2305                  %repeat
  2306              %finish
  2307              inhibit = 1
  2308              %return
  2309  
  2310  c(140):     add char( 'p' );         ->top;            ! psep
  2311  c(144):     ;                                          ! prb
  2312              add char( 'p' );
  2313              add char( 'E' );         ->top
  2314  
  2315              !constant expressions
  2316  c(155):     ;                                          ! pconst
  2317              %if x < 0 %then lit = tag(-x)_format %else lit = lit pool(x)
  2318              pending = pending+1;     pstack(pending) = lit;  ->top
  2319  c(156):     lit = pstack(pending);  lit = -lit %if lit < 0
  2320              pstack(pending) = lit;  ->top;  !cmod
  2321  c(157):     lit = -pstack(pending);  pstack(pending) = lit;  ->top; ! csign
  2322  c(158):     lit = \pstack(pending);  pstack(pending) = lit;  ->top; ! cuop
  2323  c(159):     ;                                          ! cop1
  2324  c(160):     ;                                          ! cop2
  2325  c(161):     pending = pending-1;                       ! cop3
  2326              lit2 = pstack(pending+1);  lit = pstack(pending)
  2327              ->litop(x>>2)
  2328  
  2329  litop(1):   lit = lit<<lit2;           ->setl
  2330  litop(2):   lit = lit>>lit2;           ->setl
  2331  litop(3):   n = 1;                                     ! lit = lit\\lit2
  2332              fault(10) %if lit2 < 0
  2333              %while lit2 > 0 %cycle
  2334                  lit2 = lit2-1
  2335                  n = n*lit
  2336              %repeat
  2337              lit = n;                   ->setl
  2338  litop(4):   %if lit2 = 0 %then fault(10) %else lit = lit//lit2
  2339                                         ->setl
  2340  litop(5):   lit = lit&lit2;            ->setl
  2341  litop(6):   lit = lit!lit2;            ->setl
  2342  litop(7):   lit = lit!!lit2;           ->setl
  2343  litop(8):   lit = lit+lit2;            ->setl
  2344  litop(9):   lit = lit-lit2;            ->setl
  2345  litop(10):  lit = lit*lit2;            ->setl
  2346  litop(11):  lit = lit+lit2;            ->setl
  2347  litop(12):  n = 1;                                     ! lit = lit\\lit2
  2348              fault(10) %if lit2 < 0
  2349              %while lit2 > 0 %cycle
  2350                  lit2 = lit2-1
  2351                  n = n*lit
  2352              %repeat
  2353              lit = n;                   ->setl
  2354  setl:       pstack(pending) = lit;     ->top
  2355  
  2356  c(170):     ;
  2357              !Fault(4) %if IMPCOM_Option # ""
  2358              !IMPCOM_Option = String(x-x'4000'+Stbase); ! Option string
  2359              ->Top
  2360  
  2361              !string resolution
  2362  c(135):     resln = 2;                    ->top;       ! dotl
  2363  c(136):     resln = resln+1;              ->top;       ! dotr
  2364  c(55):      op('r', resln);    resln = 0; ->top;       ! resop
  2365  c(164):     op('r', resln+4);  resln = 0;              ! cresop
  2366  c(122):     x = 6;                        ->cop;       ! %PRED
  2367  c(87):      set const(pstack(1));                      ! mass
  2368              bp=bp+1 %and buff(bp)='P';    ->top
  2369          %end
  2370  
  2371      %end;                                              ! of compile block
  2372  
  2373      %on 9 %start
  2374          abandon(5)
  2375      %finish
  2376  
  2377      selectinput(2);  selectoutput(listing)
  2378      tag(max tag) = 0;                                  ! %begin defn
  2379      tag(0) = 0;  tag(0)_flags = 7;                     ! %begin tag!
  2380      Hash(x) = 0 %for x = 0, 1, max names
  2381      printstring("         Edinburgh IMP77 Compiler - Version ")
  2382  !    printstring("         Preston IMP2020 Compiler - Version ")
  2383      printstring(version);  newlines(2)
  2384      op('l', 0)
  2385      compile block(0, 0, max dict, 0, 0)
  2386      add char( nl );                                    ! {for bouncing off}
  2387      flush buffer( 0 );                                 ! flush if bp >= 0
  2388  
  2389      x = listing
  2390      newline
  2391      %cycle
  2392          %if faulty = 0 %start
  2393              write(stats, 5)
  2394              printstring(" Statements compiled")
  2395          %else
  2396              printstring(" Program contains ")
  2397              write(faulty, 1)
  2398              printstring(" fault")
  2399              printsymbol('s') %unless faulty = 1
  2400          %finish
  2401          newline
  2402          %exit %if x = report
  2403          x = report
  2404          selectoutput(report)
  2405      %repeat
  2406  
  2407      %if faulty # 0 %then %stop;        ! try to flag to shell that we failed
  2408  
  2409  %endofprogram

  2406 Statements compiled
