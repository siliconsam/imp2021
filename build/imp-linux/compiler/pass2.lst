         Edinburgh IMP77 Compiler - Version 8.4

   1  !   Intel 80386 IMP77 compiler second pass
   2  
   3  ! Copyright 2021 JD McMullin for various enhancements
   4  ! Copyright 2002 NB Information Limited.
   5  !        from an original version probably -
   6  ! Copyright The University of Edinburgh
   7  !        and various contributions 
   8  ! Copyright many other individuals,
   9  !        but most particularly
   10  ! Copyright 1977-1980 Peter Robertson
   11  
   12  ! Version 2.00 - February 2021
   13  !   * Enabled machine code to be embedded (NO floating point implemented)
   14  !
   15  ! Version 1.03 - October 2003
   16  !	* Properly cleaned up GP TAG list at end of a block
   17  !	* Tidied up some constant tables with names (a hangover from the SKIMP version)
   18  !	* Corrected ISWORK to only be true for full-size string work blocks
   19  
   20  %begin
   21  
   22      !SIZE CONSTANTS
   23      %constinteger  max vars  = 1024
   24      %constinteger  max stack = 16
   25      %constinteger  max labs  = 50
   26      %constinteger  max level = 16
   27      %constinteger  Max GP    = 120
   28  
   29      ! SOME WEE ENVIRONMENTAL THINGS
   30      ! Main program internal name
   31      %conststring(12) program ip = "Main Program"
   32  
   33      ! Main program external name
   34      %conststring(8)  program ep = "__impmain"
   35  
   36      ! prefixed to %system routine idents
   37      %conststring(5)  system prefix = "_imp_"
   38  
   39      ! I/O file handles
   40      ! input streams
   41      %constinteger icode   = 1
   42      %constinteger source  = 2
   43      ! output streams
   44      %constinteger report  = 0
   45      %constinteger objout  = 1
   46      %constinteger listout = 2
   47  
   48      ! DIAGNOSE BITS
   49      ! JDM Identify which IMP pass this is
   50      %constinteger  passId = 2
   51  
   52      ! CONTROL BITS
   53      ! The only active check is check array
   54      %constinteger  check capacity = 1
   55      %constinteger  check unass    = 2
   56      %constinteger  check array    = 4
   57      %constinteger  check bits     = check array
   58  
   59      ! REGISTERS - basic register number = actual value + 1
   60      %constinteger  AX = 1
   61      %constinteger  CX = 2
   62      %constinteger  DX = 3
   63      %constinteger  BX = 4
   64      %constinteger  SP = 5
   65      %constinteger  BP = 6
   66      %constinteger  SI = 7
   67      %constinteger  DI = 8
   68  
   69      ! Floating point coprocessor stack registers
   70      %constinteger  FR0	= 9
   71      !%constinteger  FR1	= 10
   72      !%constinteger  FR2	= 11
   73      !%constinteger  FR3	= 12
   74      !%constinteger  FR4	= 13
   75      !%constinteger  FR5	= 14
   76      !%constinteger  FR6	= 15
   77      %constinteger  FR7	= 16
   78  
   79      ! 8 bit registers - actual value + 17
   80      %constinteger	AL	= 17
   81      %constinteger	CL	= 18
   82      %constinteger	DL	= 19
   83      %constinteger	BL	= 20
   84      %constinteger	AH	= 21
   85      %constinteger	CH	= 22
   86      %constinteger	DH	= 23
   87      %constinteger	BH	= 24
   88  
   89      ! Pseudo Registers
   90      %constinteger  any   = 25 { Truly any register }
   91      %constinteger  anyg  = 26 { A "General Purpose" byte accessible register }
   92                                { (AX, BX, CX, DX) }
   93      %constinteger  anyp  = 27 { A pointing register (BX, SI, DI) }
   94      %constinteger  anyf  = 28 { Generally means the top of the 8087 stack }
   95  
   96      ! DATA FORMS
   97  
   98      ! EXTERNAL FORM
   99      %constinteger  simple         = 1
  100      %constinteger  name           = 2
  101      %constinteger  label          = 3
  102      %constinteger  recordformat   = 4
  103      %constinteger  switch         = 6
  104      %constinteger  array          = 11
  105      %constinteger  arrayname      = 12
  106      %constinteger  namearray      = 13
  107      %constinteger  namearrayname  = 14
  108  
  109      ! INTERNAL
  110      %constinteger  constant    = 0
  111      %constinteger  v in r      = 1
  112      %constinteger  av in r     = 2
  113      %constinteger  a in r      = 3
  114      %constinteger  v in s      = 4
  115      %constinteger  av in s     = 5
  116      %constinteger  a in s      = 6
  117      %constinteger  v in rec    = 7
  118      %constinteger  av in rec   = 8
  119      %constinteger  a in rec    = 9
  120      %constinteger  pgm label   = 10
  121  
  122      ! DATA TYPES
  123      %constinteger  general  = 0
  124      %constinteger  integer  = 1
  125      %constinteger  real     = 2
  126      %constinteger  string   = 3
  127      %constinteger  record   = 4
  128      ! Private internal derived types
  129      %constinteger  byte     = 5
  130      %constinteger  short    = 6
  131      %constinteger  long     = 7
  132      %constinteger  lreal    = 8
  133      ! JDM JDM additional datatypes added for use by typeof/sizeof functions
  134      ! They correspond to some of the external forms
  135      %constinteger  tarray   = 9
  136      %constinteger  tlabel   = 10
  137      %constinteger  xarray          = 11
  138      %constinteger  xarrayname      = 12
  139      %constinteger  xnamearray      = 13
  140      %constinteger  xnamearrayname  = 14
  141  
  142      ! JDM JDM vsize and gen map arrays extended to cope with extra
  143      ! type parameters passed to typeof/sizeof internal macro/functions
  144      !   typeof mapped values
  145      !   (originally taken from "The Imp77 Language - A Reference Manual)
  146      !   more mapped values could be added as needed
  147      !
  148      ! code v  name (returned by typeName)
  149      !    0 = "unknown"
  150      !    1 = "integer"
  151      !    2 = "real"
  152      !    3 = "string"
  153      !    4 = "record"
  154      !    5 = "byteinteger"
  155      !    6 = "shortinteger"
  156      !    7 = "longinteger"
  157      !    8 = "longreal"
  158      !    9 = "array"
  159      !   10 = "label"
  160      !
  161      ! JDM JDM extended list of returned values for typeof
  162      ! N.B. The value 9 ("array") has been split into 17..26
  163      ! This depend on the underlying simple type of the array
  164      ! code = name (returned by typeName library function)
  165      !   16 = "name"
  166      !   17 = "integer array"
  167      !   18 = "real array"
  168      !   19 = "string array"
  169      !   20 = "record array"
  170      !   21 = "byte array"
  171      !   22 = "shortinteger array"
  172      !   23 = "longinteger array"
  173      !   24 = "longreal array"
  174      !   25 = "array array"
  175      !   26 = "label array"
  176      !   *  = "unknown"
  177  
  178      ! size of each of those internal types in bytes
  179      %constbyteintegerarray  vsize(general:xnamearrayname) =
  180+         0,4,4,0,0,1,2,4,8,0,0,0,0,0,0
  181  
  182      ! Define type codes known externally (to pass 3 and user):
  183      ! The extended list of type codes are NOT specified here
  184      %constbyteintegerarray  gen map(general:xnamearrayname) =
  185+         0,1,2,3,4,5,6,7,8,9,10,9,9,9,9
  186  
  187      ! GENERIC STORE ALIGNMENT - ASSUME 80386
  188      %constinteger  align     = 3
  189      %constinteger  word size = 4 { in bytes }
  190  
  191      !OWN INFO
  192      %constinteger  own      = 1
  193      %constinteger  con      = 2
  194      %constinteger  external = 3
  195      %constinteger  system   = 4
  196      %constinteger  dynamic  = 5
  197      %constinteger  primrt   = 6
  198      %constinteger  permrt   = 7
  199  
  200  {Procedure end codes}
  201  
  202  	%constinteger	Map     = -2,
  203+ 					Fn      = -1, { negative value implies stacked result }
  204+ 					Routine =  0,
  205+ 					True    =  1,
  206+ 					False   =  2
  207  
  208      ! PERM ROUTINE INDEXES
  209      %constinteger  iexp   =  1 { Integer Exponent                    }
  210      %constinteger  fexp   =  2 { floating exponent                   }
  211      %constinteger  smove  =  3 { string copy (length checked)        }
  212      %constinteger  sjam   =  4 { string copy (whatever fits)         }
  213      %constinteger  sconc  =  5 { string concatenate (length checked) }
  214      %constinteger  sjconc =  6 { concatenate whatever fits           }
  215      %constinteger  sresln =  7 { string resolution                   }
  216      %constinteger  scomp  =  8 { string compare                      }
  217      %constinteger  aref   =  9 { array access                        }
  218      %constinteger  adef   = 10 { array definition                    }
  219      %constinteger  signal = 11 { %signal                             }
  220      %constinteger  stop   = 12 { %stop                               }
  221      %constinteger  lastperm = stop
  222  
  223      ! and the corresponding linkage names for the perms
  224      %const %string(12)%array permname(1:lastperm)=
  225+     "_IMPIEXP",
  226+     "_IMPFEXP",
  227+     "_IMPSTRCPY",
  228+     "_IMPSTRJAM",
  229+     "_IMPSTRCAT",
  230+     "_IMPSTRJCAT",
  231+     "_IMPSTRRES",
  232+     "_IMPSTRCMP",
  233+     "_IMPAREF",
  234+     "_IMPADEF",
  235+     "_IMPSIGNAL",
  236+     "_IMPSTOP"
  237  
  238      ! Compiler Internal Operations (not to be confused with OpCodes)
  239      %constinteger  ADDx    = 1
  240      %constinteger  SUBx    = 2
  241      %constinteger  MULx    = 3
  242      %constinteger  DIVx    = 4
  243      %constinteger  CONCx   = 5
  244      %constinteger  ANDx    = 6
  245      %constinteger  ORx     = 7
  246      %constinteger  XORx    = 8
  247      %constinteger  LSHx    = 9
  248      %constinteger  RSHx    = 10
  249      %constinteger  REMx    = 11
  250      %constinteger  EXPx    = 12
  251      %constinteger  REXPx   = 13
  252      %constinteger  RDIVx   = 14
  253      %constinteger  NOTx    = 15
  254      %constinteger  NEGx    = 16
  255      %constinteger  ABSx    = 17
  256      %constinteger  unaries = 15
  257  
  258      ! opcode indexes...
  259  
  260      ! simple (no operand) ones first
  261      %constinteger NOP	= 0
  262      %constinteger CWD   = 1
  263      %constinteger RET   = 2
  264      %constinteger SAHF  = 3
  265      %constinteger LEAVE = 4
  266  
  267      ! simple unary math functions
  268      %constinteger DEC = 5
  269      %constinteger INC = 6
  270      %constinteger NEG = 7
  271      %constinteger NOT = 8
  272  
  273      ! simple unary moves
  274      %constinteger POP  = 9
  275      %constinteger PUSH = 10
  276  
  277      ! two operand moves
  278      %constinteger LEA  = 11
  279      %constinteger MOV  = 12
  280      %constinteger XCHG = 13
  281  
  282      ! simple two operand math functions
  283      %constinteger ADC = 14
  284      %constinteger ADD = 15
  285      %constinteger AND = 16
  286      %constinteger CMP = 17
  287      %constinteger OR  = 18
  288      %constinteger SUB = 19
  289      %constinteger XOR = 20
  290      ! slightly more complicated two operand math
  291      %constinteger SHL  = 21
  292      %constinteger SHR  = 22
  293      %constinteger IDIV = 23
  294      %constinteger IMUL = 24
  295  
  296      ! calls and jumps
  297      %constinteger CALL = 25
  298      %constinteger JE   = 26
  299      %constinteger JNE  = 27
  300      %constinteger JG   = 28
  301      %constinteger JGE  = 29
  302      %constinteger JL   = 30
  303      %constinteger JLE  = 31
  304      %constinteger JA   = 32
  305      %constinteger JAE  = 33
  306      %constinteger JB   = 34
  307      %constinteger JBE  = 35
  308      %constinteger JMP  = 36
  309  
  310      ! Floating point instructions - note that these map directly onto
  311      ! 8087 sequences, unlike the generic MOV, ADD style of the base
  312      ! operations for the 8086
  313      %constinteger	FILD	= 37
  314      %constinteger	FLDD	= 38
  315      %constinteger	FLDQ	= 39
  316      %constinteger	FSTI	= 40
  317      %constinteger	FSTD	= 41
  318      %constinteger	FSTQ	= 42
  319      %constinteger	FADD	= 43
  320      %constinteger	FSUB	= 44
  321      %constinteger	FSUBR	= 45
  322      %constinteger	FMUL	= 46
  323      %constinteger	FDIV	= 47
  324      %constinteger	FDIVR	= 48
  325      %constinteger	FCMP	= 49
  326      %constinteger	FCHS	= 50
  327      %constinteger	FABS	= 51
  328      ! Special floating point things
  329      %constinteger	FSTSW	= 52
  330      %constinteger	FLDZ	= 53
  331      %constinteger	FLDPI	= 54
  332  
  333      ! modifiers to memory base for accessing global memory
  334      %constinteger	DATA	= 16_10
  335      %constinteger	COT		= 16_20
  336      %constinteger	BSS		= 16_30
  337      %constinteger	DISPLAY	= 16_40
  338      %constinteger	EXT		= 16_50
  339      %constinteger	SWT		= 16_60
  340      %constinteger	CODE	= 16_70
  341  
  342      ! opcodes
  343      %const %string(5) %array opname(NOP:JMP) =
  344+ 	"NOP", "CWD", "RET", "SAHF", "LEAVE",
  345+ 	"DEC", "INC", "NEG", "NOT",
  346+ 	"POP", "PUSH",
  347+ 	"LEA", "MOV", "XCHG",
  348+ 	"ADC", "ADD", "AND", "CMP", "OR", "SUB", "XOR",
  349+ 	"SHL", "SHR", "IDIV", "IMUL",
  350+ 	"CALL", "JE", "JNE",
  351+     "JG", "JGE", "JL", "JLE",
  352+     "JA", "JAE", "JB", "JBE", "JMP"
  353  
  354      %const %byte %integer %array opvalue(NOP:JMP) =
  355+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9,
  356+ 	16_FF, 16_FF, 16_F7, 16_F7,
  357+ 	16_8F, 16_FF,
  358+ 	16_8B, 16_89, 16_87,		{ LEA is fudged as if it were m <- r, to allow the flip }
  359+ 	16_11, 16_01, 16_21, 16_39, 16_09, 16_29, 16_31,
  360+ 	16_D1, 16_D1, 16_F7, 16_F7,
  361+ 	16_E8, 16_74, 16_75,
  362+     16_7F, 16_7D, 16_7C, 16_7E,
  363+     16_77, 16_73, 16_72, 16_76, 16_EB
  364  
  365      ! 8 bit equivalent opcodes
  366      ! Some are not actually 8 bit, but are added for completenes }
  367      %const %byte %integer %array op8value(NOP:JMP) =
  368+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9, { included for completeness }
  369+ 	16_FE, 16_FE, 16_F6, 16_F6,
  370+ 	16_8F, 16_FF,                      { included for completeness }
  371+ 	16_8B, 16_88, 16_86,                    { LEA is not applicable for 8 bit }
  372+ 	16_10, 16_00, 16_20, 16_38, 16_08, 16_28, 16_30,
  373+ 	16_D0, 16_D0, 16_F6, 16_F6,
  374+ 	16_E8, 16_74, 16_75,
  375+     16_7F, 16_7D, 16_7C, 16_7E,
  376+     16_77, 16_73, 16_72, 16_76, 16_EB  { included for completeness }
  377  
  378  	{Condition codes}
  379  
  380  	{ The "Never" test should never! be used. The others are all used } 
  381  	%constinteger	Never  = 0,
  382+                     EQ     = 1,
  383+                     LT     = 2,
  384+                     LE     = 3,
  385+                     GT     = 4,
  386+                     GE     = 5,
  387+ 					NE     = 6,
  388+                     Always = 7,
  389+                     TT     = 8,
  390+                     FF     = 9
  391  	%constbytearray Reverse(Never:FF) =	Never  {Never},
  392+ 										EQ     {EQ},
  393+ 										GT     {LT},
  394+ 										GE     {LE},
  395+ 										LT     {GT},
  396+ 										LE     {GE},
  397+ 										NE     {NE},
  398+ 										Always {Always},
  399+ 										TT     {TT},
  400+ 										FF     {FF}
  401  	%constbytearray Negated(Never:FF) =	Always {Never},
  402+ 										NE     {EQ},
  403+ 										GE     {LT},
  404+ 										GT     {LE},
  405+ 										LE     {GT},
  406+ 										LT     {GE},
  407+ 										EQ     {NE},
  408+ 										Never  {Always},
  409+ 										FF     {TT},
  410+ 										TT     {FF}
  411  
  412      {Never - This is added for completeness}
  413      %constbytearray TestToOp(Never:FF) =	JMP {Never},
  414+ 											JE  {EQ},
  415+ 											JL  {LT},
  416+ 											JLE {LE},
  417+ 											JG  {GT},
  418+ 											JGE {GE},
  419+ 											JNE {NE},
  420+ 											JMP {Always},
  421+ 											JNE {TT},
  422+ 											JE  {FF}
  423  
  424      {Never - This is added for completeness}
  425      %constbytearray TestToUnsignedOp(Never:FF) =	JMP {Never},
  426+ 													JE  {EQ},
  427+ 													JB  {LT},
  428+ 													JBE {LE},
  429+ 													JA  {GT},
  430+ 													JAE {GE},
  431+ 													JNE {NE},
  432+ 													JMP {Always},
  433+ 													JNE {TT},
  434+ 													JE  {FF}
  435  
  436      ! JDM JDM debug count of iCode instructions
  437      %integer icodeCount = 0
  438      %integer iCodeInst
  439      %integer ShowICode = 0
  440  
  441      ! Standard IMPish data structures
  442  
  443      ! Variables are declared here
  444      ! JDM JDM added idname to remember the IMP variable names
  445      %recordformat  varfm( %string(255) idname,
  446+                           %byteinteger type, form, level, scope, dim,
  447+                           %integer disp, extdisp, 
  448+                                    format, size, pbase, extra )
  449      %record(varfm)%array  var(0:max vars)
  450      %record(varfm)%name   decvar
  451      %record(varfm)        begin
  452  
  453      ! The compiler is stack based
  454      ! JDM JDM changed record format to reference the IMP variable name
  455      ! via var(var no)_idname
  456      ! This saves some memory by not adding 256 bytes per stack entry
  457      %recordformat  stackfm( %byteinteger type, form, aform, base, scope, dim,
  458+                             %integer var no,
  459+                             %integer disp, extdisp,
  460+                                      format, size, pbase, extra )
  461      %record(stackfm)%array  stack(1:max stack)
  462      %record(stackfm)        null
  463      %record(stackfm)%name   top
  464  
  465      ! Pass 1 uses a lame label redefinition that forces us to map
  466      ! label ID's into unique labels for pass 3, using this database
  467      %recordformat LabelFm(%integer id, tag)
  468      %record(LabelFm)%array Labels(1:Max Labs)
  469  
  470      ! most recent Jump tag translation
  471      ! - needed when planting event blocks
  472      %integer J Tag
  473  
  474      ! Status of registers
  475      %ownintegerarray  activity(0:fr7) = 0, 0, 0, 0, 0, -1, -1, 0, 0,
  476+                                         0, 0, 0, 0, 0, 0, 0, 0
  477      %owninteger  claimed = 0
  478  
  479      ! Pointer registers may be pointing to non-local display
  480      ! - we remember them for future use
  481      %ownintegerarray displayhint(AX:DI) = 0, 0, 0, 0, 0, 0, 0, 0
  482  
  483      ! Math Co-processor uses a stack
  484      ! - we remember where it should be with this pointer
  485      %owninteger fpustack = 0
  486  
  487      ! A general purpose workspace resource
  488      %recordformat gp tag(%integer info, addr, flags, link)
  489      %record(gptag)%array gptags(0:Max GP)
  490      %integer gp asl;
  491  
  492      ! Current compiler flags (set by %control statement)
  493      %owninteger control = check bits
  494  
  495      ! Current diagnostic flags (set by %diagnose statement)
  496      %owninteger diagnose = 0
  497  
  498     ! Special directive flags for languages (other than standard imp)
  499  	%owninteger Language Flags = 0
  500  
  501      ! notional code address (not real - pass3 shuffles stuff)
  502      %owninteger nextcad = 0
  503  
  504      ! current contextual level
  505      %owninteger level = 0
  506  
  507      ! Code symbol, next symbol
  508      %integer    sym, Pending
  509  
  510      ! vector lower/upper bound
  511      %integer    vlb,vub
  512  
  513      ! source line number
  514      %owninteger current line = 0
  515  
  516      ! stack pointer
  517      %owninteger stp = 0
  518  
  519      ! current data item size
  520      %integer    data size
  521  
  522      ! local stack frame extent
  523      %owninteger frame = 0
  524  
  525      ! start of parameter stack
  526      %integer    parms
  527  
  528      ! condition inversion flag
  529      %owninteger invert = 0
  530  
  531      ! condition was non-standard (generally FPU compare)
  532      %owninteger compare unsign = 0
  533  
  534      ! address of code hole
  535      %owninteger uncond jump = 0
  536  
  537      ! -1 = RECORDS, 1 = PROCEDURE, 2 = SPEC
  538      %owninteger block type = 1
  539  
  540      ! if # 0, indicates we are inside a parameter list
  541      %owninteger in params = 0
  542  
  543      ! Information about OWNs currently being declared
  544      %integer    otype,
  545+                 owntype,
  546+                 ownform
  547  
  548      ! More about current declaration
  549      %integer    spec,
  550+                 potype
  551  
  552      ! used in the initialisation loops only
  553      %integer    i, j
  554  
  555      ! Place to store Real and LReal function results
  556      %owninteger Fp Result Loc = -1
  557  
  558      ! Size in WORDS of switch segment table
  559      %constinteger max switch = 1000
  560      %integerarray swtab(0:max switch)
  561      ! pointer to next switch segment entry
  562      %owninteger swtp = 0
  563  
  564      %ownstring(255)  external id = "",
  565+ 	                 alias = "",
  566+ 					 block name = ""
  567  
  568      ! current string literal
  569      %byteintegerarray  current string(0:255)
  570  
  571      ! current external string name
  572      %byteintegerarray x sym buff(0:255)
  573      %integer  xlen
  574  
  575      ! WORK List - used to optimise use of temporary storage
  576      ! There is a head of list for each contextual level
  577      %ownintegerarray worklist(1:max level) = 
  578+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  579  
  580      ! floating point value for constants and initialisers
  581      %longreal rvalue
  582  
  583      ! value to use when initialising OWNs
  584      %owninteger ownval = 0
  585  
  586      !-----------------------------------------------------------
  587      ! start of "enumeration to String/name functions
  588      ! The following are debug functions to convert "enumerated" values
  589      ! to an appropriate String/name
  590      !-----------------------------------------------------------
  591  
  592      %string(255) %fn get own String( %integer flags )
  593          %string(255) s
  594          %label esac
  595          %switch sw(0:15)
  596  
  597          -> sw(flags&7)
  598          sw( 0): s = "auto";      -> esac
  599          sw( 1): s = "own";       -> esac
  600          sw( 2): s = "constant";  -> esac
  601          sw( 3): s = "external";  -> esac
  602          sw( 4): s = "system";    -> esac
  603          sw( 5): s = "dynamic";   -> esac
  604          sw( 6): s = "primitive"; -> esac
  605          sw( 7): s = "permanent"; -> esac
  606          esac:
  607  
  608          %result = s
  609      %end
  610  
  611      %string(255) %fn get flags string( %integer flags )
  612          %string(255) s
  613  
  614          s = ""
  615  
  616          %if (Flags&1 # 0) %start
  617              %if (length(s) > 0) %then s = s . ","
  618              s = s . "spec"
  619          %finish
  620          %if (Flags &2 # 0) %start
  621              %if (length(s) > 0) %then s = s . ","
  622              s = s . "indirect"
  623          %finish
  624          %if (Flags&4 # 0) %start
  625              %if (length(s) > 0) %then s = s . ","
  626              s = s . "check"
  627          %finish
  628          %if (Flags &8 # 0) %start
  629              %if (length(s) > 0) %then s = s . ","
  630              s = s . "b6flag"
  631          %finish
  632          %if (Flags&16 # 0) %start
  633              %if (length(s) > 0) %then s = s . ","
  634              s = s . "b7flag"
  635          %finish
  636  
  637          %result = s
  638      %end
  639  
  640      %string(255) %fn get type def( %integer type,size )
  641          %string(255) s,so
  642          %label esac
  643          %switch sw(0:15)
  644  
  645          so = itos(size,0)
  646          s = ""
  647          -> sw(type&15)
  648          sw(0):
  649              s = "void"
  650              -> esac
  651          sw(1):
  652              %if (size = 1) %start
  653                  s = "integer"
  654              %finish %else %if (size = 2) %start
  655                  s = "byte"
  656              %finish %else %if (size = 3) %start
  657                  s = "short"
  658              %finish %else %if (size = 4) %start
  659                  s = "long"
  660              %finish %else %if (size = 5) %start
  661                  s = "quad"
  662              %finish %else %start
  663                  s = "unknown size for type 1=" . so
  664              %finish
  665              -> esac
  666          sw(2):
  667              %if (size = 1) %start
  668                  s = "real"
  669              %finish %else %if (size = 4) %start
  670                  s = "longreal"
  671              %finish %else %start
  672                  s = "unknown size for type 2=" . so
  673              %finish
  674              -> esac
  675          sw(3):
  676              %if (size = 0) %start
  677                  s = "string(*)"
  678              %finish %else %start
  679                  s = "string(".so.")"
  680              %finish
  681              -> esac
  682          sw(4):
  683              %if (size = 0) %start
  684                  s = "record(*)"
  685              %finish %else %start
  686                  s = "record(""".var(size)_idname.""")"
  687              %finish
  688              -> esac
  689          sw(5):
  690              s = "boolean"
  691              -> esac
  692          sw(6):
  693              s = "set"
  694              -> esac
  695          sw(7):
  696              s = "enum8(""".var(size)_idname.""")"
  697              -> esac
  698          sw(8):
  699              s = "enum16(""".var(size)_idname.""")"
  700              -> esac
  701          sw(9):
  702              s = "pointer"
  703              -> esac
  704          sw(10):
  705              s = "char"
  706              -> esac
  707          sw(11):
  708              %if (size = 1) %start
  709                  s = "unsigned"
  710              %finish %else %if (size = 2) %start
  711                  s = "ubyte"
  712              %finish %else %if (size = 3) %start
  713                  s = "ushort"
  714              %finish %else %if (size = 4) %start
  715                  s = "ulong"
  716              %finish %else %if (size = 5) %start
  717                  s = "uquad"
  718              %finish %else %start
  719                  s = "unknown size for type 11=" . so
  720              %finish
  721              -> esac
  722          sw(*):
  723              s = "unknown type " . so
  724              -> esac
  725          esac:
  726  
  727          %result = s
  728      %end
  729  
  730      %string(255) %fn get typeof String( %integer type )
  731          %string(255) s
  732          %label esac
  733          %switch sw(0:15)
  734  
  735          -> sw(type&15)
  736          sw( 0): s = "void";          -> esac
  737          sw( 1): s = "integer";       -> esac
  738          sw( 2): s = "real";          -> esac
  739          sw( 3): s = "string";        -> esac
  740          sw( 4): s = "record";        -> esac
  741          sw( 5): s = "byteinteger";   -> esac
  742          sw( 6): s = "shortinteger";  -> esac
  743          sw( 7): s = "longinteger";   -> esac
  744          sw( 8): s = "longreal";      -> esac
  745          sw( 9): s = "array";         -> esac
  746          sw(10): s = "label";         -> esac
  747  
  748          sw(12): s = "arrayname";     -> esac
  749  
  750          sw(*):  s = "**type ??**";   -> esac
  751          esac:
  752  
  753          %result = s
  754      %end
  755  
  756      %string(255) %function get type name( %integer type)
  757          %string(255) name
  758          %label esac
  759          %switch n(0:15)
  760              
  761          -> n(type&15)
  762          n( 0):  name = "general";       -> esac
  763          n( 1):  name = "integer";       -> esac
  764          n( 2):  name = "real";          -> esac
  765          n( 3):  name = "string";        -> esac
  766          n( 4):  name = "record";        -> esac
  767          n( 5):  name = "byte";          -> esac
  768          n( 6):  name = "short";         -> esac
  769          n( 7):  name = "long";          -> esac
  770          n( 8):  name = "lreal";         -> esac
  771          n( 9):  name = "array";         -> esac
  772          n(10):  name = "label";         -> esac
  773          n(11):  name = "?array";        -> esac
  774          n(12):  name = "arrayname";     -> esac
  775          n(13):  name = "namearray";     -> esac
  776          n(14):  name = "namearrayname"; -> esac
  777  
  778          n(*):   name = "????";    -> esac
  779          esac:
  780  
  781          %result = name
  782      %end
  783  
  784      %string(255) %function get external form name( %integer form )
  785          %string(255) name
  786          %label esac
  787          %switch n(0:15)
  788              
  789          -> n(form&15)
  790          n( 0):  name = "void";           -> esac
  791          n( 1):  name = "simple";         -> esac
  792          n( 2):  name = "name";           -> esac
  793          n( 3):  name = "label";          -> esac
  794          n( 4):  name = "recordformat";   -> esac
  795  
  796          n( 6):  name = "switch";         -> esac
  797          n( 7):  name = "routine";        -> esac
  798          n( 8):  name = "function";       -> esac
  799          n( 9):  name = "map";            -> esac
  800          n(10):  name = "predicate";      -> esac
  801          n(11):  name = "array";          -> esac
  802          n(12):  name = "arrayname";      -> esac
  803          n(13):  name = "namearray";      -> esac
  804          n(14):  name = "namearrayname";  -> esac
  805  
  806          n(*):   name = "????";           -> esac
  807          esac:
  808  
  809          %result = name;
  810      %end
  811  
  812      %string(255) %function get internal form name( %integer form )
  813          %string(255) name
  814          %label esac
  815          %switch n(0:15)
  816  
  817          -> n(form&15)
  818          n( 0):  name = "Constant";    -> esac
  819          n( 1):  name = "V in R";      -> esac
  820          n( 2):  name = "A V in R";    -> esac
  821          n( 3):  name = "A in R";      -> esac
  822          n( 4):  name = "V in S";      -> esac
  823          n( 5):  name = "A V in S";    -> esac
  824          n( 6):  name = "A in S";      -> esac
  825          n( 7):  name = "V in REC";    -> esac
  826          n( 8):  name = "A V in REC";  -> esac
  827          n( 9):  name = "A in REC";    -> esac
  828          n(10):  name = "PgmLabel";    -> esac
  829  
  830          n(*):   name = "????";        -> esac
  831          esac:
  832  
  833          %result = name;
  834      %end
  835  
  836      ! The individual switch entries MUST match those in the assemble routine
  837      ! If the iCode language is extended/re-ordered then this routine
  838      ! must be updated.
  839      %string(255) %function getICodeName( %integer code )
  840          %string(255) s
  841          %label esac
  842          %switch c(0:255)
  843  
  844          -> c(code&255)
  845          c(10):      s = "ENDOFFILE"; -> esac
  846          c('!'):     s = "OR";        -> esac
  847          c('"'):     s = "COMPARED";  -> esac
  848          c('#'):     s = "JNE";       -> esac
  849          c('$'):     s = "DEF";       -> esac
  850          c('%'):     s = "XOR";       -> esac
  851          c('&'):     s = "AND";       -> esac
  852          c(''''):    s = "PUSHS";     -> esac
  853          c('('):     s = "JLE";       -> esac
  854          c(')'):     s = "JGE";       -> esac
  855          c('*'):     s = "MUL";       -> esac
  856          c('+'):     s = "ADD";       -> esac
  857          c('-'):     s = "SUB";       -> esac
  858          c('.'):     s = "CONCAT";    -> esac
  859          c('/'):     s = "QUOT";      -> esac
  860          c(':'):     s = "LOCATE";    -> esac
  861          c(';'):     s = "END";       -> esac
  862          c('<'):     s = "JL";        -> esac
  863          c('='):     s = "JE";        -> esac
  864          c('>'):     s = "JG";        -> esac
  865          c('?'):     s = "COMPARE";   -> esac
  866          c('@'):     s = "PUSH";      -> esac
  867          c('A'):     s = "INIT";      -> esac
  868          c('B'):     s = "REPEAT";    -> esac
  869          c('C'):     s = "COMPAREA";  -> esac
  870          c('D'):     s = "PUSHR";     -> esac
  871          c('E'):     s = "CALL";      -> esac
  872          c('F'):     s = "GOTO";      -> esac
  873          c('G'):     s = "ALIAS";     -> esac
  874          c('H'):     s = "BEGIN";     -> esac
  875          c('I'):     s = "UNUSED_I";  -> esac
  876          c('J'):     s = "JUMP";      -> esac
  877          c('K'):     s = "FALSE";     -> esac
  878          c('L'):     s = "LABEL";     -> esac
  879          c('M'):     s = "MAP";       -> esac
  880          c('N'):     s = "PUSHI";     -> esac
  881          c('O'):     s = "LINE";      -> esac
  882          c('P'):     s = "PLANT";     -> esac
  883          c('Q'):     s = "DIVIDE";    -> esac
  884          c('R'):     s = "RETURN";    -> esac
  885          c('S'):     s = "ASSVAL";    -> esac
  886          c('T'):     s = "TRUE";      -> esac
  887          c('U'):     s = "NEGATE";    -> esac
  888          c('V'):     s = "RESULT";    -> esac
  889          c('W'):     s = "SJUMP";     -> esac
  890          c('X'):     s = "IEXP";      -> esac
  891          c('Y'):     s = "UNUSED_Y";  -> esac
  892          c('Z'):     s = "ASSREF";    -> esac
  893          c('['):     s = "LSH";       -> esac
  894          c('\'):     s = "NOT";       -> esac
  895          c(']'):     s = "RSH";       -> esac
  896          c('^'):     s = "SETFORMAT"; -> esac
  897          c('_'):     s = "SLABEL";    -> esac
  898          c('a'):     s = "ACCESS";    -> esac
  899          c('b'):     s = "BOUNDS";    -> esac
  900          c('c'):     s = "UNUSED_c";  -> esac
  901          c('d'):     s = "DIM";       -> esac
  902          c('e'):     s = "EVENT";     -> esac
  903          c('f'):     s = "FOR";       -> esac
  904          c('g'):     s = "UNUSED_g";  -> esac
  905          c('h'):     s = "UNUSED_h";  -> esac
  906          c('i'):     s = "INDEX";     -> esac
  907          c('j'):     s = "JAM";       -> esac
  908          c('k'):     s = "JZ";        -> esac
  909          c('l'):     s = "LANG";      -> esac
  910          c('m'):     s = "MONITOR";   -> esac
  911          c('n'):     s = "SELECT";    -> esac
  912          c('o'):     s = "ON";        -> esac
  913          c('p'):     s = "ASSPAR";    -> esac
  914          c('q'):     s = "SUBA";      -> esac
  915          c('r'):     s = "RESOLVE";   -> esac
  916          c('s'):     s = "STOP";      -> esac
  917          c('t'):     s = "JNZ";       -> esac
  918          c('u'):     s = "ADDA";      -> esac
  919          c('v'):     s = "MOD";       -> esac
  920          c('w'):     s = "MCODE";     -> esac
  921          c('x'):     s = "REXP";      -> esac
  922          c('y'):     s = "DIAG";      -> esac
  923          c('z'):     s = "CONTROL";   -> esac
  924          c('{'):     s = "START";     -> esac
  925          c('|'):     s = "ALT_PSR";   -> esac
  926          c('}'):     s = "FINISH";    -> esac
  927          c('~'):     s = "ALT";       -> esac
  928          c(*):       s = "ILLEGAL";   -> esac
  929          esac:
  930  
  931          %result = s
  932      %end
  933  
  934      %routine ListICode
  935          selectoutput(listout)
  936          printstring( "icode(" )
  937          printstring( itos(iCodeCount,5) )
  938          printstring( "): " )
  939          printstring( getiCodeName(iCodeInst) )
  940      %end
  941  
  942      %routine ListICodeNoOp
  943          ListICode
  944          newline
  945      %end
  946  
  947      !-----------------------------------------------------------
  948      ! end of "enumeration to String/name functions
  949      !-----------------------------------------------------------
  950  
  951      ! Moved declarations so they can be used by debug routines
  952      %const %string(3) %array regname(AX:DI) =
  953+ 	"EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"
  954  
  955      %const %string(2) %array reg8name(AL:BH) =
  956+ 	"AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH"
  957  
  958      %const %string(7) %array relocname(0:6) =
  959+ 	"", "DATA", "COT", "BSS", "DISPLAY", "EXTERN", "SWTAB"
  960  
  961      !-----------------------------------------------------------
  962      ! Start with machine independent utility functions and stack
  963      ! manipulation and debug
  964      !-----------------------------------------------------------
  965  
  966      !                                                  >> SHOW <<
  967      %routine  show(%record(stackfm)%name  v)
  968          ! JDM The field widths have been tweaked to align columns
  969          write(v_varno,4)
  970          print string(" : Typ="); write(v_type,1)
  971          print string(" Frm="); write(v_form,1)
  972          print string(" Bse="); write(v_base,3);
  973          print string(" Dsp="); write(v_disp,5)
  974          print string(" ExtDsp="); write(v_extdisp,4)
  975          print string(" Siz="); write(v_size,3)
  976          print string(" Xtr="); write(v_extra,3)
  977          print string(" Fmt="); write(v_format,2)
  978          print string(" Dim="); write(v_dim,1)
  979          print string(" Pba="); write(v_pbase,4)
  980          ! JDM JDM retrieve the variable name
  981          %if (length(var(v_var no)_idname) # 0)%start
  982              { JDM show the variable name also }
  983              print string(" Name='".var(v_var no)_idname."'")
  984          %finish
  985          newline
  986      %end
  987  
  988      %routine dump stack entry( %record(stackfm)%name  v, %string(7) prefix )
  989  
  990          ! JDM JDM retrieve the variable name
  991          print string(" STACK entry")
  992          newline
  993          print string(" ".prefix."    name=".var(v_var no)_idname)
  994          newline
  995  
  996          print string(" ".prefix."    type=".itos(v_type,0))
  997          printstring(" ".get type name(v_type))
  998          newline
  999  
  1000          print string(" ".prefix."    form=".itos(v_form,0))
  1001          printstring(" ".get internal form name(v_form))
  1002          newline
  1003  
  1004          print string(" ".prefix."   aform=".itos(v_aform,0))
  1005          printstring(" ".get external form name(v_aform))
  1006          newline
  1007  
  1008          print string(" ".prefix."    base=".itos(v_base,0))
  1009          newline
  1010          print string(" ".prefix."   scope=".itos(v_scope,0))
  1011          newline
  1012          print string(" ".prefix."     dim=".itos(v_dim,0))
  1013          newline
  1014  
  1015          print string(" ".prefix."    disp=".itos(v_disp,0))
  1016          newline
  1017          print string(" ".prefix." extdisp=".itos(v_extdisp,0))
  1018          newline
  1019          print string(" ".prefix."  format=".itos(v_format,0))
  1020          newline
  1021          print string(" ".prefix."    size=".itos(v_size,0))
  1022          newline
  1023          print string(" ".prefix."   pbase=".itos(v_pbase,0))
  1024          newline
  1025          print string(" ".prefix."   extra=".itos(v_extra,0))
  1026          newline
  1027          print string(" ".prefix."   varno=".itos(v_varno,0))
  1028          newline
  1029          newline
  1030      %end
  1031  
  1032      %routine dump tag var( %integer tag, %string(7) prefix )
  1033  
  1034          print string(" VAR entry")
  1035          newline
  1036          print string(" ".prefix."     tag=".itos(tag,0))
  1037          newline
  1038          print string(" ".prefix."    name=".var(tag)_idname)
  1039          newline
  1040  
  1041          print string(" ".prefix."    type=".itos(var(tag)_type,0))
  1042          printstring(" ".get type name(var(tag)_type))
  1043          newline
  1044          print string(" ".prefix."    form=".itos(var(tag)_form,0))
  1045          printstring(" ".get external form name(var(tag)_form))
  1046          newline
  1047          print string(" ".prefix."   level=".itos(var(tag)_level,0))
  1048          newline
  1049          print string(" ".prefix."   scope=".itos(var(tag)_scope,0))
  1050          printstring(" ".relocname(var(tag)_scope>>4) )
  1051          newline
  1052          print string(" ".prefix."     dim=".itos(var(tag)_dim,0))
  1053          newline
  1054  
  1055          print string(" ".prefix."    disp=".itos(var(tag)_disp,0))
  1056          newline
  1057          print string(" ".prefix." extdisp=".itos(var(tag)_extdisp,0))
  1058          newline
  1059          print string(" ".prefix."  format=".itos(var(tag)_format,0))
  1060          newline
  1061          print string(" ".prefix."    size=".itos(var(tag)_size,0))
  1062          newline
  1063          print string(" ".prefix."   pbase=".itos(var(tag)_pbase,0))
  1064          newline
  1065          print string(" ".prefix."   extra=".itos(var(tag)_extra,0))
  1066          newline
  1067          newline
  1068      %end
  1069  
  1070      ! Simple ABORT routine
  1071      %routine abort(%string(255) message)
  1072          %integer j
  1073  
  1074          select output(report)
  1075          printstring("Pass 2 abandoned at line ");
  1076          write(current line, 0);
  1077          printstring(" : ");
  1078          printstring(message)
  1079          newline
  1080          %if (stp # 0) %start
  1081              print string("STACK:");  newline
  1082              spaces(11) %and show(stack(j)) %for j = 1,1,stp
  1083          %finish
  1084          %stop
  1085      %end
  1086  
  1087      !                                                  >> WARN <<
  1088      %routine  warn(%integer  n)
  1089          %string(255) warning
  1090          %switch  w(1:8)
  1091          -> w(n)
  1092  w(1):   warning = "Division by zero";                  -> at
  1093  w(2):   warning = "Illegal FOR";                       -> at
  1094  w(3):   warning = "Non-local control variable?";       -> at
  1095  w(4):   warning = "Invalid parameter for READ SYMBOL"; -> at
  1096  w(5):   warning = "String constant too long";          -> at
  1097  w(6):   warning = "No. of shifts outwith 0..31";       -> at
  1098  w(7):   warning = "Illegal constant exponent";         -> at
  1099  w(8):   warning = "Numerical constant too big";        -> at
  1100  at:
  1101          select output(report)
  1102          print string("*WARNING: line")
  1103          write(current line, 0)
  1104          print string(": ")
  1105          print string( warning )
  1106          newline
  1107          select output(objout)
  1108      %end
  1109  
  1110      !                                                  >> MONITOR <<
  1111      %routine  monitor(%record(stackfm)%name  v, %string(15) text)
  1112          select output(report)
  1113          print string(text);  print symbol(':')
  1114          spaces(10-length(text))
  1115          show(v)
  1116          select output(objout)
  1117      %end
  1118  
  1119      !                                                  >> GET GP TAG <<
  1120      %integerfn get gp tag
  1121          %integer l
  1122  
  1123          %if (gp asl = 0) %then abort("GP Tags")
  1124          l = gp asl
  1125          gp asl = gp tags(l)_link
  1126          %result = l
  1127      %end
  1128  
  1129      !                                                  >> RET GP TAG <<
  1130      %integerfn ret gp tag(%integer index)
  1131          %integer link
  1132  
  1133          link = gp tags(index)_link
  1134          gp tags(index)_link = gp asl
  1135          gp asl = index
  1136          %result = link
  1137      %end
  1138  
  1139      !------------------------------------------------------
  1140      ! Machine dependent utility routines
  1141      !------------------------------------------------------
  1142  
  1143      ! Routines to write the intermediate file
  1144      ! Record format is:
  1145      ! <type><length><data>
  1146      ! For debug purposes, the elements are all written as ascii
  1147      ! characters, where <type> is a single letter, <length> is a single
  1148      ! hex digit, length refers to the number of bytes (2 chars) of data.
  1149  
  1150      ! Intermediate file types: ( description below declaration )
  1151      %constinteger IF OBJ		=  0
  1152            { A - plain object code }
  1153      %constinteger IF DATA	    =  1
  1154            { B - dataseg offset code word }
  1155      %constinteger IF CONST	    =  2
  1156            { C - const seg offset code word }
  1157      %constinteger IF DISPLAY	=  3
  1158            { D - display seg offset code word }
  1159      %constinteger IF JUMP		=  4
  1160            { E - unconditional jump to label }
  1161      %constinteger IF JCOND	    =  5
  1162            { F - cond jump to label JE, JNE, JLE, JL, JGE, JG }
  1163      %constinteger IF CALL		=  6
  1164            { G - call a label }
  1165      %constinteger IF LABEL	    =  7
  1166            { H - define a label }
  1167      %constinteger IF FIXUP	    =  8
  1168            { I - define location for stack fixup instruction }
  1169      %constinteger IF SETFIX	    =  9
  1170            { J - stack fixup <location> <amount> }
  1171      %constinteger IF REQEXT	    = 10
  1172            { K - external name spec }
  1173      %constinteger IF REFLABEL   = 11
  1174            { L - relative address of label (JDM JDM new IBJ command) }
  1175      %constinteger IF REFEXT	    = 12
  1176            { M - external name relative offset code word (call external) }
  1177      %constinteger IF BSS		= 13
  1178            { N - BSS segment offset code word }
  1179      %constinteger IF COTWORD	= 14
  1180            { O - Constant table word }
  1181      %constinteger IF DATWORD	= 15
  1182            { P - Data segment word }
  1183      %constinteger IF SWTWORD	= 16
  1184            { Q - switch table entry - actually a label ID }
  1185      %constinteger IF SOURCE	    = 17
  1186            { R - name of the source file }
  1187      %constinteger IF DEFEXTCODE = 18
  1188            { S - define a code label that is external }
  1189      %constinteger IF DEFEXTDATA = 19
  1190            { T - define a data label that is external }
  1191      %constinteger IF SWT        = 20
  1192            { U - switch table offset code word }
  1193      %constinteger IF LINE       = 21
  1194            { V - line number info for debugger }
  1195      %constinteger IF ABSEXT     = 22
  1196            { W - external name absolute offset code word (data external) }
  1197  
  1198      %routine  writenibble(%integer n)
  1199          n = n&16_f
  1200          %if (0 <= n %and n <= 9) %start
  1201              printsymbol(n + '0')
  1202          %else
  1203              printsymbol(n + ('A' - 10))
  1204          %finish
  1205      %end
  1206  
  1207      ! print a number in hexadecimal, to "places" size
  1208      %routine write hex(%integer n, places)
  1209          %integer p, shift
  1210  
  1211          shift = (places - 1) * 4
  1212          %while (shift > 0) %cycle
  1213              p = n >> shift
  1214              writenibble(p)
  1215              shift = shift - 4
  1216          %repeat
  1217          writenibble(n)
  1218      %end
  1219  
  1220      %routine  writeifrecord( %integer type, length, 
  1221+                              %byteintegerarrayname buffer )
  1222          %integer c1, c2, i
  1223  
  1224          select output(objout)
  1225          printsymbol('A'+type)
  1226          %if (length > 255) %then abort("Intermediate file record too long")
  1227          writenibble(length>>4)
  1228          writenibble(length&15)
  1229  	
  1230          i = 0;
  1231          %while (length > 0) %cycle
  1232              c1 = buffer(i) >> 4
  1233              c2 = buffer(i)&15
  1234              writenibble(c1)
  1235              writenibble(c2)
  1236              i = i + 1
  1237              length = length - 1
  1238          %repeat
  1239          newline
  1240      %end
  1241  
  1242      ! Simple buffered output of code bytes...
  1243      %own %integer objectptr = 0;
  1244  	%const %integer objbufmax = 20
  1245      %own %byte %integer %array objectbytes(0:objbufmax)
  1246      ! Add corresponding bytes for the listing
  1247      !    (not always the same for fudged opcodes)
  1248      %own %integer listptr = 0
  1249  	%const %integer lstbufmax = 11
  1250      %own %byte %integer %array listbytes(0:lstbufmax)
  1251  
  1252  	! routine to clean to object buffer
  1253  	%routine ClearObjectBuffer
  1254  		%integer i
  1255  		%for i = 0,1,objbufmax %cycle
  1256  			objectbytes(i) = 0
  1257  		%repeat
  1258  		objectptr = 0
  1259  	%end
  1260  
  1261      ! Routine to provide the address and hex opcode listing in the
  1262      ! diagnostic output
  1263      %routine  listpreamble
  1264          %integer i;
  1265  
  1266          select output(listout)
  1267          space; writehex(nextcad, 4); space;
  1268          %for i = 0, 1, 7 %cycle
  1269              %if (i < listptr) %start
  1270                  writehex(listbytes(i), 2)
  1271                  space
  1272              %else
  1273                  spaces(3)
  1274              %finish
  1275          %repeat
  1276          spaces(8)
  1277          nextcad = nextcad + listptr
  1278          listptr = 0
  1279      %end
  1280  
  1281      ! flush the code buffer
  1282      %routine flushcode
  1283          %if (objectptr # 0) %start
  1284              writeifrecord(IF OBJ, objectptr, objectbytes)
  1285              ! clear the output pipe
  1286              ClearObjectBuffer
  1287          %finish
  1288      %end
  1289  
  1290      ! puts a normal code byte into the listing and code pipes
  1291      %routine  putcodebyte(%integer b)
  1292          objectbytes(objectptr) = b
  1293          objectptr = objectptr + 1
  1294      %end
  1295  
  1296      ! puts a normal code byte into the listing and code pipes
  1297      %routine  putlistbyte(%integer b)
  1298          listbytes(listptr) = b
  1299          listptr = listptr + 1
  1300      %end
  1301  
  1302      ! puts a normal code byte into the listing and code pipes
  1303      %routine  putbyte(%integer b)
  1304  		putlistbyte( b )
  1305  		putcodebyte( b )
  1306      %end
  1307  
  1308      ! A very handy little boolean function, used for instructions
  1309      ! with variable size immediate operands
  1310      %integerfn issmall(%integer i)
  1311          %result = 1 %if (-128 < i < 128)
  1312          %result = 0;
  1313      %end
  1314  
  1315      ! And aide-memoire of intel 80386 address modes...
  1316      !-------------------------
  1317      !     [EAX]
  1318      !     [ECX]
  1319      !     [EDX]
  1320      !     [EBX]
  1321      !     [][]
  1322      !     [disp32]
  1323      !     [ESI]
  1324      !     [EDI]
  1325      !-------------------------
  1326      !     [EAX+disp8]
  1327      !     [ECX+disp8]
  1328      !     [EDX+disp8]
  1329      !     [EBX+disp8]
  1330      !     [][]
  1331      !     [EBP+disp8]
  1332      !     [ESI+disp8]
  1333      !     [EDI+disp8]
  1334      !-------------------------
  1335      !     [EAX+disp32]
  1336      !     [ECX+disp32]
  1337      !     [EDX+disp32]
  1338      !     [EBX+disp32]
  1339      !     [][]
  1340      !     [EBP+disp32]
  1341      !     [ESI+disp32]
  1342      !     [EDI+disp32]
  1343      !-------------------------
  1344  
  1345      ! mod r/m format is:
  1346      ! mod LHREG R/M
  1347      ! where mod = 11 for rh registers
  1348  
  1349      ! plant a modrm reference where the rh operand is a register
  1350      ! Both parameters are actual register numbers, not internal ID's
  1351      %routine  modrmreg(%integer reg1, %integer reg2)
  1352          putbyte(16_C0 ! (reg1 << 3) ! (reg2));
  1353      %end
  1354  
  1355      ! tags corresponding to linker directives...
  1356      %const %integer %array reltag(0:6) =
  1357+     0,			{ no relocation }
  1358+ 	IF DATA,    { dataseg offset code word }
  1359+ 	IF CONST,   { const seg offset code word }
  1360+ 	IF BSS,		{ BSS relative code word }
  1361+ 	IF DISPLAY,	{ display seg offset code word }
  1362+ 	IF ABSEXT, 	{ external name absolute offset code word }
  1363+ 	IF SWT		{ switch table offset code word }
  1364  
  1365      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  1366      %routine norelocateoffset( %integer offset )
  1367          %integer i;
  1368  
  1369  		%for i=1,1,word size %cycle
  1370  			putbyte(offset&255)
  1371  			offset = offset >> 8
  1372  		%repeat
  1373  
  1374      %end
  1375  
  1376      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  1377      %routine relocateoffset( %integer reloc, offset, extdisp )
  1378          %integer tag, i;
  1379  
  1380  		%if (reloc = 0) %start
  1381  			norelocateoffset( offset )
  1382  		%else
  1383              ! so that only the offset is going into the queue
  1384  			flushcode
  1385  
  1386  			tag = reltag(reloc);
  1387  			
  1388  			%if (tag = IF ABSEXT) %start
  1389                  ! offset byte 0
  1390  				putbyte(offset&255)
  1391                  ! get next byte
  1392                  offset = offset >> 8
  1393                  ! offset byte 1
  1394  				putbyte(offset&255)
  1395                  ! get next byte
  1396                  ! needed?
  1397                  offset = offset >> 8
  1398  
  1399                  ! extdisp byte 0
  1400  				putbyte(extdisp&255)
  1401                  ! get next byte
  1402                  extdisp = extdisp >> 8
  1403                  ! extdisp byte 1
  1404  				putbyte(extdisp&255)
  1405                  ! get next byte
  1406                  ! needed?
  1407                  extdisp = extdisp >> 8
  1408  
  1409  				writeifrecord(tag, word size, objectbytes)
  1410                  ! clear the queue
  1411  				ClearObjectBuffer	
  1412  			%else
  1413  				%for i=1,1,word size %cycle
  1414  					putbyte(offset&255)
  1415                      ! get next byte
  1416                      offset = offset >> 8
  1417  				%repeat
  1418  				writeifrecord(tag, word size, objectbytes)
  1419                  ! clear the queue
  1420  				ClearObjectBuffer
  1421  			%finish
  1422  
  1423  		%finish
  1424  
  1425      %end
  1426  
  1427      ! plant a modrm reference where the rh operand is in memory
  1428      ! Parameter REG1 is an actual register number,
  1429      !    but BASE is an internal ID
  1430      %routine  modrmmem( %integer reg1, base, disp, extdisp )
  1431          %integer mod, reloc
  1432  
  1433          reloc = base>>4
  1434          base = base&15
  1435  
  1436          %if (base = 0) %start
  1437              ! no register, just a displacement
  1438              ! mod = 000, rm = 101
  1439              putbyte((reg1 << 3) ! 5)
  1440              relocateoffset(reloc, disp, extdisp )
  1441          %else
  1442              %if (disp = 0) %and (base # BP) %start
  1443                  mod = 0
  1444              %else
  1445                  %if (issmall(disp) # 0) %start
  1446                      ! fits in one byte
  1447                      mod = 1
  1448                  %else
  1449                      mod = 2
  1450                  %finish
  1451              %finish
  1452  
  1453              ! Alas, displacement (even zero) must be output in full if
  1454              ! the offset is relocatable
  1455              %if (reloc # 0) %then mod = 2
  1456  
  1457              %if (base > DI) %or (base = SP) %start
  1458                  abort("Internal address mode error")
  1459              %finish
  1460  
  1461              ! Note - base-1 maps internal ID to real register
  1462  
  1463              putbyte((mod << 6)!(reg1 << 3)!(base - 1))
  1464  
  1465              %if (mod = 1) %start
  1466                  putbyte(disp)
  1467              %else
  1468                  %if (mod = 2) %then relocateoffset(reloc, disp, extdisp )
  1469              %finish
  1470          %finish
  1471      %end
  1472  
  1473      ! Print the corresponding memory access string
  1474      ! BASE is an internal ID, not an actual register number
  1475      %routine  printmemref( %integer base, disp )
  1476          %integer reloc
  1477  
  1478          reloc = base >> 4
  1479          base = base&15
  1480          selectoutput(listout)
  1481          printsymbol('[')
  1482          %if (base # 0) %start
  1483              printstring(regname(base))
  1484              %if (reloc # 0) %start
  1485                  printsymbol('+')
  1486                  printstring(relocname(reloc))
  1487              %finish
  1488              %if (disp # 0) %then %start
  1489                  printsymbol('+') %if (disp > 0)
  1490                  write(disp,0)
  1491              %finish
  1492          %else
  1493              %if (reloc # 0) %start
  1494                  printstring(relocname(reloc))
  1495                  printsymbol('+')
  1496              %finish
  1497              writehex(disp, 4)
  1498          %finish
  1499          printsymbol(']')
  1500      %end
  1501  
  1502      ! An opcode with no operands (eg RET)
  1503      %routine dumpsimple(%integer opn)
  1504  
  1505          putbyte(opvalue(opn))
  1506  
  1507          listpreamble
  1508          printstring(opname(opn))
  1509          newline
  1510          flushcode
  1511      %end
  1512  
  1513      ! A special bit of magic, used in record assignment
  1514      %routine dumprepmovsb
  1515          ! rep
  1516          putbyte(16_f3)
  1517          ! movsb
  1518          putbyte(16_a4)
  1519  
  1520          listpreamble
  1521          printstring("REP MOVSB")
  1522          newline
  1523          flushcode
  1524      %end
  1525  
  1526      ! Used in record = 0 assignment
  1527      %routine dumprepstosb
  1528          ! rep
  1529          putbyte(16_f3)
  1530          ! stosb
  1531          putbyte(16_aa)
  1532  
  1533          listpreamble
  1534          printstring("REP STOSB")
  1535          newline
  1536          flushcode
  1537      %end
  1538  
  1539      ! unary register operation - DEC, INC, NEG, NOT, POP, PUSH, IDIV, IMUL
  1540      ! REG is an internal ID, not an actual register number
  1541      %routine dumpur( %integer opn, reg )
  1542          %switch ops(DEC:IMUL)
  1543  
  1544          displayhint(reg) = 0
  1545  
  1546          ->ops(opn)
  1547  
  1548  ops(DEC):   putbyte(16_48 + reg - AX);                 ->break
  1549  ops(INC):   putbyte(16_40 + reg - AX);                 ->break
  1550  ops(NEG):   putbyte(16_F7); modrmreg(3, reg - AX);     ->break
  1551  ops(NOT):   putbyte(16_F7); modrmreg(2, reg - AX);     ->break
  1552  ops(POP):   putbyte(16_58 + reg - AX);                 ->break
  1553  ops(PUSH):  putbyte(16_50 + reg - AX);                 ->break
  1554  ops(IDIV):  putbyte(16_F7); modrmreg(7, reg - AX);     ->break
  1555  ops(IMUL):  putbyte(16_F7); modrmreg(5, reg - AX);     ->break
  1556  
  1557  break:
  1558          listpreamble
  1559          printstring(opname(opn))
  1560          space
  1561          printstring(regname(reg))
  1562          newline
  1563          flushcode
  1564      %end
  1565  
  1566      ! Plant code for a unary operation on memory
  1567      ! BASE is an internal ID, not the actual register number
  1568      %routine dumpum( %integer opn, base, disp, extdisp )
  1569          %switch ops(DEC:JMP)
  1570  
  1571          ->ops(opn)
  1572  
  1573  ops(DEC):   putbyte(16_FF) ;modrmmem(1, base, disp, extdisp);  ->break
  1574  ops(INC):   putbyte(16_FF) ;modrmmem(0, base, disp, extdisp);  ->break
  1575  ops(NEG):   putbyte(16_F7) ;modrmmem(3, base, disp, extdisp);  ->break
  1576  ops(NOT):   putbyte(16_F7) ;modrmmem(2, base, disp, extdisp);  ->break
  1577  ops(POP):   putbyte(16_8F) ;modrmmem(0, base, disp, extdisp);  ->break
  1578  ops(PUSH):  putbyte(16_FF) ;modrmmem(6, base, disp, extdisp);  ->break
  1579  ops(IDIV):  putbyte(16_F7) ;modrmmem(7, base, disp, extdisp);  ->break
  1580  ops(IMUL):  putbyte(16_F7) ;modrmmem(5, base, disp, extdisp);  ->break
  1581  ops(JMP):   putbyte(16_FF) ;modrmmem(4, base, disp, extdisp);  ->break
  1582  ops(CALL):  putbyte(16_FF) ;modrmmem(2, base, disp, extdisp);  ->break
  1583  
  1584  break:
  1585          listpreamble
  1586          printstring(opname(opn))
  1587          ! otherwise it's ambiguous for the reader
  1588          printstring(" WORD ")
  1589          printmemref(base, disp)
  1590          newline
  1591          flushcode
  1592      %end
  1593  
  1594      ! Plant code for a unary operation on an 8 bit memory location
  1595      ! Not all of the possible unary ops make sense as 8 bit destinations
  1596      ! BASE is an internal ID, not the actual register number
  1597      %routine dumpum8( %integer opn, base, disp, extdisp )
  1598          %integer base op, index
  1599  
  1600          %if (opn = DEC) %or (opn = INC) %start
  1601              base op = 16_FE
  1602              %if (opn = DEC) %then index = 1 %else index = 0
  1603          %else
  1604              %if (opn = NOT) %or (opn = NEG) %start
  1605                  base op = 16_F6
  1606                  %if (opn = NOT) %then index = 2 %else index = 3
  1607              %else
  1608                  Abort("Invalid UM8")
  1609              %finish
  1610          %finish
  1611  
  1612          putbyte(base op)
  1613          modrmmem(index, base, disp, extdisp )
  1614  
  1615          listpreamble
  1616          printstring(opname(opn))
  1617          ! otherwise it's ambiguous for the reader
  1618          printstring(" BYTE ")
  1619          printmemref(base, disp)
  1620          newline
  1621          flushcode
  1622      %end
  1623  
  1624      ! Plant a Memory <- Reg operation
  1625      ! Both BASE and REG are internal ID's, not actual register numbers
  1626      %routine dumpmr( %integer opn, base, disp, extdisp, reg )
  1627  
  1628          %if (opn = SHL) %start
  1629              ! special "shift by CL"
  1630              putbyte(16_D3)
  1631              modrmmem(4, base, disp, extdisp )
  1632          %else
  1633              %if (opn = SHR) %start
  1634                  putbyte(16_D3)
  1635                  modrmmem(5, base, disp, extdisp )
  1636              %else
  1637                  ! normal stuff
  1638                  putbyte(opvalue(opn))
  1639                  modrmmem(reg - AX, base, disp, extdisp )
  1640              %finish
  1641          %finish
  1642  
  1643          listpreamble
  1644          printstring(opname(opn))
  1645          space
  1646          printmemref(base, disp)
  1647          printsymbol(',')
  1648          printstring(regname(reg))
  1649          newline
  1650          flushcode
  1651      %end
  1652  
  1653      ! Plant an 8 bit Memory <- Reg operation
  1654      ! Both BASE and REG are internal ID's, not actual register numbers
  1655      %routine dumpmr8( %integer opn, base, disp, extdisp, reg )
  1656  
  1657          %if (opn = SHL) %start
  1658              ! special "shift by CL"
  1659              putbyte(16_D2)
  1660              modrmmem(4, base, disp, extdisp )
  1661          %finish %else %if (opn = SHR) %start
  1662              putbyte(16_D2)
  1663              modrmmem(5, base, disp, extdisp )
  1664          %finish %else %start
  1665              ! normal stuff
  1666              putbyte(op8value(opn))
  1667              modrmmem(reg - AL, base, disp, extdisp )
  1668          %finish
  1669  
  1670          listpreamble
  1671          printstring(opname(opn))
  1672          space
  1673          printmemref(base, disp)
  1674          printsymbol(',')
  1675          printstring(reg8name(reg))
  1676          newline
  1677          flushcode
  1678      %end
  1679  
  1680      ! Plant a 16 bit Reg <- Memory operation
  1681      ! Both BASE and REG are internal ID's, not actual register numbers
  1682      %routine dumprm( %integer opn, reg, base, disp, extdisp )
  1683  
  1684          ! We optimise the fairly common instruction MOV AX,[disp] with
  1685          ! the special short-form quirk of the 8086...
  1686  
  1687          %if (reg = AX) %and (opn = MOV) %and (base&15 = 0) %start
  1688              putbyte(16_A1)
  1689              relocateoffset(base>>4, disp, extdisp)
  1690          %else
  1691              displayhint(reg) = 0
  1692  
  1693              putbyte(opvalue(opn)+2)
  1694              modrmmem(reg - AX, base, disp, extdisp)
  1695          %finish
  1696  
  1697          listpreamble
  1698          printstring(opname(opn))
  1699          space
  1700          printstring(regname(reg))
  1701          printsymbol(',')
  1702          printmemref(base, disp)
  1703          newline
  1704          flushcode
  1705      %end
  1706  
  1707      ! Plant an 8 bit Reg <- Memory operation
  1708      ! Both BASE and REG are internal ID's, not actual register numbers
  1709      %routine dumprm8( %integer opn, reg, base, disp, extdisp )
  1710  
  1711          putbyte(op8value(opn)+2)
  1712          modrmmem(reg - AL, base, disp, extdisp )
  1713  
  1714          listpreamble
  1715          printstring(opname(opn))
  1716          space
  1717          printstring(reg8name(reg))
  1718          printsymbol(',')
  1719          printmemref(base, disp)
  1720          newline
  1721          flushcode
  1722      %end
  1723  
  1724      ! Plant a word Reg <- Reg operation
  1725      ! Both register parameters are internal ID's
  1726      %routine dumprr( %integer opn, reg1, reg2 )
  1727  
  1728          displayhint(reg1) = 0
  1729  
  1730          %if (opn = SHL) %start
  1731              ! special "shift by CL"
  1732              putbyte(16_D3)
  1733              modrmreg(4, reg1 - AX)
  1734          %finish %else %if (opn = SHR) %start
  1735              putbyte(16_D3)
  1736              modrmreg(5, reg1 - AX)
  1737          %finish %else %start
  1738              ! normal stuff
  1739              putbyte(opvalue(opn))
  1740              modrmreg(reg2 - AX, reg1 - AX)
  1741          %finish
  1742  
  1743          listpreamble
  1744          printstring(opname(opn))
  1745          space
  1746          printstring(regname(reg1))
  1747          printsymbol(',')
  1748          printstring(regname(reg2))
  1749          newline
  1750          flushcode
  1751      %end
  1752  
  1753      %routine dumprr8( %integer opn, reg1, reg2 )
  1754  
  1755          %if (opn = SHL) %start
  1756              ! special "shift by CL"
  1757              putbyte(16_D2)
  1758              modrmreg(4, reg1 - AL)
  1759          %finish %else %if (opn = SHR) %start
  1760              putbyte(16_D2)
  1761              modrmreg(5, reg1 - AL)
  1762          %finish %else %start
  1763              putbyte(op8value(opn))
  1764              modrmreg(reg2 - AL, reg1 - AL)
  1765          %finish
  1766  
  1767          listpreamble
  1768          printstring(opname(opn))
  1769          space
  1770          printstring(reg8name(reg1))
  1771          printsymbol(',')
  1772          printstring(reg8name(reg2))
  1773          newline
  1774          flushcode
  1775      %end
  1776  
  1777      %const %byte %integer %array aximmediatevalue(NOP:XOR) =
  1778+     0, 0, 0, 0, 0,
  1779+ 	0, 0, 0, 0,
  1780+ 	0, 0,
  1781+ 	0, 16_B8, 0,
  1782+ 	16_15, 16_05, 16_25, 16_3D, 16_0D, 16_2D, 16_35
  1783  
  1784      ! Register immediate operations - can be MOV, Math, or Shift
  1785      ! The immediate operand may be a relocated offset as part of
  1786      ! an address calculation
  1787      %routine dumprioffset( %integer opn, reg, reloc, immed, extdisp )
  1788          %integer subop
  1789          %switch ops(MOV:SHR)
  1790  
  1791          displayhint(reg) = 0
  1792  
  1793          ! because we pass around the or-able version
  1794          reloc = reloc >> 4
  1795  
  1796          %if (reg = AX) %and (opn <= XOR) %start
  1797              putbyte(aximmediatevalue(opn))
  1798              relocateoffset(reloc, immed, extdisp)
  1799              ->break
  1800          %else
  1801              ->ops(opn)
  1802          %finish
  1803  
  1804  ops(MOV):
  1805          putbyte(16_B8 + reg - AX)
  1806          relocateoffset(reloc, immed, extdisp )
  1807                                                         ->break
  1808  ops(ADD):
  1809          subop = 0
  1810          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1811              putbyte(16_83)
  1812              modrmreg(subop, reg - AX)
  1813              putbyte(immed&255)
  1814          %else
  1815              putbyte(16_81)
  1816              modrmreg(subop, reg - AX)
  1817              relocateoffset(reloc, immed, extdisp )
  1818          %finish
  1819                                                         ->break
  1820  ops(ADC):
  1821          subop = 2
  1822          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1823              putbyte(16_83)
  1824              modrmreg(subop, reg - AX)
  1825              putbyte(immed&255)
  1826          %else
  1827              putbyte(16_81)
  1828              modrmreg(subop, reg - AX)
  1829              relocateoffset(reloc, immed, extdisp )
  1830          %finish
  1831                                                         ->break
  1832  ops(CMP):
  1833          subop = 7
  1834          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1835              putbyte(16_83)
  1836              modrmreg(subop, reg - AX)
  1837              putbyte(immed&255)
  1838          %else
  1839              putbyte(16_81)
  1840              modrmreg(subop, reg - AX)
  1841              relocateoffset(reloc, immed, extdisp )
  1842          %finish
  1843                                                         ->break
  1844  ops(SUB):
  1845          subop = 5
  1846          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1847              putbyte(16_83)
  1848              modrmreg(subop, reg - AX)
  1849              putbyte(immed&255)
  1850          %else
  1851              putbyte(16_81)
  1852              modrmreg(subop, reg - AX)
  1853              relocateoffset(reloc, immed, extdisp )
  1854          %finish
  1855                                                         ->break
  1856  ops(AND):
  1857          subop = 4
  1858          putbyte(16_81)
  1859          modrmreg(subop, reg - AX)
  1860          relocateoffset(reloc, immed, extdisp )
  1861                                                         ->break
  1862  ops(OR):
  1863          subop = 1
  1864          putbyte(16_81)
  1865          modrmreg(subop, reg - AX)
  1866          relocateoffset(reloc, immed, extdisp )
  1867                                                         ->break
  1868  ops(XOR):
  1869          subop = 6
  1870          putbyte(16_81)
  1871          modrmreg(subop, reg - AX)
  1872          relocateoffset(reloc, immed, extdisp )
  1873                                                         ->break
  1874  ops(SHL):
  1875          subop = 4
  1876          %if (immed = 1) %start
  1877              ! special shift-by-one instruction
  1878              putbyte(16_D1)
  1879              modrmreg(subop, reg - AX)
  1880          %else
  1881              putbyte(16_C1)
  1882              modrmreg(subop, reg - AX)
  1883              putbyte(immed)
  1884          %finish
  1885                                                         ->break
  1886  ops(SHR):
  1887          subop = 5
  1888          %if (immed = 1) %start
  1889              ! special shift-by-one instruction
  1890              putbyte(16_D1)
  1891              modrmreg(subop, reg - AX)
  1892          %else
  1893              putbyte(16_C1)
  1894              modrmreg(subop, reg - AX)
  1895              putbyte(immed)
  1896          %finish
  1897                                                         ->break
  1898  break:
  1899          listpreamble
  1900          printstring(opname(opn))
  1901          space
  1902          printstring(regname(reg))
  1903          printsymbol(',')
  1904          %if (reloc # 0) %start
  1905              printstring(relocname(reloc))
  1906              printsymbol('+')
  1907          %finish
  1908          write(immed, 0)
  1909          newline
  1910          flushcode
  1911      %end
  1912  
  1913      ! Register immediate operations - can be MOV, Math, or Shift
  1914      %routine dumpri( %integer opn, reg, immed )
  1915          %integer subop
  1916          %switch ops(MOV:SHR)
  1917  
  1918          displayhint(reg) = 0
  1919  
  1920          %if (reg = AX) %and (opn <= XOR) %start
  1921              putbyte(aximmediatevalue(opn))
  1922              norelocateoffset( immed )
  1923              ->break
  1924          %else
  1925              ->ops(opn)
  1926          %finish
  1927  
  1928  ops(MOV):
  1929          putbyte(16_B8 + reg - AX)
  1930          norelocateoffset( immed )
  1931                                                         ->break
  1932  ops(ADD):
  1933          subop = 0
  1934          %if (issmall(immed) # 0) %start
  1935              putbyte(16_83)
  1936              modrmreg(subop, reg - AX)
  1937              putbyte(immed&255)
  1938          %else
  1939              putbyte(16_81)
  1940              modrmreg(subop, reg - AX)
  1941              norelocateoffset( immed )
  1942          %finish
  1943                                                         ->break
  1944  ops(ADC):
  1945          subop = 2
  1946          %if (issmall(immed) # 0) %start
  1947              putbyte(16_83)
  1948              modrmreg(subop, reg - AX)
  1949              putbyte(immed&255)
  1950          %else
  1951              putbyte(16_81)
  1952              modrmreg(subop, reg - AX)
  1953              norelocateoffset( immed )
  1954          %finish
  1955                                                         ->break
  1956  ops(CMP):
  1957          subop = 7
  1958          %if (issmall(immed) # 0) %start
  1959              putbyte(16_83)
  1960              modrmreg(subop, reg - AX)
  1961              putbyte(immed&255)
  1962          %else
  1963              putbyte(16_81)
  1964              modrmreg(subop, reg - AX)
  1965              norelocateoffset( immed )
  1966          %finish
  1967                                                         ->break
  1968  ops(SUB):
  1969          subop = 5
  1970          %if (issmall(immed) # 0) %start
  1971              putbyte(16_83)
  1972              modrmreg(subop, reg - AX)
  1973              putbyte(immed&255)
  1974          %else
  1975              putbyte(16_81)
  1976              modrmreg(subop, reg - AX)
  1977              norelocateoffset( immed )
  1978          %finish
  1979                                                         ->break
  1980  ops(AND):
  1981          subop = 4
  1982          putbyte(16_81)
  1983          modrmreg(subop, reg - AX)
  1984          norelocateoffset( immed )
  1985                                                         ->break
  1986  ops(OR):
  1987          subop = 1
  1988          putbyte(16_81)
  1989          modrmreg(subop, reg - AX)
  1990          norelocateoffset( immed )
  1991                                                         ->break
  1992  ops(XOR):
  1993          subop = 6
  1994          putbyte(16_81)
  1995          modrmreg(subop, reg - AX)
  1996          norelocateoffset( immed )
  1997                                                         ->break
  1998  ops(SHL):
  1999          subop = 4
  2000          %if (immed = 1) %start
  2001              ! special shift-by-one instruction
  2002              putbyte(16_D1)
  2003              modrmreg(subop, reg - AX)
  2004          %else
  2005              putbyte(16_C1)
  2006              modrmreg(subop, reg - AX)
  2007              putbyte(immed)
  2008          %finish
  2009                                                         ->break
  2010  ops(SHR):
  2011          subop = 5
  2012          %if (immed = 1) %start
  2013              ! special shift-by-one instruction
  2014              putbyte(16_D1)
  2015              modrmreg(subop, reg - AX)
  2016          %else
  2017              putbyte(16_C1)
  2018              modrmreg(subop, reg - AX)
  2019              putbyte(immed)
  2020          %finish
  2021                                                         ->break
  2022  break:
  2023          listpreamble
  2024          printstring(opname(opn))
  2025          space
  2026          printstring(regname(reg))
  2027          printsymbol(',')
  2028          write(immed, 0)
  2029          newline
  2030          flushcode
  2031      %end
  2032  
  2033      ! Memory (word) immediate operations - can be MOV, Math, or Shift
  2034      %routine dumpmi( %integer opn, base, disp, extdisp, immed )
  2035          %integer subop
  2036          %switch ops(MOV:SHR)
  2037  
  2038          ->ops(opn)
  2039  
  2040  ops(MOV):
  2041          putbyte(16_C7)
  2042          modrmmem(0, base, disp, extdisp )
  2043          norelocateoffset( immed )
  2044                                                         ->break
  2045  ops(ADD):
  2046          subop = 0
  2047          %if (issmall(immed) # 0) %start
  2048              putbyte(16_83)
  2049              modrmmem(subop, base, disp, extdisp )
  2050              putbyte(immed&255)
  2051          %else
  2052              putbyte(16_81)
  2053              modrmmem(subop, base, disp, extdisp )
  2054              norelocateoffset( immed )
  2055          %finish
  2056                                                         ->break
  2057  ops(ADC):
  2058          subop = 2
  2059          %if (issmall(immed) # 0) %start
  2060              putbyte(16_83)
  2061              modrmmem(subop, base, disp, extdisp )
  2062              putbyte(immed&255)
  2063          %else
  2064              putbyte(16_81);
  2065              modrmmem(subop, base, disp, extdisp )
  2066              norelocateoffset( immed )
  2067          %finish
  2068                                                         ->break
  2069  ops(CMP):
  2070          subop = 7
  2071          %if (issmall(immed) # 0) %start
  2072              putbyte(16_83)
  2073              modrmmem(subop, base, disp, extdisp )
  2074              putbyte(immed&255)
  2075          %else
  2076              putbyte(16_81)
  2077              modrmmem(subop, base, disp, extdisp )
  2078              norelocateoffset( immed )
  2079          %finish
  2080                                                         ->break
  2081  ops(SUB):
  2082          subop = 5
  2083          %if (issmall(immed) # 0) %start
  2084              putbyte(16_83)
  2085              modrmmem(subop, base, disp, extdisp )
  2086              putbyte(immed&255)
  2087          %else
  2088              putbyte(16_81)
  2089              modrmmem(subop, base, disp, extdisp )
  2090              norelocateoffset( immed )
  2091          %finish
  2092                                                         ->break
  2093  ops(AND):
  2094          subop = 4
  2095          putbyte(16_81)
  2096          modrmmem(subop, base, disp, extdisp )
  2097          norelocateoffset( immed )
  2098                                                         ->break
  2099  ops(OR):
  2100          subop = 1
  2101          putbyte(16_81)
  2102          modrmmem(subop, base, disp, extdisp )
  2103          norelocateoffset( immed )
  2104                                                         ->break
  2105  ops(XOR):
  2106          subop = 6
  2107          putbyte(16_81)
  2108          modrmmem(subop, base, disp, extdisp )
  2109          norelocateoffset( immed )
  2110                                                         ->break
  2111  ops(SHL):
  2112          subop = 4
  2113          %if (immed = 1) %start
  2114              ! special shift-by-one instruction
  2115              putbyte(16_D1)
  2116              modrmmem(subop, base, disp, extdisp )
  2117          %else
  2118              putbyte(16_C1)
  2119              modrmmem(subop, base, disp, extdisp )
  2120              putbyte(immed)
  2121          %finish
  2122                                                         ->break
  2123  ops(SHR):
  2124          subop = 5
  2125          %if (immed = 1) %start
  2126              ! special shift-by-one instruction
  2127              putbyte(16_D1)
  2128              modrmmem(subop, base, disp, extdisp )
  2129          %else
  2130              putbyte(16_C1)
  2131              modrmmem(subop, base, disp, extdisp )
  2132              putbyte(immed)
  2133          %finish
  2134                                                         ->break
  2135  break:
  2136          listpreamble
  2137          printstring(opname(opn))
  2138          ! otherwise it's ambiguous for the reader
  2139          printstring(" WORD ")
  2140          printmemref(base, disp)
  2141          printsymbol(',')
  2142          write(immed, 0)
  2143          newline
  2144          flushcode
  2145      %end
  2146  
  2147      ! Memory (8 bit) immediate operations - can be MOV, Math, or Shift
  2148      %routine dumpmi8( %integer opn, base, disp, extdisp, immed )
  2149          %integer subop
  2150          %switch ops(MOV:SHR)
  2151  
  2152  		->ops(opn)
  2153  
  2154  ops(MOV):
  2155          subop = 0
  2156          putbyte(16_C6)
  2157          modrmmem(subop, base, disp, extdisp )
  2158          putbyte(immed&255)
  2159                                                         ->break
  2160  ops(ADD):
  2161          subop = 0
  2162          putbyte(16_80)
  2163          modrmmem(subop, base, disp, extdisp )
  2164          putbyte(immed&255)
  2165                                                         ->break
  2166  ops(ADC):
  2167          subop = 2
  2168          putbyte(16_80)
  2169          modrmmem(subop, base, disp, extdisp )
  2170          putbyte(immed&255)
  2171                                                         ->break
  2172  ops(CMP):
  2173          subop = 7
  2174          putbyte(16_80)
  2175          modrmmem(subop, base, disp, extdisp )
  2176          putbyte(immed&255)
  2177                                                         ->break
  2178  ops(SUB):
  2179          subop = 5
  2180          putbyte(16_80)
  2181          modrmmem(subop, base, disp, extdisp )
  2182          putbyte(immed&255)
  2183                                                         ->break
  2184  ops(AND):
  2185          subop = 4
  2186          putbyte(16_80)
  2187          modrmmem(subop, base, disp, extdisp )
  2188          putbyte(immed&255)
  2189                                                         ->break
  2190  ops(OR):
  2191          subop = 1
  2192          putbyte(16_80)
  2193          modrmmem(subop, base, disp, extdisp )
  2194          putbyte(immed&255)
  2195                                                         ->break
  2196  ops(XOR):
  2197          subop = 6
  2198          putbyte(16_80)
  2199          modrmmem(subop, base, disp, extdisp )
  2200          putbyte(immed&255)
  2201                                                         ->break
  2202  ops(SHL):
  2203          subop = 4
  2204          %if (immed = 1) %start
  2205              ! special shift-by-one instruction
  2206              putbyte(16_D0)
  2207              modrmmem(subop, base, disp, extdisp )
  2208          %else
  2209              putbyte(16_C0)
  2210              modrmmem(subop, base, disp, extdisp )
  2211              putbyte(immed)
  2212          %finish
  2213                                                         ->break
  2214  ops(SHR):
  2215          subop = 5
  2216          %if (immed = 1) %start
  2217              ! special shift-by-one instruction
  2218              putbyte(16_D0)
  2219              modrmmem(subop, base, disp, extdisp )
  2220          %else
  2221              putbyte(16_C0)
  2222              modrmmem(subop, base, disp, extdisp )
  2223              putbyte(immed)
  2224          %finish
  2225                                                         ->break
  2226  break:
  2227          listpreamble
  2228          printstring(opname(opn))
  2229          ! otherwise it's ambiguous for the reader
  2230          printstring(" BYTE ")
  2231          printmemref(base, disp)
  2232          printsymbol(',')
  2233          write(immed, 0)
  2234          newline
  2235          flushcode
  2236      %end
  2237  
  2238      ! Finally, a catch-all that recasts operations using generic
  2239      ! Var Stack structures
  2240      ! Plant a 16 bit Reg <- Var operation
  2241      %routine dumprv( %integer opn, reg, %record(stackfm)%name v )
  2242  
  2243          %if (v_form = V in R) %start
  2244              dumprr(opn, reg, v_base)
  2245          %finish %else %if (v_form = V in S) %start
  2246              dumprm(opn, reg, v_base!v_scope, v_disp, v_extdisp )
  2247          %finish %else %if (v_form = constant) %start
  2248              dumprioffset(opn, reg, v_scope, v_disp, v_extdisp )
  2249          %finish %else %start
  2250              abort("Address Mode")
  2251          %finish
  2252      %end
  2253  
  2254      ! Another special dumper - the only "Unary" operation that
  2255      ! takes an immediate operand is PUSH
  2256      %routine dumppushi( %integer reloc, immed, extdisp )
  2257  
  2258  
  2259          ! because we pass around the or-able version
  2260          reloc = reloc >> 4
  2261  
  2262          %if (reloc = 0) %and (is small(immed) # 0) %start
  2263              putbyte(16_6A)
  2264              putbyte(immed&255)
  2265          %else
  2266              putbyte(16_68)
  2267              relocateoffset(reloc, immed, extdisp )
  2268          %finish
  2269  
  2270          listpreamble
  2271          printstring("PUSH")
  2272          space
  2273          %if (reloc # 0) %start
  2274              printstring(relocname(reloc))
  2275              printsymbol('+')
  2276          %finish
  2277          write(immed, 0)
  2278          newline
  2279          flushcode
  2280      %end
  2281  
  2282      %routine dumpvpush(%record(stackfm)%name v)
  2283  
  2284          %if (v_form = V in R) %start
  2285              dumpur(PUSH, v_base)
  2286          %finish %else %if (v_form = V in S) %start
  2287              dumpum(PUSH, v_base!v_scope, v_disp, v_extdisp )
  2288          %finish %else %if (v_form = constant) %start
  2289              dumppushi(v_scope, v_disp, v_extdisp )
  2290          %finish %else %start
  2291              abort("Push Mode")
  2292          %finish
  2293      %end
  2294        
  2295      !----------------------------------------------------------
  2296      ! Floating point instructions - much simpler since there are
  2297      ! only two forms - RR and RM
  2298  
  2299      %conststring(10)%array flopname(FILD:FLDPI) =
  2300+     "FILD", "FLD DWORD", "FLD QWORD", "FISTP",
  2301+     "FSTP DWORD", "FSTP QWORD", "FADDP", "FSUBP",
  2302+     "FSUBRP", "FMULP", "FDIVP", "FDIVRP",
  2303+     "FCOMPP", "FCHS", "FABS",
  2304+     "FSTSW AX", "FLDZ", "FLDPI"
  2305  
  2306      ! The prefix opcode
  2307      %constbyteintegerarray flprefix(FILD:FLDPI) =
  2308+     16_DB, 16_D9, 16_DD, 16_DB,
  2309+     16_D9, 16_DD, 16_DE, 16_DE,
  2310+     16_DE, 16_DE, 16_DE, 16_DE,
  2311+     16_DE, 16_D9, 16_D9,
  2312+     16_DF, 16_D9, 16_D9
  2313  
  2314      ! The function selector to put in the field in the second byte
  2315      ! (or the second byte)
  2316      %constbyteintegerarray flindex(FILD:FLDPI) =
  2317+     16_00, 16_00, 16_00, 16_03,
  2318+     16_03, 16_03, 16_C0, 16_E8,
  2319+     16_E0, 16_C8, 16_F8, 16_F0,
  2320+     16_D8, 16_E0, 16_E1,
  2321+     16_E0, 16_EE, 16_EB
  2322  
  2323      ! Plant a Floating Point Reg <- Memory operation
  2324      ! BASE is an internal ID, not actual register number
  2325      ! Destination register is implicitly the stack top
  2326      %routine dumpfloprm( %integer opn, base, disp, extdisp )
  2327  
  2328          %if (opn <= FLDQ) %start
  2329              ! a load type
  2330              fpu stack = fpu stack + 1
  2331              %if (fpu stack > 8) %then abort("FPU Stack Overflow")
  2332          %else
  2333              fpu stack = fpu stack - 1
  2334              %if (fpu stack < 0) %then abort("FPU Stack Underflow")
  2335          %finish
  2336  
  2337          ! JDM JDM old code used with external 8087 numeric co-processor
  2338  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2339          putbyte(flprefix(opn))
  2340          modrmmem(flindex(opn), base, disp, extdisp )
  2341  
  2342          listpreamble
  2343          printstring(flopname(opn))
  2344          space
  2345          printmemref(base, disp)
  2346          newline
  2347          flushcode
  2348      %end
  2349  
  2350      ! Plant a Floating Point Reg <- Reg operation
  2351      ! Both register parameters are internal ID's that we
  2352      ! convert to stack offsets
  2353      %routine dumpfloprr( %integer opn, reg1, reg2 )
  2354          %integer top
  2355  
  2356          top = fpustack + (FR0 - 1)
  2357  
  2358          %if (reg2 # top) %then abort("FPU Stack Address")
  2359  
  2360          %if (opn < FCHS) %start
  2361              ! two operands - will pop one
  2362              fpu stack = fpu stack - 1
  2363              ! COMPP pops both registers
  2364              %if (opn = FCMP) %then fpu stack = fpu stack - 1
  2365              %if (fpu stack < 0) %then abort("FPU Stack Underflow")
  2366          %finish
  2367  
  2368          ! JDM JDM old code used with external 8087 numeric co-processor
  2369  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2370          putbyte(flprefix(opn))
  2371          putbyte(flindex(opn)!(top - reg1))
  2372  
  2373          listpreamble
  2374          printstring(flopname(opn))
  2375          space
  2376          printstring("ST(")
  2377          write(top-reg1, 0)
  2378          printstring("),ST")
  2379          newline
  2380          flushcode
  2381      %end
  2382  
  2383      ! Plant a "special" floating point operation
  2384      %routine dumpflopspec(%integer opn)
  2385  
  2386          %if (opn >= FLDZ) %start
  2387              ! load a constant
  2388              fpu stack = fpu stack + 1
  2389              %if (fpu stack > 8) %then abort("FPU Stack Overflow")
  2390          %finish
  2391  
  2392          ! JDM JDM old code used with external 8087 numeric co-processor
  2393  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2394          putbyte(flprefix(opn));
  2395          putbyte(flindex(opn))
  2396  
  2397          listpreamble
  2398          printstring(flopname(opn))
  2399          newline
  2400          flushcode
  2401      %end
  2402  
  2403      %routine dumpjump( %integer opn, labelid )
  2404          ! we put conventional assembler into the pipe for the listing
  2405          ! (with a zero jump offset) but then re-use the pipe for the
  2406          ! pseudo-code for the jump
  2407          putbyte(opvalue(opn))
  2408          putbyte(0)
  2409          %if (opn = CALL) %then putbyte(0)
  2410  
  2411          listpreamble
  2412          printstring(opname(opn))
  2413          space
  2414          { JDM JDM start new code }
  2415          %if (opn = CALL) %start
  2416              ! JDM JDM See if we can show the routine name
  2417              printstring("'".var(top_var no)_idname."' (INTERNAL ")
  2418              printsymbol('L')
  2419              write(labelid,0)
  2420              printstring(" )")
  2421          %else
  2422              printsymbol('L')
  2423              write(labelid,0)
  2424          %finish
  2425          { JDM JDM end new code }
  2426          newline
  2427  
  2428  		! zap the current contents of the pipe
  2429          ClearObjectBuffer
  2430          %if (opn = JMP) %start
  2431  			putcodebyte( labelid&255 )
  2432  			putcodebyte( labelid >> 8 )
  2433  			writeifrecord(IF JUMP, 2, objectbytes)
  2434  
  2435              ! zap the current contents of the pipe
  2436  			ClearObjectBuffer
  2437          %finish %else %if (opn = CALL) %start
  2438  ! JDM replaced use of IF CALL command by IF REFLABEL command
  2439  ! old code retained Just-in-case
  2440  !           ! Generated code using IF CALL ibj command
  2441  !           putcodebyte( labelid&255 )
  2442  !           putcodebyte( labelid >> 8 )
  2443  !           writeifrecord(IF CALL, 2, objectbytes)
  2444  !            ! zap the current contents of the pipe
  2445  !           ClearObjectBuffer
  2446  
  2447              ! JDM JDM Generated code using IF REFLABEL ibj command
  2448              ! plant the CALL code
  2449              ! call with relative address
  2450              putcodebyte( 16_E8 )
  2451              writeifrecord(IF OBJ, 1, objectbytes)
  2452  
  2453              ! zap the current contents of the pipe
  2454              ClearObjectBuffer
  2455              ! plant the relative address of the label
  2456              putcodebyte( labelid&255 )
  2457              putcodebyte( labelid >> 8 )
  2458  
  2459              ! JDM set offset to zero
  2460              putcodebyte(0)
  2461              putcodebyte(0)
  2462              writeifrecord(IF REFLABEL, 4, objectbytes)
  2463  
  2464              ! zap the current contents of the pipe
  2465              ClearObjectBuffer
  2466          %finish %else %start
  2467              ! not an unconditional JMP or a CALL
  2468              ! assume it is a conditional JMP (i.e. JE,JNE, etc.)
  2469              putcodebyte(opn - JE)
  2470              putcodebyte( labelid&255 )
  2471              putcodebyte( labelid >> 8 )
  2472              writeifrecord(IF JCOND, 3, objectbytes)
  2473  
  2474              ! zap the current contents of the pipe
  2475              ClearObjectBuffer
  2476          %finish
  2477  
  2478          ! finally, calls may trash registers...
  2479          %if (opn = CALL) %start
  2480              displayhint(BX) = 0
  2481              displayhint(SI) = 0
  2482              displayhint(DI) = 0
  2483          %finish
  2484      %end
  2485  
  2486      ! call the n'th external routine we've spec'ed
  2487      %routine dumpextcall(%integer labelid)
  2488  
  2489          displayhint(BX) = 0
  2490          displayhint(SI) = 0
  2491          displayhint(DI) = 0
  2492  
  2493          ! plant the "CALL" instruction
  2494          putbyte(opvalue(CALL))
  2495          flushcode
  2496  
  2497          putbyte( labelid&255 )
  2498          putbyte( labelid >> 8 )
  2499          listpreamble
  2500          ! JDM JDM attempt to show external routine name
  2501          printstring("CALL ")
  2502          %if (labelid <= lastperm) %start
  2503              ! This is an internal "perm" routine
  2504              ! So, show the name
  2505              printstring("'".permname(labelid)."'")
  2506          %else
  2507              ! JDM JDM this is an external routine
  2508              printstring("'".var(top_var no)_idname."'")
  2509          %finish
  2510          printstring(" (EXTERN ")
  2511          write(labelid,0)
  2512          printstring(")")
  2513          newline
  2514          ! JDM JDM end attempt
  2515  
  2516          writeifrecord(IF REFEXT, word size, objectbytes)
  2517  !        writeifrecord(IF REFEXT, 2, objectbytes)
  2518  
  2519          ! zap the current contents of the pipe
  2520          ClearObjectBuffer
  2521      %end
  2522  
  2523      %routine dumplabel(%integer labelid)
  2524  
  2525          select output(listout)
  2526          space
  2527          writehex(nextcad, 4)
  2528          spaces(22)
  2529          printsymbol('L')
  2530          write(labelid,0)
  2531          printstring("  EQU $")
  2532          newline
  2533  
  2534          ! zap the current contents of the pipe
  2535          ClearObjectBuffer
  2536  
  2537  		putcodebyte(labelid & 255)
  2538  		putcodebyte(labelid >> 8)
  2539          writeifrecord(IF LABEL, 2, objectbytes)
  2540  
  2541          ! zap the current contents of the pipe
  2542          ClearObjectBuffer
  2543  
  2544          displayhint(BX) = 0
  2545          displayhint(SI) = 0
  2546          displayhint(DI) = 0
  2547      %end
  2548  
  2549      %routine dumpstaticalloc(%integer which, level, %string(255)%name name)
  2550          %integer i, len
  2551          ! we pretend to dump "C8 00 00 lev  ENTER 0000,lev"
  2552          ! but we actually plant a special pass 2 directive
  2553  
  2554          putbyte(16_C8)
  2555          putbyte(16_00)
  2556          putbyte(16_00)
  2557          putbyte(level)
  2558          listpreamble
  2559          printstring("ENTER 0000,")
  2560          write(level,0)
  2561          newline
  2562  
  2563          ! zap the current contents of the pipe
  2564          ClearObjectBuffer
  2565  		putcodebyte( which&255 )
  2566  		putcodebyte( which >> 8 )
  2567  		putcodebyte( level )
  2568  
  2569          ! we also pass the (truncated) name of the routine
  2570          !  - for pass3 diagnostic use
  2571  
  2572          len = length(name)
  2573          %if (len > 16) %then len = 16
  2574          %for i=1,1,len %cycle
  2575              putcodebyte(charno(name,i))
  2576          %repeat
  2577          writeifrecord(IF FIXUP, len+3, objectbytes)
  2578          ! zap the current contents of the pipe
  2579          ClearObjectBuffer
  2580      %end
  2581  
  2582      ! Pass 3 goes back and plants the correct preamble code for
  2583      ! the static allocation based on this directive, and also fills
  2584      ! in the event trap block as appropriate
  2585      %routine dumpstaticfill(%integer which, size, events, evep, evfrom)
  2586  
  2587          ! zap the current contents of the pipe
  2588          ClearObjectBuffer
  2589  
  2590          putcodebyte( which& 255 )
  2591          putcodebyte( which >> 8 )
  2592  
  2593          putcodebyte( size& 255 )
  2594          putcodebyte( size >> 8 )
  2595  
  2596          putcodebyte( events& 255 )
  2597          putcodebyte( events >> 8 )
  2598  
  2599          putcodebyte( evep&255 )
  2600          putcodebyte( evep >> 8 )
  2601  
  2602          putcodebyte( evfrom&255 )
  2603          putcodebyte(evfrom >> 8)
  2604  
  2605          writeifrecord(IF SETFIX, 10, objectbytes)
  2606  
  2607          ! zap the current contents of the pipe
  2608          ClearObjectBuffer
  2609      %end
  2610  
  2611      ! dump words for the constant segment or the data segment
  2612      ! Adjusts CAD so that the diagnostic listing looks sensible
  2613      %routine dumpcdword( %integer word, which )
  2614  
  2615          %integer tag, tmpcad, hi, lo
  2616          %owninteger cptr = 0
  2617          %owninteger dptr = 0
  2618          %owninteger sptr = 0
  2619  
  2620          tmpcad = next cad
  2621          %if (which = 2) %start
  2622              tag = IF SWTWORD
  2623              next cad = sptr
  2624              sptr = sptr + 2
  2625          %finish %else %if (which = 1) %start
  2626              tag = IF COTWORD
  2627              next cad = cptr
  2628              cptr = cptr + 2
  2629          %finish %else %start
  2630              tag = IF DATWORD
  2631              next cad = dptr
  2632              dptr = dptr + 2
  2633          %finish
  2634  
  2635          hi = word >> 8
  2636          lo = word&255
  2637          putbyte(lo)
  2638          putbyte(hi)
  2639          listpreamble
  2640          printstring("db ")
  2641          writehex(lo, 2)
  2642          printsymbol(',')
  2643          writehex(hi, 2)
  2644          printstring(" ; ")
  2645          %if (32 < lo < 127) %then printsymbol(lo) %else printsymbol('.')
  2646          %if (32 < hi < 127) %then printsymbol(hi) %else printsymbol('.')
  2647          newline
  2648          writeifrecord(tag, 2, objectbytes)
  2649  
  2650          ! clear the pipe
  2651          ClearObjectBuffer
  2652  
  2653          ! restore the real CAD
  2654          nextcad = tmp cad
  2655      %end
  2656  
  2657      ! tell the object file maker what source line we are on
  2658      %routine dumplinenumber(%integer line)
  2659  
  2660          %byteintegerarray buffer(0:1)
  2661  
  2662          buffer(0) = (line&255)
  2663          buffer(1) = (line >> 8)
  2664          writeifrecord(IF LINE, 2, buffer)
  2665  
  2666      %end
  2667  
  2668      ! utility to copy an IMP string into a simple buffer to
  2669      ! pass to the IF Record routine
  2670      %routine str to xsym(%string(255)%name s)
  2671          %integer l
  2672  
  2673          l = length(s)
  2674          xlen = 0
  2675          %while xlen < l %cycle
  2676              x sym buff(xlen) = charno(s, xlen+1)
  2677              xlen = xlen + 1
  2678          %repeat
  2679      %end
  2680  
  2681      ! tell the object maker the source file name
  2682      %routine dumpsourcename(%string(255) filename)
  2683  
  2684          str to xsym(filename)
  2685          writeifrecord(IF SOURCE, xlen, x sym buff)
  2686  
  2687      %end
  2688  
  2689      ! Plant a request to the linker for the external name, and
  2690      ! return an index number to refer to it with in future
  2691      %integerfn externalref(%string(255) extname)
  2692          %owninteger nextextref=1
  2693  
  2694          str to xsym(extname)
  2695          writeifrecord(IF REQEXT, xlen, x sym buff)
  2696          nextextref = nextextref + 1
  2697          %result = nextextref - 1
  2698      %end
  2699  
  2700      ! tell the linker about an external definition
  2701      %routine fill external(%integer seg, offset, %string(255) extname)
  2702  
  2703          str to xsym(extname)
  2704          %if (seg = CODE) %start
  2705              writeifrecord(IF DEFEXTCODE, xlen, x sym buff)
  2706          %else
  2707              writeifrecord(IF DEFEXTDATA, xlen, x sym buff)
  2708              ! JDM JDM pass3 amended to allow external data
  2709          %finish
  2710      %end
?OFFSET unused
  2711  
  2712      !------------------------------------------------------
  2713      ! Constant table utility routines
  2714      !
  2715      ! Rather than dump literal constants as they occur, we
  2716      ! collect them in a table.  Whenever the compiler wants
  2717      ! any kind of literal, we look to see if we already
  2718      ! have it.  Note this automatically solves re-use of
  2719      ! things like floating point constants, string newline,
  2720      ! and fixed array dope vectors.  When the table starts
  2721      ! to get fairly full, we flush it.  Obviously that means
  2722      ! in a large program we might not actually get full re-use
  2723      ! of constants after we've flushed, but the idea is sound.
  2724      !
  2725      ! For the convenience of the caller, several versions of
  2726      ! pretty much the same thing are provided.
  2727      !------------------------------------------------------
  2728      %constinteger cot size = 2000
  2729      %ownbyteintegerarray contable(0:cot size)
  2730      %owninteger cotp = 0
  2731  
  2732      ! updated on a flush
  2733      %owninteger cotoffset = 0
  2734  
  2735      %routine flushcot
  2736          %integer i
  2737  
  2738          ! We output a position hint to the diagnostic stream
  2739          ! Note that although this is intended to look like
  2740          ! 8086 assembly directives the real work is done by
  2741          ! pass 3 - this is only to guide the human reader as
  2742          ! to what is going on
  2743  
  2744          selectoutput(listout)
  2745          printstring("      _TEXT  ENDS")
  2746          newline
  2747          printstring("      CONST  SEGMENT WORD PUBLIC 'CONST'")
  2748          newline
  2749  
  2750          i = 0
  2751          %while i < cotp %cycle
  2752              dumpcdword((contable(i+1) << 8) ! contable(i), 1)
  2753              i = i + 2
  2754          %repeat
  2755  
  2756          ! Update the pointers
  2757          cotp = 0
  2758          cotoffset = cotoffset + i
  2759  
  2760          ! and send another hint
  2761          selectoutput(listout)
  2762          printstring("      CONST  ENDS")
  2763          newline
  2764          printstring("      _TEXT  SEGMENT WORD PUBLIC 'CODE'")
  2765          newline
  2766  
  2767      %end
  2768  
  2769      ! return the offset in the const segment of a byte
  2770      ! with value b
  2771      %integerfn getcotb(%byteinteger b)
  2772          %integer i
  2773  
  2774          i = 0
  2775          %while (i < cotp) %cycle
  2776              %if (contable(i) = b) %then %result = i + cotoffset
  2777              i = i + 1
  2778          %repeat
  2779  
  2780          ! value wasn't there
  2781          %if (cotp = cotsize) %then flushcot
  2782  
  2783          contable(cotp) = b
  2784          cotp = cotp + 1
  2785          %result = (cotp - 1) + cotoffset
  2786      %end
  2787  
  2788      ! return the offset in the const segment of a word
  2789      ! with value w
  2790      %integerfn getcotw(%integer w)
  2791          %integer i, cw
  2792  
  2793          i = 0
  2794          %while (i < cotp-3) %cycle
  2795              cw = 0
  2796              cw = cw!(contable(i)<<0)
  2797              cw = cw!(contable(i+1)<<8)
  2798              cw = cw!(contable(i+2)<<16)
  2799              cw = cw!(contable(i+3)<<24)
  2800              %if (cw = w) %then %result = i + cotoffset
  2801              i = i + word size
  2802          %repeat
  2803  
  2804          ! value wasn't there - first make sure there is space
  2805          %if (cotp > cotsize-word size) %then flushcot
  2806  
  2807          ! now round off the COT
  2808          cotp = (cotp + align) & (\align)
  2809  
  2810          %for i=1,1,word size %cycle
  2811              contable(cotp) = w&255
  2812              w = w >> 8
  2813              cotp = cotp + 1
  2814          %repeat
  2815  
  2816          %result = (cotp - word size) + cotoffset
  2817      %end
  2818  
  2819      ! return the offset in the const segment of double precision real number
  2820      %integerfn getcotdouble( %longreal double )
  2821          %integer i
  2822  
  2823          i = 0
  2824          %while (i < cotp-7) %cycle
  2825              %if      (contable(i)   = byteinteger(addr(double)))   %c
  2826+                 %and (contable(i+1) = byteinteger(addr(double)+1)) %c
  2827+                 %and (contable(i+2) = byteinteger(addr(double)+2)) %c
  2828+                 %and (contable(i+3) = byteinteger(addr(double)+3)) %c
  2829+                 %and (contable(i+4) = byteinteger(addr(double)+4)) %c
  2830+                 %and (contable(i+5) = byteinteger(addr(double)+5)) %c
  2831+                 %and (contable(i+6) = byteinteger(addr(double)+6)) %c
  2832+                 %and (contable(i+7) = byteinteger(addr(double)+7)) %c
  2833+             %then %result = i + cotoffset
  2834              i = i + 4
  2835          %repeat
  2836  
  2837          ! value wasn't there - first make sure there is space
  2838          %if (cotp > cotsize-8) %then flushcot
  2839  
  2840          ! now round off the COT
  2841          cotp = (cotp + align) & (\align)
  2842  
  2843          %for i=0,1,7 %cycle
  2844              contable(cotp) = byteinteger(addr(double)+i)
  2845              cotp = cotp + 1
  2846          %repeat
  2847  
  2848          %result = (cotp - 8) + cotoffset
  2849      %end
  2850  
  2851      ! return the offset in the const segment of a quad word
  2852      ! with value q0:q1:q2:q3 (lo to hi)
  2853      %integerfn getcot4(%integer q0, q1, q2, q3)
  2854          %integer i, cw0, cw1, cw2, cw3
  2855  
  2856          i = 0
  2857          cw0 = 0
  2858          cw0 = cw0!(contable(i+0)<<0)
  2859          cw0 = cw0!(contable(i+1)<<8)
  2860          cw0 = cw0!(contable(i+2)<<16)
  2861          cw0 = cw0!(contable(i+3)<<24)
  2862  
  2863          cw1 = 0
  2864          cw1 = cw1!(contable(i+4)<<0)
  2865          cw1 = cw1!(contable(i+5)<<8)
  2866          cw1 = cw1!(contable(i+6)<<16)
  2867          cw1 = cw1!(contable(i+7)<<24)
  2868  
  2869          cw2 = 0
  2870          cw2 = cw2!(contable(i+8)<<0)
  2871          cw2 = cw2!(contable(i+9)<<8)
  2872          cw2 = cw2!(contable(i+10)<<16)
  2873          cw2 = cw2!(contable(i+11)<<24)
  2874          %while i < cotp-15 %cycle
  2875              cw3 = 0
  2876              cw3 = cw3!(contable(i+12)<<0)
  2877              cw3 = cw3!(contable(i+13)<<8)
  2878              cw3 = cw3!(contable(i+14)<<16)
  2879              cw3 = cw3!(contable(i+15)<<24)
  2880  
  2881              %if      (cw0 = q0) %c
  2882+                 %and (cw1 = q1) %c
  2883+                 %and (cw2 = q2) %c
  2884+                 %and (cw3 = q3) %then %result = i + cotoffset
  2885              i = i + word size
  2886              cw0 = cw1
  2887              cw1 = cw2
  2888              cw2 = cw3
  2889          %repeat
  2890  
  2891          ! value wasn't there - first make sure there is space
  2892          %if (cotp > cotsize - 16) %then flushcot
  2893  
  2894          ! now round off the COT
  2895          cotp = (cotp + align) & (\align)
  2896  
  2897          %for i=1,1,word size %cycle
  2898              contable(cotp) = q0&255
  2899              q0 = q0 >> 8
  2900              cotp = cotp + 1
  2901          %repeat
  2902  
  2903          %for i=1,1,word size %cycle
  2904              contable(cotp) = q1&255
  2905              q1 = q1 >> 8
  2906              cotp = cotp + 1
  2907          %repeat
  2908  
  2909          %for i=1,1,word size %cycle
  2910              contable(cotp) = q2&255
  2911              q2 = q2 >> 8
  2912              cotp = cotp + 1
  2913          %repeat
  2914  
  2915          %for i=1,1,word size %cycle
  2916              contable(cotp) = q3&255
  2917              q3 = q3 >> 8
  2918              cotp = cotp + 1
  2919          %repeat
  2920  
  2921          %result = (cotp - 16) + cotoffset
  2922      %end
  2923  
  2924      %owninteger null string = -1
  2925  
  2926      ! get an index into the constant table for the string literal
  2927      ! in the array s
  2928      %integerfn getcots( %byteintegerarrayname b )
  2929          %integer i, first, slen, match
  2930  
  2931  		slen = b(0)
  2932  
  2933          ! We optimise the Null String "" in comparisons, so we remember
  2934          ! the location here
  2935          %if (slen = 0) %start
  2936              null string = getcotb(0)
  2937              %result = null string
  2938          %finish
  2939  
  2940          ! offset to search in contable
  2941          first = 0
  2942  
  2943          %while (first + slen < cotp) %cycle
  2944              ! so long as there are that many bytes left
  2945              match = 1
  2946  			! Simple check of string lengths
  2947              %if (slen # contable(first)) %start
  2948                  match = 0
  2949                  %exit
  2950              %finish
  2951  			! ok, so lengths match but do the contents
  2952              %for i = 1, 1, slen %cycle
  2953                  %if (b(i) # contable(first + i)) %start
  2954                      match = 0
  2955                      %exit
  2956                  %finish
  2957              %repeat
  2958              %if (match = 1) %then %result = first + cotoffset
  2959  
  2960              ! try the next solution
  2961              first = first + 1
  2962          %repeat
  2963  
  2964          ! if we get here, it wasn't already in the constant table
  2965  		! Ok, so will we overflow the buffer
  2966          %if (cotp + slen + 1) >= cotsize %then flushcot
  2967  
  2968  		! dump the string length
  2969          first = cotp
  2970          contable(cotp) = slen
  2971          cotp = cotp + 1
  2972  		! Now, dump the string contents
  2973  		%for i = 1,1,slen %cycle
  2974              contable(cotp) = b(i)
  2975              cotp = cotp + 1
  2976          %repeat
  2977          %result = first + cotoffset
  2978      %end
  2979  
  2980      !------------------------------------------------------
  2981      ! Data segment utility routines
  2982      !
  2983      ! Unlike constants, we can't re-use data segment items,
  2984      ! which makes this much simpler.  We still accumulate
  2985      ! the bytes in a table because (1) we can make life
  2986      ! more efficient for Pass 3 that way and (2) by collecting
  2987      ! the bytes together we can produce more convincing debug
  2988      ! code listings, especially for programs that don't need
  2989      ! to flush the table in the middle of the code.
  2990      ! Note that because data segment offsets are used directly
  2991      ! as variable displacements, our pointer DATATP doesn't
  2992      ! wrap like the COTP does, and instead we subtract the
  2993      ! offset before we use it...
  2994      !------------------------------------------------------
  2995  
  2996      ! Size in bytes of data segment table
  2997      %constinteger datat limit = 1999
  2998      %byteintegerarray datat(0:datat limit)
  2999  
  3000      ! pointer to next data segment byte
  3001      %owninteger datatp = 0
  3002  
  3003      ! updated on a flush
  3004      %owninteger datat offset = 0
  3005  
  3006      ! Flush the accumulated data table
  3007      %routine flush data
  3008          %integer i, limit
  3009  
  3010          ! We output a position hint to the diagnostic stream
  3011  
  3012          selectoutput(listout)
  3013          printstring("            ENDS")
  3014          newline
  3015          printstring("      DATA  SEGMENT WORD PUBLIC 'DATA'")
  3016          newline
  3017  
  3018          i = 0
  3019          limit = datatp - datat offset
  3020          %while i < limit %cycle
  3021              ! JDM JDM DANGER ! in line below is a Bitwise OR not a comment
  3022              dumpcdword((datat(i+1) << 8) ! datat(i), 0)
  3023              i = i + 2;
  3024          %repeat
  3025  
  3026          datat offset = datat p
  3027  
  3028          ! and send another hint
  3029          selectoutput(listout)
  3030          printstring("      DATA    ENDS")
  3031          newline
  3032      %end
  3033  
  3034      !                                                  >> GBYTE <<
  3035      ! Simple byte in data segment
  3036      %routine  gbyte(%integer  n)
  3037  
  3038          flush data %if (datatp - datat offset > datat limit)
  3039          datat(datatp - datat offset) = n & 255;
  3040          datatp = datatp + 1
  3041      %end
  3042  
  3043      !                                                  >> GPUT <<
  3044      ! Put a word into data segment
  3045      %routine  gput(%integer  n)
  3046          %integer i
  3047  
  3048          %for i=1,1,word size %cycle
  3049              gbyte(n)
  3050              n = n >> 8;
  3051          %repeat
  3052      %end
  3053  
  3054      !                                                  >> GFIX <<
  3055      ! round off the data-segment pointer for alignment
  3056      %routine  gfix(%integer align)
  3057          gbyte(0) %while (datatp&align # 0)
  3058      %end
  3059  
  3060      !-----------------------------------------------------
  3061      ! The last table we collect as we go along is the switch
  3062      ! table.  We don't provide individual routines to fill
  3063      ! it in, but for neatness we provide this routine to send
  3064      ! the contents to pass 3
  3065  
  3066      %routine flush switch
  3067          %integer i
  3068  
  3069          select output(listout)
  3070          printstring("              ENDS")
  3071          newline
  3072          printstring("      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'")
  3073          newline
  3074          i = 0
  3075          %while i < swtp %cycle
  3076              dumpcdword(swtab(i), 2)
  3077              i = i + 1
  3078          %repeat
  3079  
  3080          ! and send another hint
  3081          selectoutput(listout)
  3082          printstring("      _SWTAB   ENDS")
  3083          newline
  3084      %end
  3085  
  3086      !-------------------------------------------------------------
  3087      ! Print the source code lines up to the indicated line
  3088      ! number - these will interleave with the diagnostic assembly
  3089      ! output
  3090      %owninteger echoline = 0
  3091  
  3092      %routine echo source line
  3093          %integer ch
  3094          %owninteger source eof = 0
  3095  
  3096          ! update the count even if there's no input
  3097          echoline = echoline + 1
  3098  
  3099          ! silently ignore lack of source file
  3100          %if (source eof # 0) %then %return
  3101  
  3102          select input(source)
  3103          select output(listout)
  3104          %cycle
  3105              readsymbol(ch)
  3106              printsymbol(ch)
  3107              %exit %if (ch = 10) %or (ch < 0)
  3108          %repeat
  3109  
  3110          %if (ch < 0) %then source eof = 1
  3111  
  3112          select input(icode)
  3113          select output(objout)
  3114      %end
  3115  
  3116      !-----------------------------------------------------------
  3117      ! General descriptor and register manipulation routines
  3118      !-----------------------------------------------------------
  3119  
  3120      !                                                  >> FLOATING <<
  3121      %integerfn  floating( %record(stackfm)%name v )
  3122          ! check descriptor for floating point quantity
  3123          %result = 1 %if (v_type = real)
  3124          %result = 1 %if (v_type = lreal)
  3125          %result = 0
  3126      %end
  3127  
  3128      !                                                  >> ZERO <<
  3129      %integerfn  zero( %record(stackfm)%name  v )
  3130          ! CHECK DESCRIPTOR FOR (INTEGER) ZERO
  3131          ! JDM JDM sequence of %result = 0 %if is equivalent to %or sequence
  3132          %result = 0 %if (v_disp # 0)
  3133          %result = 0 %if (v_base # 0)
  3134          %result = 0 %if ((v_form # constant) %and (v_form # A V in S))
  3135          %result = 1
  3136      %end
  3137  
  3138      !                                                  >> CONST <<
  3139      %integerfn  const( %record(stackfm)%name  v )
  3140          ! CHECK DESCRIPTOR FOR CONSTANT (INTEGER) VALUE
  3141          %result = 0 %unless (v_form = constant)
  3142          %result = 0 %if (v_type > byte)
  3143          %result = 1
  3144      %end
  3145  
  3146      %integerfn Min Record Size( %record(stackfm)%name A, B )
  3147          %integer N, M
  3148          N = A_format
  3149          N = var(N)_size&16_7FFF %if (N # 0)
  3150          M = B_format
  3151          M = var(M)_size&16_7FFF %if (M # 0)
  3152          N = M %if (N = 0) %or ((M # 0) %and (M < N))
  3153          %result = N %if (N > 0)
  3154          Abort("Min Rec Size")
  3155      %end
  3156  
  3157      !                                                  >> MULSHIFT <<
  3158      %integerfn mulshift( %integer n )
  3159          %integer shift, ref
  3160          ref = 1
  3161          %for shift = 1, 1, 14 %cycle
  3162              ref = ref<<1
  3163              %if (ref >= n) %start
  3164                  %if (ref = n) %then %result = shift %else %result = -1
  3165              %finish
  3166          %repeat
  3167          %result = -1
  3168      %end
  3169  
  3170      !                                                  >> SAME <<
  3171      %integerfn  same( %record(stackfm)%name  v,w )
  3172          ! Test whether or not V and W describe the same object.
  3173          ! JDM JDM code altered avoid %or to become simple test
  3174          %result = 0 %if (v_disp # w_disp)
  3175          %result = 0 %if (v_base # w_base)
  3176  
  3177          %result = 0 %if (v_type # w_type)
  3178          %result = 0 %if (v_form # w_form)
  3179  
  3180          %result = 0 %if (v_extra # w_extra)
  3181          %result = 0 %if (v_scope # w_scope)
  3182  
  3183          %result = 1
  3184      %end
  3185  
  3186      ! grab a slab of working store in the local stack
  3187      %integerfn getwork(%integer size)
  3188          %integer cell
  3189  
  3190          cell = worklist(level)
  3191          %while (cell # 0) %cycle
  3192              %if      (gp tags(cell)_info = size) %c
  3193+                 %and (gp tags(cell)_flags = 0) %start
  3194                  ! suitable candidate?
  3195                  ! mark it as in use
  3196                  gp tags(cell)_flags = 1
  3197                  %result = gp tags(cell)_addr
  3198              %finish
  3199              cell = gp tags(cell)_link
  3200          %repeat
  3201  
  3202          ! no space available already - make more
  3203          cell = get gp tag
  3204  
  3205          ! make them all even boundaries
  3206          frame = (frame - size) & (\align)
  3207          gp tags(cell)_addr = frame
  3208          gp tags(cell)_info = size
  3209          gp tags(cell)_link = worklist(level)
  3210          worklist(level) = cell
  3211  
  3212          ! in use
  3213          gp tags(cell)_flags = 1
  3214          %result = frame
  3215      %end
  3216  
  3217      ! Return a slab of working store to the free pool
  3218      ! Note that ReturnWork is cautious about what it accepts
  3219      ! - it only takes in items it has previously given out,
  3220      !   so we can call it fairly liberally with any old
  3221      !   rubbish and it will do the right thing
  3222      %routine Return Work( %integer addr )
  3223          %integer cell
  3224  
  3225          cell = worklist(level)
  3226          %while (cell # 0) %cycle
  3227              %if (gp tags(cell)_addr = addr) %start
  3228                  %if (gp tags(cell)_flags = 0) %then abort("Return Work")
  3229  
  3230                  ! mark it as free
  3231                  gp tags(cell)_flags = 0
  3232                  %return
  3233              %finish
  3234              cell = gp tags(cell)_link
  3235          %repeat
  3236  
  3237          ! Here, work area was not found - it probably wasn't a work area!
  3238      %end
  3239  
  3240      ! Check to see if a variable is in a work list assigned block.
  3241      ! Used in string expression compilation to avoid un-necessary copying,
  3242      ! hence only marked true for 256 byte chunks
  3243      %integerfn Is Work( %record(stackfm)%name v )
  3244          %integer cell
  3245  
  3246          ! JDM JDM replaced long %or test sequence by individual tests
  3247          ! order of tests could be altered for speed
  3248          %result = 0 %if (v_base # BP)
  3249          %result = 0 %if (v_disp >= 0)
  3250          %result = 0 %if (v_scope # 0)
  3251          %result = 0 %if (v_form # V in S)
  3252  
  3253          cell = worklist(level);
  3254          %while (cell # 0) %cycle
  3255              %if (gp tags(cell)_addr = v_disp) %start
  3256                  %if (gp tags(cell)_flags = 0) %then abort("Is Work")
  3257                  %if (gp tags(cell)_info # 256) %then %result = 0
  3258                  %result = 1
  3259              %finish
  3260              cell = gp tags(cell)_link
  3261          %repeat
  3262  
  3263          %result = 0
  3264      %end
  3265  
  3266      !                                                  >> RELEASE <<
  3267      %routine  release( %integer  reg )
  3268          ! Hazard the value in a register
  3269  
  3270          ! JDM JDM replaced long %or test sequence by individual tests
  3271          ! order of tests could be altered for speed
  3272          ! check if LOCKED
  3273          %return %if (reg = 0)
  3274          %return %if (reg > fr7)
  3275          %return %if (activity(reg) < 0)
  3276  
  3277          activity(reg) = activity(reg)-1
  3278          abort("Release inactive") %if (activity(reg) < 0)
  3279          claimed = claimed - 1
  3280      %end
  3281  
  3282      !                                                  >> CLAIM <<
  3283      %routine  claim( %integer  reg )
  3284          ! Cherish the value in a register
  3285          abort("Claim bad register") %if (reg > fr7)
  3286  
  3287          ! JDM JDM replaced long %or test sequence by individual tests
  3288          ! order of tests could be altered for speed
  3289  
  3290          %return %if (reg = 0)
  3291          %return %if (activity(reg) < 0)
  3292  
  3293          activity(reg) = activity(reg)+1
  3294          claimed = claimed+1
  3295      %end
  3296  
  3297      !                                                  >> HAZARD <<
  3298      ! Protect any value in register REG by storing in a temporary.
  3299      %routine  hazard( %integer  reg )
  3300          %integer  i, n, t, type
  3301  
  3302          %routine  mod(%record(stackfm)%name  v)
  3303              %switch  sw(0:a in rec)
  3304              v_base = BP
  3305              n = n-1
  3306              -> sw(v_form)
  3307  sw(a in rec):
  3308  sw(av in rec):
  3309  sw(v in rec):
  3310  sw(constant):
  3311              abort("Mod")
  3312  sw(v in s):
  3313              %if (v_disp = 0) %and (v_scope = 0) %start
  3314                  v_disp = t
  3315                  v_form = a in s
  3316              %else
  3317                  !  change (X in S) to (X in REC)
  3318                  v_form = v_form + 3
  3319                  v_extra = t
  3320              %finish
  3321                                                         -> out1
  3322  sw(a in s):
  3323  sw(av in s):
  3324              !  change (X in S) to (X in REC)
  3325              v_form = v_form + 3
  3326              v_extra = t
  3327                                                         -> out1
  3328  sw(v in r):
  3329              v_form = v in s
  3330              v_disp = t
  3331              v_type = type
  3332                                                         -> out1
  3333  out1:
  3334          %end
  3335  
  3336          n = activity(reg)
  3337  
  3338          ! NOT IN USE OR CLAIMED?
  3339          %return %if (n <= 0)
  3340          claimed = claimed - n
  3341          activity(reg) = 0
  3342          %if (reg >= fr0) %start
  3343              ! Note that the FPU can only save the top of the stack.
  3344              ! If we need to save something lower down,
  3345              ! we need to pop the things above me first...
  3346              ! and recurse as required
  3347              %if (reg - FR0 >= FPU Stack) %then hazard(reg+1)
  3348              type = lreal
  3349              t = getwork(8)
  3350              dumpfloprm(FSTQ, BP, t, 0)
  3351          %else
  3352              type = integer
  3353              t = getwork(word size)
  3354              dumpmr(MOV, BP,t, 0, reg)
  3355          %finish
  3356          %for i = 1, 1, stp %cycle
  3357              mod(stack(i)) %if (stack(i)_base = reg)
  3358          %repeat
  3359  
  3360          ! USE STILL OUTSTANDING?
  3361          abort("Usage Outstanding") %if (n # 0)
  3362      %end
  3363  
  3364      !                                                  >> HAZARD ALL <<
  3365      %routine  hazard all
  3366          %integer  j
  3367  
  3368          %if (claimed # 0) %start
  3369              ! at least one register claimed
  3370              hazard(j) %for j = AX,1,FR7
  3371          %finish
  3372      %end
  3373  
  3374      !                                                  >> GP REG <<
  3375      ! Get a general (integer) register
  3376      ! Note that registers AX, CX, DX, BX are, in order
  3377      ! numbers 1, 2, 3 and 4 (which is convenient)
  3378      %integerfn  gpreg
  3379          %integer  r
  3380  
  3381          ! look for an empty one
  3382          %for r = AX,1,BX %cycle
  3383              %result = r %if (activity(r) = 0)
  3384          %repeat
  3385  
  3386          ! look for an unlocked one
  3387          %for r = AX,1,BX %cycle
  3388              %if (activity(r) > 0) %start
  3389                  hazard(r)
  3390                  %result = r
  3391              %finish
  3392          %repeat
  3393  
  3394          abort("Get Reg")
  3395      %end
  3396  
  3397      !                                                  >> PT REG <<
  3398      %integerfn  pt reg
  3399          ! Get a register we can use as a pointer.
  3400          ! We deliberately rotate around the candidates
  3401          ! - to make re-use more likely
  3402          %constbyteintegerarray  pt pref(0:2) =
  3403+            7,  8,  4
  3404          ! SI, DI, BX
  3405          %owninteger next = 0
  3406          %integer  r,j
  3407  
  3408          ! look for an empty one
  3409          %for j = 1,1,3 %cycle
  3410              r = pt pref(next)
  3411              next = next+1
  3412              next = 0 %if (next = 3)
  3413              %result = r %if (activity(r) = 0)
  3414          %repeat
  3415  
  3416          ! look for an unlocked one
  3417          %for j = 1,1,3 %cycle
  3418              r = pt pref(j)
  3419              %if (activity(r) > 0) %start
  3420                  hazard(r)
  3421                  %result = r
  3422              %finish
  3423          %repeat
  3424  
  3425          abort("Get PT Reg")
  3426      %end
  3427  
  3428      !                                                  >> GET DISPLAY <<
  3429      ! return the register to use to access display level <n>
  3430      %integerfn getdisplay( %integer l )
  3431          %integer r, lev
  3432  
  3433          ! get rid of any relocation info
  3434          lev = l&15
  3435  
  3436          ! global?
  3437          %if (lev = 0) %then %result = l
  3438  
  3439          ! local?
  3440          %if (lev = level) %then %result = BP
  3441  
  3442          ! We now try the 3 pointer register
  3443          ! - they are not contiguously numbered,
  3444          !   which is why this is unrolled!
  3445          %if (displayhint(BX) = lev) %then %result = BX
  3446          %if (displayhint(SI) = lev) %then %result = SI
  3447          %if (displayhint(DI) = lev) %then %result = DI
  3448  
  3449          r = pt reg
  3450  
  3451          ! displays are first words in frame
  3452          dumprm(MOV, r, BP, -(lev * word size), 0 )
  3453          displayhint(r) = lev
  3454          %result = r
  3455      %end
  3456  
  3457      !                                                  >> SET DOPE VECTOR <<
  3458      ! Plants a dope vector for a 1-D constant bound array (usually
  3459      ! OWN or CONST arrays) in the CONST segment, returns the offset
  3460      ! Note that it also modifies the vlb and vub variables - after
  3461      ! the call, VLB contains the byte offset for the first member
  3462      ! and VUB contains the size to allocate for the array in bytes.
  3463      %integerfn  set dope vector
  3464          %integer  t, dv
  3465  
  3466          t = vub-vlb+1
  3467          dv = getcot4(1, vlb, vub, data size)
  3468          vub = t*data size
  3469          vlb = vlb*data size
  3470          %result = dv
  3471      %end
  3472  
  3473      !                                                  >> PERM <<
  3474      ! calls a PERM and adjusts the stack by SPACE words afterwards
  3475      %routine  perm(%integer  n, space)
  3476          ! PERM routines were written in MS C,
  3477          ! as such they preserved SI and DI,
  3478          ! but trash the general purpose registers
  3479          hazard(AX)
  3480          hazard(CX)
  3481          hazard(DX)
  3482          hazard(BX)
  3483          ! JDM perm routines now implemented as IMP routines
  3484          ! so be more careful and hazard the SI,DI registers as well
  3485          hazard(SI)
  3486          hazard(DI)
  3487          dumpextcall(n)
  3488          %if (space # 0) %then dumpri( ADD, SP, space * word size)
  3489      %end
  3490  
  3491      %routine Load Perm( %integer  n, space )
  3492  
  3493          ! JDM JDM debug show the iCode instruction
  3494          %if (ShowIcode=1) %start
  3495              ListICodeNoOp
  3496          %finish
  3497          ! JDM JDM end debug
  3498  
  3499          perm( n, space )
  3500      %end
  3501  
  3502      !                                                  >> ASSEMBLE <<
  3503      ! AMODE:
  3504      !  -3: initial call
  3505      !  -2: alternate record format
  3506      !  -1: record format
  3507      !   0: begin block
  3508      !   1: procedure
  3509      !   2: %spec
  3510      %routine Assemble( %integer  amode, labs, names )
  3511          %switch c(33:127)
  3512          
  3513          ! General purpose pointer
  3514          %record(varfm)%name v
  3515  
  3516          ! Var of the current procedure we're compiling
  3517          %record(varfm)%name procvar
  3518  
  3519          ! Actual parameter ptr, used to copy parms to parm area
  3520          %record(varfm)%name   ap
  3521  
  3522          ! formal parameter ptr, used to copy parms to parm area
  3523          %record(varfm)%name   fp
  3524          ! General stack pointer
  3525          %record(stackfm)%name lhs
  3526  
  3527          ! General stack pointers
  3528          %record(stackfm)%name rhs
  3529  
  3530          ! Used for alternate records to find the largest alternate
  3531          %integer max frame
  3532  
  3533          ! First descriptor at this level
  3534          %integer first name
  3535  
  3536          ! Tag used by pass 3 to fix up this level's stack allocation
  3537          %integer staticalloc
  3538  
  3539          ! Used to jump around routines
  3540          %integer skipproc, lastskip
  3541  
  3542          ! Event info (mask, entry point, block start)
  3543          %integer events, evep, evfrom
  3544  
  3545          ! First label at this level
  3546          %integer First label
  3547  
  3548          ! Previous level's static allocation
  3549          %integer old frame
  3550  
  3551          %integer j, t
  3552          %integer dv
  3553  
  3554          %routinespec   compile to string(%record(stackfm)%name v)
  3555          ! JDM change name from load()
  3556          %routinespec   loadreg(%record(stackfm)%name  v, %integer  reg)
  3557          ! JDM new code
  3558          %routinespec   storereg(%record(stackfm)%name  v, %integer  reg)
  3559          %routinespec   assign(%integer  assop)
  3560          %routinespec   array ref(%integer  mode)
  3561          %routinespec   Operation(%integer n)
  3562          %routinespec   compare(%record(stackfm)%name  l,r)
  3563          %routinespec   test zero(%record(stackfm)%name v)
  3564          %integerfnspec new tag
  3565  
  3566          ! Actual code for Assemble is down around label NEXT
  3567  
  3568  		! The following functions "parse" an iCode instructions' parameters
  3569  		! These functions are the only places where the iCode stream is read
  3570  		!                                                      >> TAG <<
  3571  		!                                                      >> TAG+COMMA <<
  3572  		!                                                      >> INTEGER <<
  3573  		!                                                      >> BYTE <<
  3574  		!                                                      >> REAL <<
  3575  		%integerfn  ReadTag
  3576  			%integer s1, s2
  3577  			s1 = Pending
  3578  			readsymbol(s2)
  3579  			readsymbol(Pending)
  3580  			%result = s1<<8!s2
  3581  		%end
  3582  
  3583  		%integerfn  ReadTagComma
  3584  			%integer t
  3585  			t = ReadTag
  3586  			readsymbol(Pending)
  3587  			%result = t
  3588  		%end
  3589  
  3590  		%integerfn  ReadInteger
  3591  			%integer s1, s2, s3, s4
  3592  			s1 = Pending
  3593  			readsymbol(s2)
  3594  			readsymbol(s3)
  3595  			readsymbol(s4)
  3596  			readsymbol(Pending)
  3597  			%result = (s1<<24)!(s2<<16)!(s3<<8)!s4
  3598  		%end
  3599  
  3600  		%integerfn ReadByte
  3601  			%integer s1
  3602  			s1 = Pending
  3603  			readsymbol(Pending)
  3604  			%result = s1
  3605  		%end
  3606  
  3607  		!                                                      >> READ REAL <<
  3608  		! Read a floating point literal.  Pass 1 treats these as strings
  3609  		! and leaves it up to us to make a floating point number out of it
  3610  		! We therefore expect [COUNT]NNN.NNN@NN
  3611  		%longrealfn  ReadReal
  3612  			%integer n
  3613  			%longreal p, r
  3614  			n = ReadTagComma;	! char count, skip comma
  3615  
  3616  			r = 0
  3617  			! Start with the bit ahead of the decimal point
  3618  			%cycle
  3619  				sym = Pending;  read symbol(Pending)
  3620  				%exit %if (sym = '.')
  3621  				n = n-1
  3622  				-> power %if (sym = '@')
  3623  				r = r*10+(sym-'0')
  3624  				-> SIGN %if (n = 0)
  3625  			%repeat
  3626  			p = 1
  3627  			%cycle
  3628  				n = n-1
  3629                  -> SIGN %if (n = 0)
  3630  				sym = Pending
  3631                  read symbol(Pending)
  3632  				-> POWER %if (sym = '@')
  3633  				p = p/10
  3634  				r = r + (sym-'0')*p
  3635  			%repeat
  3636  
  3637  POWER:
  3638  			n = ReadTag
  3639              ! Tag is unsigned 16-bit integer (0..65535)
  3640              ! but is read into a 32-bit signed integer
  3641              ! and so 0 < n < 65535
  3642              ! BUT - tag is to be regarded as a 16-bit signed integer
  3643              ! So 0 < n < 32768 is to be regarded as a positive integer
  3644              ! and 32767 < n < 65536 is a negative integer
  3645              ! n     => correct n
  3646              ! 65536 =>  0
  3647              ! 65535 => -1      (65536 - n)
  3648              ! 65534 => -2      (65536 - n)
  3649              ! ..
  3650              ! 32768 => -32768  (65536 - n)
  3651  
  3652              ! Now to tweak the floating point value. This method is
  3653  			! somewhat clunky so that we can be portable to a system that
  3654  			! doesn't do exponents
  3655  
  3656              ! This version of the pass2 code generator targets the 8087
  3657              ! and later versions as the numeric processor for floating
  3658              ! point arithmetic
  3659              ! e.g. double real (== %longreal)
  3660              ! Double real uses an 11-bit exponent so we should ensure
  3661              ! that the tag represents an exponent in the range
  3662              !             -1023 <= exp <= 1023
  3663              ! -1024 is omitted to ensure no overflow for reciprocals
  3664              ! The exponent however, has a bias of 1023 so the actual
  3665              ! 8087 exponent is in the range 0 <= exp <= 2046
  3666  
  3667              ! Currently don't bother to check that the exponent is in
  3668              ! the range -1023 < exp < 1023
  3669              %if (n # 0) %start
  3670                  ! ok, non-zero exponent
  3671                  %if (0 < n < 32768) %start
  3672                      ! positive exponent
  3673                      %while (n > 0) %cycle
  3674                          r = r * 10
  3675                          n = n - 1
  3676                      %repeat
  3677                  %else
  3678                      ! a negative exponent
  3679                      ! So, convert to negative value
  3680                      n = n - 65536
  3681  
  3682                      ! Now, attempt to update the float value
  3683                      %while (n < 0) %cycle
  3684                          r = r / 10
  3685                          n = n + 1
  3686                      %repeat
  3687                  %finish
  3688              %finish
  3689  SIGN:
  3690              ! sign of whole value
  3691  			%if (Pending = 'U') %start
  3692  				read symbol(Pending)
  3693  				r = -r
  3694  			%finish
  3695  
  3696  			%result = r
  3697  		%end
  3698  
  3699  		%string(255)%function ReadString
  3700              ! JDM JDM changed Limit to be a %constinteger
  3701              %constinteger limit = 255
  3702  			%integer J, Sym
  3703  			%string(255) s
  3704  
  3705  			s = ""
  3706  			%for J = Pending, -1,1 %cycle
  3707  				Readsymbol(Sym)
  3708  				s = s.Tostring(Sym) %if (Length(s) < Limit)
  3709  			%repeat
  3710  			Readsymbol(Pending)
  3711  			
  3712  			%result = s
  3713  		%end
  3714  
  3715  		%string(255)%function Get Ascii( %integer terminator)
  3716  			%string(255) a
  3717  			%integer Sym
  3718  			a = ""
  3719  			%cycle
  3720  				sym = Pending
  3721                  read symbol(Pending)
  3722                  %exit %if (sym = terminator)
  3723  				%if (length( a ) # 255) %start
  3724  					a = a.to string(sym)
  3725  				%finish
  3726  			%repeat
  3727  			%result = a
  3728  		%end
  3729  		! End of parsing routines
  3730  
  3731          %routine Load Language Flags( %integer flags )
  3732  
  3733              ! JDM JDM debug show the iCode instruction
  3734              %if (ShowIcode=1) %start
  3735                  ListICode
  3736                  spaces(4)
  3737                  printstring( itos(flags,0) )
  3738                  newline
  3739              %finish
  3740              ! JDM JDM end debug
  3741  
  3742              Language Flags = flags;
  3743          %end
  3744  
  3745          !                                              >> DEFINE VAR <<
  3746          %routine  Define Var( %integer decl, %string(255) internal id, %integer tf, size, scope )
  3747              %integer  type, form, format, s, new, round, dimension
  3748              %integer  dv;              ! dope vector offset
  3749              %owninteger  prim no = 0
  3750              %integer flags
  3751              %string(255) sx,flagstring
  3752  
  3753              ! Now parse the type and form word
  3754              type = (tf>>4)
  3755              form = tf&15
  3756  
  3757              ! Now analyse the Scope word
  3758              dimension = (scope>>8)&255
  3759              ! JDM JDM debug
  3760              flags = (scope>>3)&31
  3761  
  3762              spec = (scope>>3)&1
  3763              otype = scope&7
  3764  
  3765              ! JDM JDM debug show the iCode instruction
  3766              %if (ShowIcode=1) %start
  3767                  ListICode
  3768                  spaces(4)
  3769                  printstring( itos(decl,0) )
  3770                  printsymbol( ',' )
  3771                  printsymbol( '"' )
  3772                  printstring( internal id )
  3773                  printsymbol( '"' )
  3774                  printsymbol( ',' )
  3775                  printstring( itos(tf,0) )
  3776                  printsymbol( ',' )
  3777                  printstring( itos(size,0) )
  3778                  printsymbol( ',' )
  3779                  printstring( itos(scope,0) )
  3780                  spaces(4)
  3781  
  3782                  sx = ""
  3783                  sx = sx . " " . get own string( otype )
  3784                  sx = sx . " " . get type def( type, size )
  3785                  sx = sx . " " . get external form name( form )
  3786                  { See if there are any flags set }
  3787                  flagstring = get flags string( flags )
  3788  
  3789                  { Ok, flags were set so show them }
  3790                  %if (length(flagstring) > 0) %start
  3791                      sx = sx . " [" . flagstring . "]"
  3792                  %finish
  3793  
  3794                  printsymbol( '(' )
  3795                  printstring( sx )
  3796                  space
  3797                  printsymbol( ')' )
  3798  
  3799                  newline
  3800              %finish
  3801              ! JDM JDM end debug
  3802  
  3803              new = 0
  3804              round = align
  3805  
  3806              ! Get the var index
  3807              %if (decl = 0) %start
  3808                  ! RECORD FORMAT ELEMENT NAME
  3809                  parms = parms-1
  3810                  abort("Def Var Parms") %if (parms <= names)
  3811                  decvar == var(parms)
  3812                  decvar = 0
  3813              %else
  3814                  abort("Def Var Names (decl=".itos(decl,0)." parms=".itos(parms,0).")") %if (decl >= parms)
  3815                  decvar == var(decl)
  3816                  %if (decl > names) %start
  3817                      names = decl
  3818                      new = 1
  3819                      decvar = 0
  3820                  %finish
  3821              %finish
  3822  
  3823              ! Map external type numbers into internal equivalents,
  3824              ! and adjust for short/byte/long things
  3825              %if (type = integer) %and (size # 1) %start
  3826                  ! INTEGER
  3827                  type = byte  %and round = 0 %if size = 2
  3828                  size = vsize(type)
  3829              %finish %else %if (type = real) %start
  3830                  ! REAL
  3831                  ! or possibly
  3832                  ! LONG REAL
  3833                  type = lreal %if (size = 4)
  3834                  size = vsize(type)
  3835              %finish %else %if (type = record) %start
  3836                  ! record
  3837                  format = size
  3838                  decvar_format = format
  3839                  size = var(format)_size %if (format <= names)
  3840              %finish %else %if (type = string) %start
  3841                  ! string
  3842                  round = 0
  3843                  decvar_size = size
  3844                  size = size + 1
  3845              %else
  3846                  size = vsize(type)
  3847              %finish
  3848  
  3849              ! JDM JDM remember the variable name
  3850              ! Needed should an embedded code fragment refer to an IMP variable
  3851              var(decl)_idname = internal id
  3852  
  3853              decvar_size = size %if (type # string)
  3854              decvar_type = type
  3855              decvar_form = form
  3856  
  3857              %if (otype # 0) %start
  3858                  ! Set external linkage name if appropriate
  3859                  %if (otype >= external) %start
  3860                      %if (length(alias) # 0) %start
  3861                          external id = alias
  3862                      %finish %else %if (otype = system) %start
  3863                          external id = system prefix.internal id
  3864                      %else
  3865                          external id = "_".internal id
  3866                      %finish
  3867                      ! external, system, dynamic?
  3868                      otype = external %if (otype <= dynamic)
  3869                  %finish
  3870              %finish
  3871              alias = ""
  3872  
  3873  			! JDM: Ensure the external displacement is zero
  3874  			decvar_extdisp = 0
  3875  
  3876              %if (switch < form) %and (form < array) %start
  3877                  ! PROCEDURE
  3878                  ! 1 for normal proc, 2 for spec
  3879                  block type = 1 + spec
  3880                  %if (otype # 0) %and (spec # 0) %start
  3881                      ! external spec
  3882                      %if (otype = primrt) %start
  3883                          primno = primno + 1
  3884                          decvar_level = 128
  3885                          decvar_disp = prim no
  3886                          %return
  3887                      %finish
  3888                      decvar_disp = externalref(external id)
  3889                      ! JDM: Remember the base external displacement
  3890  					decvar_extdisp = decvar_disp
  3891                      decvar_level = 0
  3892                      decvar_scope = EXT
  3893                      %return
  3894                  %finish
  3895  
  3896                  %if (in params = 0) %start
  3897                      ! NOT A PARAMETER
  3898                      potype = otype
  3899                      %if (new # 0) %start
  3900                          ! NEW NAME
  3901                          decvar_disp = new tag
  3902                          ! Procedure ID
  3903                      %finish
  3904                      block name = internal id %if (spec = 0)
  3905                      %return
  3906                  %finish
  3907  
  3908                  otype = 0
  3909                  size = word size
  3910                  data size = word size
  3911                  ! procedure parameter
  3912  
  3913              %else
  3914                  ! This is not a procedure declaration
  3915                  data size = size
  3916                  %if (form # simple) %start
  3917                      Round = Align
  3918                      %if (type = general) %start
  3919                          ! General %name
  3920                          ! FOR LABELS
  3921                          decvar_extra = in params
  3922                          size = word size * 2
  3923                      %finish %else %if (form = array) %or (form = name array) %start
  3924                          ! We will fill in dimensions and allocate space when
  3925                          ! we are told the bounds later
  3926                          size = 0
  3927                          data size = word size %if (form = name array)
  3928                      %finish %else %if (form = array name) %or (form = name array name) %start
  3929                          ! array header
  3930                          decvar_dim = dimension
  3931                          size = word size * 2
  3932                          ! array header
  3933                          round = align
  3934                      %else
  3935                          size = word size;                       ! integer (etc) %name
  3936                      %finish
  3937                  %finish
  3938              %finish
  3939  
  3940              ! Now deal with OWN (or const/extern/etc) data items
  3941              %if (otype # 0) %start
  3942                  ! OWN DATA
  3943                  %if (otype = con) %start
  3944                      ! CONST INTEGER ETC.
  3945                      ! use actual size for plain strings
  3946                      data size = 0 %if (type = string) %and (form = simple)
  3947                      %if (form = name) %or (form = arrayname) %or (form = namearrayname) %start
  3948                          ! Treat as special later
  3949                          otype = 0
  3950                      %finish
  3951                  %else
  3952                      ! OWN, not CONST
  3953                      ! so make it even if needed
  3954                      gfix(round)
  3955                  %finish
  3956                  ! set globals used by our data collection utilities
  3957                  own type = type
  3958                  own form = form
  3959  
  3960                  ! %name's are really integers
  3961                  own type = integer %and data size = word size %if (form = 2)
  3962  
  3963                  %if (spec = 0) %start
  3964                      %if (form = array) %or (form = name array) %start
  3965                          gfix(align)
  3966                          ! N.B.  changes vlb, vub
  3967                          dv = set dope vector
  3968                          ! We treat OWN and CONST arrays identically - both are in data segment
  3969                          gfix(align)
  3970                          decvar_disp = datatp - vlb;
  3971                          decvar_level = 0
  3972                          decvar_scope = DATA
  3973  
  3974                          ! save the dope vector pointer here
  3975                          decvar_pbase = dv
  3976                          ! own arrays are always 1-D
  3977                          decvar_dim = 1
  3978                      %finish
  3979                      fill external(DATA, decvar_disp, external id) %if (otype = external)
  3980                  %else
  3981                      decvar_level = 0
  3982                      decvar_scope = EXT
  3983                      decvar_disp = external ref(external id)
  3984  					! JDM: We have a reference to external data so note the external ref id
  3985  					!      inside the _extdisp field
  3986  					!      _extdisp will NEVER be modified unlike _disp
  3987  					!      Eventually it will be used when generating ABSEXT ibj records
  3988                      !      The difference between _disp and _extdisp represents the offset
  3989                      !      from the location specified by _disp
  3990                      !      offset == _extdisp - _disp
  3991                      decvar_extdisp = decvar_disp
  3992                  %finish
  3993              %finish %else %if (form = label) %start
  3994                  !%label
  3995                  decvar_disp = new tag
  3996              %finish %else %if (form = switch) %start
  3997                  size = vub - vlb
  3998                  %if (swtp + size > Max Switch) %then abort("Switch Table Full")
  3999                  decvar_scope = SWT
  4000                  decvar_disp = swtp - vlb
  4001                  decvar_extra = set dope vector
  4002                  %for s = swtp, 1, swtp + size %cycle
  4003                      ! should really deal with undefined switch entries
  4004                      swtab(s) = 0
  4005                  %repeat
  4006                  swtp = swtp + size + 1
  4007              %finish %else %if (form = record format) %start
  4008                  %if (in params # 0) %start
  4009                      frame = decvar_size %if (decvar_size > frame)
  4010                  %else
  4011                      block type = -1
  4012                      spec = -1
  4013                  %finish
  4014              %finish %else %start
  4015                  ! Here we've got an ordinary local variable, parameter or record entry
  4016                  decvar_level = level
  4017                  %if (in params = 0) %start
  4018                      ! local variable
  4019                      frame = (frame - size) & (\round)
  4020                      decvar_disp = frame
  4021                  %finish %else %if (block type > 0) %start
  4022                      ! procedure parameters
  4023                      ! parameters are always word aligned
  4024                      frame = (frame + size + align) & (\align)
  4025  
  4026                      ! offset will be adjusted at iCode '}'
  4027                      decvar_disp = frame
  4028                  %finish %else %start
  4029                      ! records
  4030                      frame = (frame + round) & (\round)
  4031                      decvar_disp = frame
  4032                      frame = frame + size
  4033  
  4034                      ! no base register
  4035                      decvar_level = 0
  4036                  %finish
  4037              %finish
  4038          %end
  4039          !    Define Var
  4040  
  4041          !---------------------------------------------------------------------
  4042          ! Stack manipulation routines
  4043          !---------------------------------------------------------------------
  4044          !                                                      >> POP STACK <<
  4045          ! Pop the top of the stack
  4046          %routine  Pop Stack
  4047              %if (stp = 0) %then abort("Pop")
  4048              monitor(top, "Pop") %if (diagnose&1 # 0)
  4049              stp = stp - 1
  4050              %if (stp # 0) %then top == stack(stp) %else top == null
  4051          %end
  4052  
  4053          !                                                      >> POP REL <<
  4054          ! Pop the top of the stack, and release its' register
  4055          %routine  pop rel
  4056              release(top_base)
  4057              pop stack
  4058          %end
  4059  
  4060          %constbyteintegerarray fmap(0:15) =
  4061+                  0, V in S,    A in S, pgm label, recordformat,         0,        switch,       0,
  4062+         {     void, simple,      name,     label, recordformat,         ?,        switch, routine, }
  4063+             V in R, V in S,    V in R,    V in S,       A in S,    V in S,        A in S,       0
  4064          { function,    map, predicate,     array,    arrayname, namearray, namearrayname,       ?  }
  4065  
  4066          !                                                           >> STACK VAR <<
  4067          ! Push a descriptor on the stack corresponding to Var "var no"
  4068          ! We map the variable form to a stack form, and assign a register
  4069          ! for the base if it is non local.  Finally, we absorb the scope
  4070          ! into the base register.
  4071          %routine  Stack Var(%integer  var no)
  4072              %record(varfm)%name  w
  4073  
  4074              abort("Stack Var Idx") %unless 0 <= var no %and var no <= max vars
  4075              w == var(varno)
  4076              stp = stp + 1
  4077              %if (stp > Max Stack) %then abort("Push V Stack Overflow")
  4078              top == stack(stp)
  4079              top = 0
  4080  
  4081              ! Translate "level" into "base register" - if it is non local
  4082              ! we flag it by adding 16 to the desired level, which later will
  4083              ! force us to pick up a pointer register
  4084              %if (w_level # 0) %start
  4085                  %if (w_level = level) %then top_base = BP %else top_base = w_level + 16
  4086              %else
  4087                  top_base = 0
  4088              %finish
  4089  
  4090              ! AFORM contains the real original declared form, while
  4091              ! FORM contains the on-the-stack subset of possible forms
  4092              top_aform = w_form
  4093              top_form = fmap(w_form)
  4094              top_dim = w_dim
  4095              top_type = w_type
  4096              top_disp = w_disp
  4097  			top_extdisp = w_disp
  4098              top_scope = w_scope
  4099              top_format = w_format
  4100              top_size = w_size
  4101              top_extra = w_extra
  4102              top_pbase = w_pbase
  4103  
  4104              ! JDM remember variable name via varno
  4105              top_varno = varno
  4106  
  4107              monitor(top, "Var stack") %if (diagnose&1 # 0)
  4108          %end
  4109  
  4110          !                                                      >> LOAD VAR <<
  4111          ! Load a var onto the stack (using StackVar)
  4112          ! JDM JDM this is a wrapper to ensure when reading the iCode data
  4113          ! the iCode data is listed only once.
  4114          ! Why? because Stack Var is used in many locations
  4115          %routine  Load Var(%integer  var no)
  4116  
  4117              ! JDM JDM debug show the iCode instruction
  4118              %if (ShowIcode=1) %start
  4119                  ListICode
  4120                  spaces(4)
  4121                  printstring( itos(var No,0) )
  4122                  printsymbol( ',' )
  4123                  printsymbol( '"' )
  4124                  printstring( var(varno)_id name )
  4125                  printsymbol( '"' )
  4126                  newline
  4127              %finish
  4128              ! JDM JDM end debug
  4129  
  4130              StackVar( var no )
  4131          %end
  4132  
  4133          !                                                      >> PUSH COPY <<
  4134          ! Push a duplicate of a stack record onto the stack
  4135          %routine  push copy(%record(stackfm)%name  v)
  4136              stp = stp + 1
  4137              %if (stp > Max Stack) %then abort("Stack Copy")
  4138              top == stack(stp)
  4139              top = v
  4140  
  4141              monitor(top, "Stack Copy") %if (diagnose&1 # 0)
  4142          %end
  4143  
  4144          !                                                      >> PUSH CONST <<
  4145          ! Push a constant on the stack
  4146          %routine  push const(%integer  n)
  4147              stp = stp + 1
  4148              %if (stp > Max Stack) %then abort("Stack Const")
  4149              top == stack(stp)
  4150              top = 0
  4151              top_disp = n
  4152  			top_extdisp = 0
  4153              top_type = integer
  4154              top_form = constant
  4155              monitor(top, "push const") %if (diagnose&1 # 0)
  4156          %end
  4157  
  4158          ! Load a const onto the stack (using Push Const)       >> PUSH CONST <<
  4159          ! JDM JDM this is a wrapper to ensure when reading the iCode data
  4160          ! the iCode data is listed only once.
  4161          ! Why? because Push Const is used in many locations
  4162          %routine  Load Const(%integer  n)
  4163  
  4164              ! JDM JDM debug show the iCode instruction
  4165              %if (ShowIcode=1) %start
  4166                  ListICode
  4167                  spaces(4)
  4168                  printstring( itos(N,0) )
  4169                  newline
  4170              %finish
  4171              ! JDM JDM end debug
  4172          
  4173              push const( n )
  4174          %end
  4175  
  4176          !---------------------------------------------------------------------
  4177          !STRING PROCESSING
  4178          !---------------------------------------------------------------------
  4179          !                                                      >> INPUT STRING VALUE<<
  4180          ! Read a string literal from the iCode stream
  4181          %routine  Input String Value( %string(255) s)
  4182              %integer  i
  4183  
  4184              ! JDM JDM debug show the iCode instruction
  4185              %if (ShowIcode=1) %start
  4186                  ListICode
  4187                  spaces(4)
  4188                  printsymbol( '"' )
  4189                  printstring( s )
  4190                  printsymbol( '"' )
  4191                  newline
  4192              %finish
  4193              ! JDM JDM end debug
  4194  
  4195  			current string(0)= length(s)
  4196  			%for i = 1,1,length(s) %cycle
  4197  				current string(i) = charno(s,i)
  4198  			%repeat
  4199  
  4200              ! if this is about to be used as a literal, put it straight into
  4201              ! the CONST segment and stack it, otherwise leave it in curr string to see
  4202              ! what comes next and stack a dummy zero
  4203              ! 
  4204              %if (Pending # 'A') %and (Pending # '$') %start
  4205                  otype = con;        ! anonymous %const
  4206                  push const( getcots(current string) );
  4207  				top_type = string
  4208                  top_base = 0;
  4209  				top_scope = COT;
  4210  				top_form = V in S;
  4211  				top_format = current string(0)+1
  4212              %else
  4213                  ! explicit string initialisation coming next
  4214                  push const(0)
  4215              %finish
  4216          %end
  4217  
  4218  		%routine Get Alias Value( %string(255) s )
  4219  
  4220              ! JDM JDM debug show the iCode instruction
  4221              %if (ShowIcode=1) %start
  4222                  ListICode
  4223                  spaces(4)
  4224                  printsymbol( '"' )
  4225                  printstring( s )
  4226                  printsymbol( '"' )
  4227                  newline
  4228              %finish
  4229              ! JDM JDM end debug
  4230  
  4231  			alias = s
  4232  
  4233  		%end
  4234  
  4235  		%routine Input Real Value( %longreal r)
  4236  
  4237              ! JDM JDM debug show the iCode instruction
  4238              %if (ShowIcode=1) %start
  4239                  ListICode
  4240                  spaces(4)
  4241                  print( r,8 )
  4242                  newline
  4243              %finish
  4244              ! JDM JDM end debug
  4245  
  4246  			%if (r = 0) %then %start
  4247  				push const(0)
  4248  			%else
  4249  				%if (Pending # 'A') %then %start
  4250                      !  anonymous %const
  4251  					otype = con
  4252  					push const(0)
  4253  					top_type = lreal
  4254  					top_scope = COT
  4255                      !  N.B. ** %fn + side-effect **
  4256  					top_disp = getcotdouble(r)
  4257  					top_extdisp = 0
  4258  					top_form = V in S
  4259  				%finish
  4260  			%finish
  4261  			rvalue = r
  4262  		%end
  4263  
  4264          !-------------------------------------------------------
  4265          !LABEL PROCESSING
  4266          !
  4267          ! Labels fixups are handled by pass 3 - we just plant
  4268          ! numerical labels for code locations, and then jump to or call
  4269          ! those labels.  Pass 3 turns them into real locations.
  4270          ! Unfortunately Pass 3 needs unique label numbers whereas
  4271          ! Pass 1 produces lame local label numbers that can
  4272          ! be reused once they've been defined.  We therefore
  4273          ! maintain an indirect database to map Pass 1 label numbers
  4274          ! into unique tags
  4275  
  4276          !                                                      >> NEW TAG <<
  4277          ! Get the next consecutive Pass 3 label ID
  4278          %integerfn  new tag
  4279              %owninteger free tag = 999
  4280  
  4281              free tag = free tag + 1
  4282              %result = free tag
  4283          %end
  4284  
  4285          !                                                      >> NEW LABEL <<
  4286          ! Get the next available label database index
  4287          %integerfn  New Label
  4288              labs = labs+1
  4289              abort("Labels") %if (labs > Max Labs)
  4290              %result = labs
  4291          %end
  4292  
  4293          !                                                        >> FIND LABEL<<
  4294          ! return the index in our label table of the Pass 1 label
  4295          %integerfn  Find Label(%integer  label)
  4296              %integer  lp
  4297  
  4298              lp = labs
  4299              %while (lp # first label) %cycle
  4300                  %result = lp %if (labels(lp)_id = label)
  4301                  lp = lp-1
  4302              %repeat
  4303              %result = 0
  4304          %end
  4305  
  4306          !                                                     >> DEFINE LABEL <<
  4307          ! This label is "here"
  4308          %routine  Define Label(%integer  label)
  4309              %integer lp
  4310              %record(labelfm)%name  l
  4311  
  4312              lp = Find Label(label)
  4313              %if (lp = 0) %start
  4314                  ! Not yet been used
  4315                  lp = New Label
  4316                  l == labels(lp)
  4317                  l_id = label
  4318                  l_tag = new tag
  4319              %else
  4320                  l == labels(lp)
  4321                  %if (l_tag&16_8000 # 0) %and (label > 0) %then l_tag = new tag
  4322              %finish
  4323  
  4324              dump label(l_tag)
  4325              l_tag = l_tag ! 16_8000
  4326              ! You can get here
  4327              uncond jump = 0
  4328          %end
  4329          ! define label
  4330  
  4331          !                                                          >> JUMP TO <<
  4332          ! A wrapper for conditional jumps to labels that we're going
  4333          ! to map into tags
  4334          %routine  Jump To(%integer  label, op, flag)
  4335              %record(labelfm)%name  l
  4336              %integer  lp
  4337  
  4338              lp = Find Label(label)
  4339              %if (lp = 0) %start
  4340                  lp = New Label
  4341                  l == labels(lp)
  4342                  l_id = label
  4343                  l_tag = new tag
  4344              %else
  4345                  l == labels(lp)
  4346                  %if (flag # 0) %and (l_tag&16_8000 # 0) %then l_tag = new tag
  4347              %finish
  4348  
  4349              ! As a side effect, we also set the global J Tag, which is used
  4350              ! in planting Event block information (a bit hacky, but a PSR feature)
  4351              JTag = l_tag & 16_7FFF
  4352  
  4353              dump jump(op, JTag)
  4354  
  4355              %if (op = JMP) %then uncond jump = nextcad
  4356          %end
  4357          ! jump to
  4358  
  4359  		%routine Jump Forward( %integer val, test )
  4360  			%integer opr
  4361  
  4362              ! JDM JDM debug show the iCode instruction
  4363              %if (ShowIcode=1) %start
  4364                  ListICode
  4365                  spaces(4)
  4366                  printsymbol( 'L' )
  4367                  printstring( itos(val,0) )
  4368                  newline
  4369              %finish
  4370              ! JDM JDM end debug
  4371  
  4372  			! FF,TT tests need a value to compare
  4373  			! TT == TRUE (#0)
  4374  			! FF == FALSE (=0)
  4375  			%if (Test = FF) %or (Test = TT) %then dumpri(CMP, AX, 0)
  4376  			! Get the required operator for the test
  4377  			! We may need to amend the choice of operator
  4378  			! depending on the invert/compare unsign "flags"
  4379  			opr = TestToOp( test )
  4380  
  4381  			%if (val = 0) %then %start
  4382  				%if (last skip # next cad) %then %start
  4383  					skip proc = new tag
  4384  					dumpjump(opr, skip proc)
  4385  				%finish
  4386  			%else
  4387  				! Check if we need to reverse the test
  4388  				! So, re-choose the operator
  4389  				%if (invert # 0) %then Test = Reverse( Test )
  4390  				invert = 0;
  4391  
  4392  				! convert the operators to unsigned versions if needed
  4393  				%if (compare unsign # 0) %then opr = TestToUnsignedOp( Test ) %else opr = TestToOp( Test )
  4394  				compare unsign = 0
  4395  
  4396  				jump to(val, opr, 1)
  4397  			%finish
  4398  		%end;				! Jump Forward
  4399  
  4400  		%routine Jump Backward( %integer val )
  4401  
  4402              ! JDM JDM debug show the iCode instruction
  4403              %if (ShowIcode=1) %start
  4404                  ListICode
  4405                  spaces(4)
  4406                  printsymbol( 'L' )
  4407                  printstring( itos(val,0) )
  4408                  newline
  4409              %finish
  4410              ! JDM JDM end debug
  4411  
  4412  			jump to(val, JMP, 0);
  4413  		%end
  4414  
  4415          !-------------------------------------------------------
  4416          ! Stack variable transformations
  4417          !-------------------------------------------------------
  4418          !                                           >> REDUCE <<
  4419          ! Convert a variable which is addressed in a Rec into a simple variable
  4420          ! by loading the indirect value into a register and changing the form
  4421          %routine  reduce(%record(stackfm)%name  v)
  4422              %integer  type, form, disp, scope, extdisp
  4423     
  4424              form = v_form - 3;         ! X in REC => X in S
  4425              type = v_type
  4426              disp = v_disp
  4427  			extdisp = v_extdisp
  4428              ! Here's a trick - we've got two displacements, DISP and EXTRA, but only
  4429              ! one SCOPE hint.  Which does it belong to?  If the REC form came from
  4430              ! a HAZARD then the scope belongs to the DISP, but for all other cases
  4431              ! the scope belongs to the EXTRA.  If we got here through HAZARD then
  4432              ! the BASE will be BP - for all other cases it will be either a different
  4433              ! register, or zero.
  4434              %if (v_base = BP) %start
  4435                  scope = v_scope
  4436                  v_scope = 0
  4437              %else
  4438                  scope = 0
  4439              %finish
  4440              v_disp = v_extra;
  4441  			v_type = integer;
  4442  			v_form = v in s
  4443  
  4444              loadreg(v, anyp)
  4445  
  4446              v_type = type;
  4447  			v_form = form
  4448              v_disp = disp;
  4449  			v_extdisp = extdisp;
  4450  			v_scope = scope
  4451          %end
  4452  
  4453          !                                              >> AMAP <<
  4454          ! convert V into a descriptor for the address of V
  4455          %routine  amap(%record(stackfm)%name  v)
  4456              %integer f
  4457              %constintegerarray  addr map(0:15) =
  4458+             {    0,        1,  2,  3,       4,   5,               6,                   7, }
  4459+                 -1,       -2, -3, -4, AV in S,  -5,          V in S,           AV in REC,
  4460+ 
  4461+             {    8,        9, 10, 11,      12,  13,              14,                  15  }
  4462+                 -6, V in REC, -7, -8,      -9, -10, {PGM LABEL} -11, {record format} -12
  4463  
  4464              ! ABD - should be code here to deal with ADDR(pgm label)
  4465  
  4466              f = addr map(v_form)
  4467              %if (f < 0) %start
  4468                  monitor(v, "AMAP target")
  4469                  abort("AMAP")
  4470              %finish
  4471  
  4472              ! Try to simplify some forms...
  4473              %if (v_disp = 0) %and (v_scope = 0) %start
  4474                  %if (f = A V in S) %start
  4475                      %if (v_base = 0) %then f = constant %else f = V in R
  4476                  %finish %else %if (f = V in REC) %or (f = A V in REC) %start
  4477                      ! eliminate redundant LOAD
  4478                      %if (f = V in REC) %then f = A in S %else f = V in S
  4479                      v_disp = v_extra
  4480                  %finish
  4481              %finish
  4482              v_type = integer
  4483              v_form = f
  4484          %end
  4485  
  4486          !                                              >> VMAP <<
  4487          ! The inverse of AMAP:  i.e. vmap(amap(x)) => x
  4488          %routine  vmap(%record(stackfm)%name  v)
  4489              %integer  f, t
  4490              %constintegerarray  var map(0:8) =
  4491+             {      0,      1,  2,  3,      4,      5,  6,        7,        8 }
  4492+               V in S, V in S, -1, -2, A in S, V in S, -3, A in REC, V in REC
  4493  
  4494              %if (v_form = A in S) %or (v_form = A in REC) %start
  4495                  t = v_type
  4496                  amap(v)
  4497                  loadreg(v,anyp)
  4498                  v_type = t
  4499                  v_form = V in S
  4500              %finish
  4501              f = var map(v_form)
  4502              v_form = f
  4503              abort("VMap") %if (f < 0)
  4504          %end
  4505          !  v map
  4506  
  4507          !                                              >> ADDRESS <<
  4508          ! convert V into a form in which it is directly addressable
  4509          ! that means either V in R, V in S or Constant
  4510          %routine  address(%record(stackfm)%name  v)
  4511              %integer  type, form
  4512     
  4513              monitor(v, "ADDRESS") %if (diagnose&2 # 0)
  4514  
  4515              form = v_form
  4516              type = v_type
  4517              %if (form >= V in REC) %start
  4518                  reduce(v)
  4519                  form = v_form
  4520              %finish
  4521  
  4522              ! Now pick up a base register if we needed one...
  4523              %if (v_base > 16) %start
  4524                  v_base = get display(v_base - 16)
  4525                  claim(v_base)
  4526              %finish
  4527  
  4528              %return %if (form = V in R) %or (form = constant)
  4529  
  4530              %if (form = A V in S) %start
  4531                  %if (v_base = 0) %start
  4532                      v_form = constant
  4533                  %else
  4534                      %if (v_disp = 0) %and (v_scope = 0) %start
  4535                          v_form = V in R
  4536                      %else
  4537                          loadreg(v, any)
  4538                      %finish
  4539                  %finish
  4540                  %return
  4541              %finish
  4542  
  4543              %return %if (form = V in S)
  4544     
  4545              %if (form = A in S) %start
  4546                  v_form = V in S
  4547                  v_type = integer
  4548                  loadreg(v,anyp)
  4549                  v_type = type
  4550                  v_form = V in S
  4551                  v_disp = 0
  4552              %finish
  4553          %end
  4554          ! address
  4555  
  4556          !                                              >> LOAD REG <<
  4557          ! Load variable V into register R
  4558          ! Along the way any register the variable owned is released, and
  4559          ! the new register is claimed.
  4560  		%routine LoadReg(%record(stackfm)%name v, %integer r)
  4561  			%switch f(0:9)
  4562  			%integer ptr, op
  4563  
  4564  			monitor(v, "LOAD") %if (diagnose&2 # 0)
  4565  
  4566  			%if (r = anyf) %start
  4567  				! Equivalents for real numbers...
  4568  				! because there's very little clever we can do, we first simplify somewhat...
  4569  				Address(v)
  4570  				! Now it's either Constant, V in R or V in S - we now turn them
  4571  				! all into V in S - the only thing we can load
  4572  				! Start with one we have no instructions for, and promote it to
  4573  				! something we know how to handle...
  4574  				%if (v_type = byte) %then loadreg(v, any)
  4575  				%if (v_form = V in R) %start
  4576  					%return %if (v_base >= FR0)
  4577  					! This must be an integer in a CPU register - we need to store it
  4578  					! before we can use it
  4579  					v_disp = getwork(word size)
  4580  					dumpmr(MOV, BP, v_disp, v_extdisp, v_base)
  4581  					release(v_base)
  4582  					v_base = BP
  4583  					v_scope = 0
  4584  					v_form = V in S
  4585  					! Now it looks like an integer V in S
  4586  				%finish
  4587  				%if (v_form = constant) %start
  4588                      ! This is an integer constant
  4589  					%if (v_disp = 0) %start
  4590                          ! We have a special instruction for zero
  4591  						r = FR0 + FPU Stack
  4592  						dumpflopspec(FLDZ)
  4593  						v_base = r
  4594  						claim(r)
  4595  						v_disp = 0;
  4596  						v_form = V in R
  4597  						v_type = real
  4598  						%return
  4599  					%finish
  4600  					! Otherwise, we need it in store
  4601  					v_disp = getcotw(v_disp)
  4602  					v_form = V in S
  4603  					v_base = 0
  4604  					v_scope = COT
  4605  				%finish
  4606  
  4607  				! Now everything that's left is a V in S
  4608  				%if (v_type = integer) %start
  4609  					op = FILD
  4610  				%else
  4611  					%if (v_type = real) %start
  4612  						op = FLDD
  4613  					%else
  4614  						op = FLDQ
  4615  					%finish
  4616  				%finish
  4617  
  4618  				! register is going to be the top of stack
  4619  				r = FR0 + FPU Stack
  4620  		
  4621  				dumpfloprm(op, v_base!v_scope, v_disp, v_extdisp )
  4622  				release(v_base)
  4623  				v_base = r
  4624  				claim(r)
  4625  				v_disp = 0;
  4626  				v_form = V in R
  4627  				v_type = real
  4628  				%return
  4629  			%finish
  4630  
  4631  			! If the request is one of the variations on "any" then we need
  4632  			! to first allocate a target register.  First, we make a local
  4633  			! adjustment because we can't load bytes into "any" register,
  4634  			! only into the GP registers...
  4635  			%if (v_type = byte) %start
  4636  				%if (r = any) %then r = anyg
  4637  				! What's more, there is only one register that is both a pointer
  4638  				! and a legal byte destination
  4639  				%if (r = anyp) %then r = BX
  4640  			%finish
  4641  
  4642  			! We also map the virtual display into a real register if we
  4643  			! need to.  Also, it is possible that an in-store form may
  4644  			! be derived from a non-pointer register, so we fix that too.
  4645  			%if (v_base > 16) %then %start
  4646  				v_base = get display(v_base - 16)
  4647  				claim(v_base)
  4648  			%finish
  4649  
  4650  			! Now go ahead and allocate a register
  4651  			%if (r = any) %then %start
  4652  				! If we've got a base,
  4653                  ! it's not in use by anyone else,
  4654                  ! and isn't a display register,
  4655                  ! then use it
  4656  				%if (v_base # 0) %and (activity(v_base) = 1) %and (displayhint(v_base) = 0) %start
  4657  					r = v_base
  4658  				%else
  4659  					r = gp reg
  4660  				%finish
  4661  			%else
  4662  				%if (r = anyg) %then %start
  4663  					%if (0 < v_base <= BX) %and (activity(v_base) = 1) %start
  4664  						r = v_base
  4665  					%else
  4666  						r = gp reg
  4667  					%finish
  4668  				%else
  4669  					%if (r = anyp) %then %start
  4670  						%if (activity(v_base) = 1) %and ((v_base = BX) %or (v_base = SI) %or (v_base = DI)) %then %start
  4671  							r = v_base
  4672  						%else
  4673  							r = pt reg
  4674  						%finish
  4675  					%else
  4676  						%if (v_base = r) %start
  4677  							%if (activity(r) > 1) %start
  4678                                  ! protect other uses
  4679  								release(r)
  4680  
  4681                                  ! Hide my ownership for the moment
  4682                                  v_base = 0
  4683  
  4684                                  ! Zap everybody else
  4685  								hazard(r)
  4686  
  4687                                  ! Get it back
  4688  								claim(r)
  4689                                  v_base = r
  4690  							%finish
  4691  						%else
  4692  							hazard(r)
  4693  						%finish
  4694  					%finish
  4695  				%finish
  4696  			%finish
  4697  			-> f(v_form)
  4698  
  4699  f(V in REC):
  4700  			reduce(v); ->f(v_form)
  4701  
  4702  f(AV in REC):
  4703              reduce(v); ->f(v_form)
  4704  
  4705  f(A in REC):
  4706              reduce(v); ->f(v_form)
  4707  
  4708  f(AV in R): Abort("Unexpected Stack Form")
  4709  
  4710  f(A in R):  Abort("Unexpected Stack Form")
  4711  
  4712  f(constant):
  4713  			%if (v_disp = 0) %and (v_scope = 0) %start
  4714  				dumprr(XOR, r, r)
  4715  			%else
  4716  				dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  4717  			%finish
  4718  			v_base = r
  4719  			v_disp = 0
  4720  			v_scope = 0
  4721  			v_form = V in R
  4722  			claim(r)
  4723  			%return
  4724  
  4725  f(V in R):
  4726              %return %if (v_base = r)
  4727  			dumprr(MOV, r, v_base)
  4728  			release(v_base)
  4729  			v_base = r
  4730  			v_disp = 0
  4731  			v_scope = 0
  4732  			v_form = V in R
  4733  			claim(r)
  4734  			%return
  4735  
  4736  f(A in S):
  4737              ! is the register a pointer?
  4738  			%if (r = BX) %or (r = SI) %or (r = DI) %start
  4739  				ptr = r
  4740  			%else
  4741  				ptr = pt reg
  4742  			%finish
  4743  			dumprm(MOV, ptr, v_base!v_scope, v_disp, v_extdisp )
  4744  			release(v_base)
  4745              claim(ptr)
  4746  			v_base = ptr
  4747  			v_disp = 0
  4748  			v_scope = 0
  4749  			%if (v_type = integer) %start
  4750  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  4751  			%else
  4752  				%if (v_type = byte) %start
  4753  					! watch out for register re-use here...
  4754  
  4755                      ! clear it, but only if it isn't needed
  4756  					%if (r # v_base) %then dumprr(XOR, r, r)
  4757  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  4758  
  4759                      ! otherwise a more expensive clear later
  4760  					%if (r = v_base) %then dumpri(AND, r, 255)
  4761  					v_type = integer
  4762  				%else
  4763                      ! reals
  4764  					abort("Load Real")
  4765  				%finish
  4766  			%finish
  4767  			release(v_base)
  4768  			v_base = r
  4769  			v_disp = 0
  4770  			v_scope = 0
  4771  			v_form = V in R
  4772  			claim(r)
  4773  			%return
  4774  
  4775  f(V in S):
  4776              %if (v_type = integer) %start
  4777  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  4778  			%else
  4779  				%if (v_type = byte) %start
  4780  					! watch out for register re-use here...
  4781  
  4782                      ! clear it, but only if it isn't needed
  4783  					%if (r # v_base) %then dumprr(XOR, r, r)
  4784  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  4785  
  4786                      ! otherwise a more expensive clear later
  4787  					%if (r = v_base) %then dumpri(AND, r, 255)
  4788  					v_type = integer
  4789  				%else
  4790                      ! reals
  4791  					abort("Load Real")
  4792  				%finish
  4793  			%finish
  4794  			release(v_base)
  4795  			v_base = r
  4796  			v_disp = 0
  4797  			v_scope = 0
  4798  			v_form = V in R
  4799  			claim(r)
  4800  			%return
  4801  
  4802  f(A V in S):
  4803  			%if (v_base # 0) %start
  4804  				dumprm(LEA, r, v_base!v_scope, v_disp, v_extdisp )
  4805  				release(v_base)
  4806  				v_type = integer
  4807  			%else
  4808  				! else
  4809  				%if (v_disp = 0) %and (v_scope = 0) %start
  4810  					dumprr(XOR, r, r)
  4811  				%else
  4812  					dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  4813  				%finish
  4814  			%finish
  4815  			v_base = r
  4816  			v_disp = 0
  4817  			v_scope = 0
  4818  			v_form = V in R
  4819  			claim(r)
  4820  			%return
  4821  		%end
  4822          ! LOAD REG
  4823  
  4824          ! JDM JDM Adapted from Store routine in Assign
  4825          ! Store the register item reg in location given by LHS stackfm.
  4826          ! This only deals with the integer registers.
  4827          ! Store Reg does NOT cater for floating point registers.
  4828          ! The destination can be one of:
  4829          ! 1) Integer
  4830          ! 2) Byte
  4831          ! 3) Name/Pointer
  4832          %routine Store Reg(%record(stackfm)%name lhs, %integer reg)
  4833  
  4834              %if (lhs_base = SP) %start
  4835                  ! it's a push
  4836                  %if (lhs_type = integer) %or (lhs_type = byte) %start
  4837                      dumpur(PUSH, reg)
  4838                  %finish
  4839              %finish %else %if (lhs_type = integer) %start
  4840                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  4841              %finish %else %if (lhs_type = byte) %start
  4842                  dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg+16)
  4843              %finish %else %if (lhs_type = record) %start
  4844                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  4845              %finish
  4846          %end
  4847          ! STORE REG
  4848  
  4849          !                                              >> OPERATION <<
  4850          ! perform the operation OP on the top two elements of the stack.
  4851          !   (single element for unary operators)
  4852          %routine  Operation(%integer op)
  4853              %record(stackfm)%name  lhs, rhs
  4854              %integer assign pending, work, value, s
  4855              %switch oper(1:17), roper(1:17), fold(1:17)
  4856              %constintegerarray opmap(1:17) = 
  4857+             ADD, SUB, IMUL, IDIV,  0,  AND, OR, XOR, SHL, SHR, IDIV,   0,    0,   0,  NOT, NEG,   0
  4858  
  4859              %constintegerarray flopmap(1:17) = 
  4860+             FADD, FSUB, FMUL, FDIV, 0, 0, 0, 0, 0, 0, 0,   0,   0,    FDIV, 0, FCHS, FABS
  4861  
  4862              %constintegerarray indec(-1:1) = DEC, 0, INC; ! decrement, and increment opcodes
  4863  
  4864              %routine swap
  4865                  %record(stackfm) temp
  4866                  temp = lhs
  4867                  lhs = rhs
  4868                  rhs = temp
  4869              %end
  4870  
  4871              assign pending = 0
  4872              rhs == top
  4873              %if (op < Unaries) %then %start
  4874                  lhs == stack(stp-1)
  4875                  %if (lhs_type = real) %or (lhs_type = lreal) %or (op >= REXPx) %then ->reals
  4876              %finish
  4877  
  4878              %if (rhs_type = real) %or (rhs_type = lreal) %then ->reals
  4879  
  4880              %if (rhs_form = constant) %and ((op >= Unaries) %or (lhs_form = constant)) %then ->fold(op)
  4881  
  4882              ! now look for optimisations for x = x <op> whatever
  4883              %if (Pending = 'S') %or (Pending = 'j') %start
  4884                  ! the next task is an assignment
  4885                  %if (op >= Unaries) %start
  4886                      %if (same(top, stack(stp-1)) # 0) %then assign pending = 1
  4887                  %else
  4888                      %if (same(lhs, stack(stp-2)) # 0) %then assign pending = 1
  4889                  %finish
  4890              %finish
  4891  
  4892              ->oper(op)
  4893  oper(NOTx):
  4894  oper(NEGx):
  4895              ! we optimise for e.g. fred = -fred as one instruction
  4896              %if (assign pending # 0) %then %start
  4897                  read symbol(Pending)
  4898                  address(rhs)
  4899                  %if (rhs_type = byte) %start
  4900                      dumpum8(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  4901                  %else
  4902                      dumpum(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  4903                  %finish
  4904                  pop rel
  4905                  pop rel
  4906                  %return
  4907              %finish
  4908              loadreg(rhs, any)
  4909              dumpur(opmap(op), rhs_base)
  4910              %return
  4911  
  4912              ! 8086 has no "abs" instructions, so we do a test and jump
  4913  oper(ABSx):
  4914              loadreg(rhs, any)
  4915  			dumpri(CMP, rhs_base, 0)
  4916              work = new tag
  4917              dumpjump(JGE, work)
  4918              dumpur(NEG, rhs_base)
  4919              dumplabel(work)
  4920              %return
  4921  
  4922  oper(ADDX):
  4923              %if (lhs_form = constant) %then swap
  4924              ! and fall through to minus
  4925  oper(SUBx):
  4926              ! First look for fred = fred + <whatever>
  4927              ! We can only safely do this for bytes if we're jamming or ignoring overflow
  4928              %if (assign pending # 0) %and %c
  4929+                 ((lhs_type = integer) %or ((control & check capacity) = 0) %or (Pending = 'j')) %then %start
  4930  
  4931                  ! we will do the assignment ourselves
  4932                  readsymbol(Pending)
  4933  
  4934                  ! make LHS accessible
  4935                  address(lhs)
  4936                  %if (rhs_form = constant) %then %start
  4937                      value = rhs_disp
  4938                      %if (value # 0) %start
  4939                          %if (op = SUBx) %then value = -value
  4940                          ! look for increment or decrement instructions
  4941                          %if (-2 < value < 2) %then %start
  4942                              %if (lhs_type = byte) %start
  4943                                  dumpum8(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  4944                              %else
  4945                                  dumpum(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  4946                              %finish
  4947                          %else
  4948                              %if (lhs_type = byte) %start
  4949                                  dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4950                              %else
  4951                                  dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4952                              %finish
  4953                          %finish
  4954                      %finish
  4955                  %else
  4956                      ! RHS not a constant
  4957                      loadreg(rhs, any)
  4958                      %if (lhs_type = byte) %start
  4959                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  4960                      %else
  4961                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  4962                      %finish
  4963                  %finish
  4964                  pop rel
  4965                  pop rel
  4966                  pop rel
  4967                  %return
  4968              %finish
  4969  
  4970              ! So, there is no assign pending        
  4971              %if (rhs_form = constant) %then %start
  4972                  value = rhs_disp
  4973                  %if (op = SUBx) %then value = -value
  4974                  ! If it is already an address, do the math on the address offset
  4975                  %if (lhs_form = AV in S) %or (lhs_form = AV in Rec) %start
  4976                      lhs_disp = lhs_disp + value
  4977                  %else
  4978                      loadreg(lhs, any)
  4979                      ! We don't particularly try for it, but if we ended up with a pointer
  4980                      ! register, we might as well convert this to use the address form...
  4981                      %if (lhs_base = BX) %start
  4982                          ! BX is the only GP reg that's also a pointer
  4983                          lhs_form = AV in S
  4984                          lhs_disp = value
  4985                      %else
  4986                          ! otherwise, don't bother deferring the operation
  4987                          ! look for increment or decrement instructions
  4988                          %if (-2 < value < 2) %then %start
  4989                              %if (value # 0) %then dumpur(indec(value), lhs_base)
  4990                          %else
  4991  							dumpri(opmap(op), lhs_base, rhs_disp)
  4992                          %finish
  4993                      %finish
  4994                  %finish
  4995              %else
  4996                  ! not a constant
  4997                  ! commutative?, so flip it
  4998                  %if (op = ADDx) %and (rhs_form = V in R) %then swap
  4999                  loadreg(lhs, any)
  5000                  %if (rhs_type = byte) %start
  5001                      loadreg(rhs, any)
  5002                  %else
  5003                      address(rhs)
  5004                  %finish
  5005                  dumprv(opmap(op), lhs_base, rhs)
  5006              %finish
  5007  
  5008              ! the RHS
  5009              pop rel
  5010              %return
  5011  oper(ANDx):
  5012  oper(ORx):
  5013  oper(XORx):
  5014              !  Logical ops are a subset of ADD - similar behaviour, but no inc/dec/addr short forms
  5015              %if lhs_form = constant %then swap
  5016              ! First look for fred = fred <op> <whatever>
  5017              %if (assign pending # 0) %then %start
  5018                  ! we will do the assignment ourselves
  5019                  readsymbol(Pending)
  5020  
  5021  				! make LHS accessible
  5022                  address(lhs)
  5023                  %if (rhs_form = constant) %then %start
  5024                      value = rhs_disp
  5025                      %if (lhs_type = byte) %start
  5026                          warn(8) %if (rhs_disp&(\255) # 0)
  5027                          dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5028                      %else
  5029                          dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5030                      %finish
  5031                  %else
  5032                      ! RHS not a constant
  5033                      loadreg(rhs, any)
  5034                      %if (lhs_type = byte) %start
  5035                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  5036                      %else
  5037                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  5038                      %finish
  5039                  %finish
  5040  
  5041                  ! RHS
  5042                  pop rel
  5043  
  5044                  ! LHS
  5045                  pop rel
  5046  
  5047                  ! Assignment destination
  5048                  pop rel
  5049  
  5050                  %return
  5051              %finish
  5052  
  5053              ! So, there is no assign pending        
  5054              %if (rhs_form = constant) %then %start
  5055                  value = rhs_disp
  5056                  loadreg(lhs, any)
  5057  				dumpri(opmap(op), lhs_base, value)
  5058              %else
  5059                  ! not a constant
  5060                  ! all these are commutative, so flip it to make it easier
  5061                  %if (rhs_form = V in R) %then swap
  5062                  loadreg(lhs, any)
  5063                  %if (rhs_type = byte) %and (op = ANDx) %start
  5064                      ! AND needs all the bits to make sense
  5065                      ! NB Load changes type to Integer
  5066                      loadreg(rhs, any)
  5067                  %else
  5068                      address(rhs)
  5069                  %finish
  5070                  %if (rhs_type = byte) %start
  5071                      ! must be V in S - everything else would be Integer
  5072                      dumprm8(opmap(op), lhs_base+16, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5073                  %else
  5074                      dumprv(opmap(op), lhs_base, rhs)
  5075                  %finish
  5076              %finish
  5077  
  5078              ! the RHS
  5079  			pop rel
  5080  
  5081              %return
  5082  
  5083  oper(MULx):
  5084              %if (lhs_form = constant) %or (rhs_base = AX) %then swap
  5085              %if (rhs_form = constant) %then %start
  5086                  value = rhs_disp
  5087                  %if (value = 0) %then %start
  5088                      ! mul by zero is zero
  5089                      release(lhs_base)
  5090                      lhs = rhs
  5091                      pop stack
  5092                      %return
  5093                  %finish
  5094                  %if (value = 1) %then %start
  5095                      ! mul by 1 is the identity
  5096                      pop stack
  5097                      %return
  5098                  %finish
  5099  
  5100                  ! find a shift factor
  5101                  s = mulshift(value)
  5102                  %if (s > 0) %then %start
  5103                      rhs_disp = s
  5104                      op = LSHx
  5105                      -> shift it
  5106                  %finish
  5107                  ! 8086 multiply instruction doesn't have an immediate operand form
  5108                  ! so we use an entry in the constant table...
  5109                  rhs_base = 0
  5110                  rhs_scope = COT
  5111                  rhs_disp = getcotw(value)
  5112                  rhs_form = V in S
  5113                  ! and fall through to the not-a-constant path
  5114              %finish
  5115  do mul:
  5116              loadreg(lhs, AX)
  5117              address(rhs)
  5118              hazard(DX)
  5119              %if (rhs_form = V in R) %start
  5120                  dumpur(IMUL, rhs_base)
  5121              %else
  5122                  dumpum(IMUL, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5123              %finish
  5124              pop rel
  5125              %return
  5126  oper(DIVx):
  5127  oper(REMx):
  5128              loadreg(lhs, AX)
  5129              address(rhs)
  5130              hazard(DX)
  5131              dumpsimple(CWD)
  5132              ! Plain 8086 Divide instruction also has no immediate operand form, so
  5133              ! we move constants to the COT
  5134              %if (rhs_form = constant) %start
  5135                  %if (rhs_disp = 0) %then warn(1)
  5136                  rhs_base = 0
  5137                  rhs_scope = COT
  5138                  rhs_disp = getcotw(rhs_disp)
  5139                  rhs_form = V in S
  5140              %finish
  5141              %if (rhs_form = V in R) %start
  5142                  dumpur(IDIV, rhs_base)
  5143              %else
  5144                  dumpum(IDIV, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5145              %finish
  5146              pop rel
  5147              %if (op = DIVx) %then %start
  5148                  lhs_base = AX
  5149              %else
  5150                  lhs_base = DX
  5151                  release(AX)
  5152                  claim(DX)
  5153              %finish
  5154              %return
  5155  oper(LSHx):
  5156  oper(RSHx):
  5157  shift it:
  5158              %if (assign pending # 0) %and %c
  5159+                 ((op = RSHx) %or (lhs_type = integer) %or (control&check capacity = 0) %or (Pending = 'j')) %then %start
  5160                  ! we will do the assignment ourselves
  5161                  readsymbol(Pending)
  5162  
  5163                  ! make LHS accessible
  5164                  address(lhs)
  5165                  %if (rhs_form = constant) %start
  5166                      warn(6) %unless (0 <= rhs_disp <= 31)
  5167                      %if (rhs_disp # 0) %start
  5168                          ! shift by zero is a no-op
  5169                          %if (lhs_type = byte) %start
  5170                              dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5171                          %else
  5172                              dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5173                          %finish
  5174                      %finish
  5175                  %else
  5176                      ! RHS not a constant
  5177                      ! Since the shift instruction only uses the bottom 5 bits of the
  5178                      ! value in CX, the value is "byte safe".  Rather than do a full
  5179                      ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  5180                      ! to save redundant coding
  5181                      %if (rhs_type = byte) %start
  5182                          hazard(CX)
  5183                          address(rhs)
  5184                          dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5185                      %else
  5186                          loadreg(rhs,CX)
  5187                      %finish
  5188                      %if (lhs_type = byte) %start
  5189                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CL)
  5190                      %else
  5191                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CX)
  5192                      %finish
  5193                  %finish
  5194  
  5195                  ! RHS
  5196                  pop rel
  5197                  ! LHS
  5198                  pop rel
  5199                  ! Assignment destination
  5200                  pop rel
  5201                  %return
  5202              %finish
  5203  
  5204              ! deal with constant shifts first...
  5205              %if (rhs_form = constant) %then %start
  5206                  value = rhs_disp
  5207                  warn(6) %unless (0 <= value <= 31)
  5208                  %if (value # 0) %start
  5209                      loadreg(lhs, any)
  5210  					dumpri(opmap(op), lhs_base, value)
  5211                  %finish
  5212              %else
  5213                  ! RHS variable
  5214                  ! Since the shift instruction only uses the bottom 4 bits of the
  5215                  ! value in CX, the value is "byte safe".  Rather than do a full
  5216                  ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  5217                  ! to save redundant coding
  5218                  %if (rhs_type = byte) %start
  5219                      hazard(CX)
  5220                      address(rhs)
  5221                      dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5222                      release(rhs_base)
  5223                      rhs_base = CX
  5224                      claim(CX)
  5225                  %else
  5226                      loadreg(rhs,CX)
  5227                  %finish
  5228                  loadreg(lhs, any)
  5229                  dumprr(opmap(op), lhs_base, CX);
  5230              %finish
  5231              pop rel
  5232              %return
  5233  oper(EXPx):
  5234              %if (rhs_form = constant) %then %start
  5235                  %if (rhs_disp = 0) %start
  5236                      pop rel
  5237                      pop rel
  5238                      push const(1)
  5239                      %return
  5240                  %finish
  5241                  %if (rhs_disp = 1) %then %start
  5242                      pop rel
  5243                      %return
  5244                  %finish
  5245                  %if (rhs_disp = 2) %then %start
  5246                      rhs = lhs
  5247                      claim(rhs_base)
  5248                      ->do mul
  5249                  %finish
  5250              %finish
  5251              loadreg(rhs, any)
  5252              dumpur(PUSH, rhs_base)
  5253              pop rel
  5254              loadreg(lhs, any)
  5255              dumpur(PUSH, lhs_base)
  5256              release(lhs_base)
  5257              perm(iexp, 2)
  5258              
  5259              lhs_base = AX
  5260              claim(AX)
  5261              lhs_form = V in R
  5262              %return
  5263  oper(REXPx):
  5264  oper(RDIVx):
  5265              abort("Oper unexpected op")
  5266  
  5267              !-----------------------------------------------
  5268              ! Fold constant expressions at compile time
  5269  fold(NEGx):
  5270              value = -rhs_disp; -> set unary
  5271  fold(NOTx):
  5272              value = \rhs_disp; -> set unary
  5273  fold(ABSx):
  5274              value = rhs_disp; %if (value < 0) %then value = -value; -> set value
  5275  fold(ADDx):
  5276              value = lhs_disp + rhs_disp; -> set value
  5277  fold(SUBx):
  5278              value = lhs_disp - rhs_disp; -> set value
  5279  fold(ORx):
  5280              value = lhs_disp ! rhs_disp; -> set value
  5281  fold(ANDx):
  5282              value = lhs_disp & rhs_disp; -> set value
  5283  fold(XORx):
  5284              value = lhs_disp !! rhs_disp; -> set value
  5285  fold(LSHx):
  5286              value = lhs_disp << rhs_disp; -> set value
  5287  fold(MULx):
  5288              value = lhs_disp * rhs_disp; -> set value
  5289  fold(RSHx):
  5290              value = lhs_disp >> rhs_disp; -> set value
  5291  fold(EXPx):
  5292              %if (rhs_disp < 0) %then abort("Fold -ve Exp")
  5293  			value = 1
  5294              %for op=1, 1, rhs_disp %cycle
  5295                  value = value * lhs_disp
  5296              %repeat
  5297              -> set value
  5298  fold(REMx):
  5299  fold(DIVx):
  5300              value = rhs_disp;
  5301              warn(1) %and value = 1 %if (value = 0)
  5302              value = lhs_disp // value
  5303              %if (op = DIVx) %then -> set value
  5304              value = lhs_disp - (rhs_disp * value)
  5305              -> set value
  5306  fold(REXPx):
  5307              abort("Fold REXPx - Not implemented")
  5308  fold(RDIVx):
  5309              abort("Fold RDIVx - Not implemented")
  5310  
  5311  set value:
  5312              pop stack
  5313  set unary:
  5314              top_disp = value
  5315              %return
  5316  fold(CONCx):
  5317              abort("Fold CONCx - Not implemented")
  5318  
  5319              !--------------------------------------------------------------------
  5320              ! String operations - the only one is concatenate...
  5321  oper(CONCx):
  5322              %if (assign pending # 0) %start
  5323                  ! It's S = S.T
  5324                  amap(lhs)
  5325                  loadreg(lhs, any)
  5326                  dumpur(PUSH, lhs_base)
  5327                  amap(rhs)
  5328                  loadreg(rhs, any)
  5329                  dumpur(PUSH, rhs_base)
  5330                  pop rel
  5331                  pop rel
  5332                  dumppushi(0, lhs_size, 0)
  5333                  %if (Pending = 'S') %then perm(sconc, 3) %else perm(sjconc, 3)
  5334                  ! and finally, skip the pending assignment, and drop the LHS
  5335                  readsymbol(Pending)
  5336                  pop rel
  5337                  %return
  5338              %finish
  5339  
  5340              ! here we've got T.U - if T is already in a WORK location
  5341              ! we've got a simple append.  If it is a user variable, we've
  5342              ! got to both copy it to a temp area and do the append
  5343              %if (Is Work(lhs) = 0) %start
  5344                  ! Not a work area
  5345                  work = getwork(256)
  5346                  push const(work)
  5347                  top_form = av in s
  5348                  top_base = BP
  5349                  loadreg(top, any)
  5350                  dumpur(PUSH, top_base)
  5351                  pop rel
  5352                  amap(lhs)
  5353                  loadreg(lhs, any)
  5354                  dumpur(PUSH, lhs_base)
  5355                  release(lhs_base)
  5356                  dumppushi(0, 255, 0)
  5357                  perm(smove, 3)
  5358                  ! Now we need to redefine the LHS as our temporary area
  5359                  ! gratuitous clear-it-all-out
  5360                  lhs = 0
  5361                  lhs_type = string
  5362                  lhs_form = V in S
  5363                  lhs_base = BP
  5364                  lhs_disp = work
  5365                  lhs_size = 255
  5366              %finish
  5367  
  5368              ! Here we are doing an in-situ concatenation
  5369              ! We want to leave the result as a normal variable, so we
  5370              ! suck up a copy for the AMAP fiddling
  5371              push copy(lhs)
  5372              amap(top)
  5373              loadreg(top, any)
  5374              dumpur(PUSH, top_base)
  5375              poprel
  5376              amap(rhs)
  5377              loadreg(rhs, any)
  5378              dumpur(PUSH, rhs_base)
  5379              pop rel
  5380              dumppushi(0, lhs_size, 0)
  5381              perm(sconc, 3)
  5382              %return
  5383  Reals:
  5384              %if (op < Unaries) %then loadreg(lhs, anyf)
  5385              %if (op # REXPx) %then loadreg(rhs, anyf)
  5386              ->roper(op)
  5387  
  5388  roper(NEGx):
  5389  roper(ABSx):
  5390              dumpfloprr(flopmap(op), rhs_base, rhs_base)
  5391              %return
  5392  
  5393  roper(ADDx):
  5394  roper(MULx):
  5395              ! Commutative, so we don't care
  5396              %if (lhs_base > rhs_base) %then swap
  5397              dumpfloprr(flopmap(op), lhs_base, rhs_base)
  5398              pop rel
  5399              %return
  5400  
  5401  roper(SUBx):
  5402  roper(DIVx):
  5403  roper(RDIVx):
  5404              ! We can't swap these, so we use the reverse form of
  5405              ! the opcode (which in our internal form is always one
  5406              ! more than the basic opcode index)
  5407              op = flopmap(op)
  5408              %if (lhs_base > rhs_base) %start
  5409                  swap
  5410                  op = op + 1
  5411              %finish
  5412              dumpfloprr(op, lhs_base, rhs_base)
  5413              pop rel
  5414              %return
  5415  
  5416  roper(REXPx):
  5417              ! This is implemented as a PERM routine
  5418              loadreg(rhs, any)
  5419              dumpur(PUSH, rhs_base)
  5420              pop rel
  5421              ! The usual slightly clunky floating point "push"
  5422              work = ptreg
  5423  			dumpri(SUB, SP, 8)
  5424              dumprr(MOV, work, SP)
  5425              dumpfloprm(FSTQ, work, 0, 0)
  5426              release(lhs_base)
  5427              perm(fexp, 1 + (8//word size))
  5428              ! Since rexp is actually a standard C routine, the result will
  5429              ! be on the FPU stack
  5430              ! JDM JDM All perm routines have been re-written in IMP
  5431              lhs_base = FR0
  5432              claim(FR0)
  5433              fpu stack = 1
  5434              lhs_form = V in R
  5435              lhs_type = lreal
  5436              %return
  5437  
  5438  roper(NOTx):
  5439  			abort("NOTx: Unsupported Real Operation")
  5440  roper(ANDx):
  5441  			abort("ANDx: Unsupported Real Operation")
  5442  roper(ORx):
  5443  			abort("ORx: Unsupported Real Operation")
  5444  roper(XORx):
  5445  			abort("XORx: Unsupported Real Operation")
  5446  roper(REMx):
  5447  			abort("REMx: Unsupported Real Operation")
  5448  roper(LSHx):
  5449  			abort("LSHx: Unsupported Real Operation")
  5450  roper(RSHx):
  5451  			abort("RSHx: Unsupported Real Operation")
  5452  roper(EXPx):
  5453  			abort("EXPx: Unsupported Real Operation")
  5454  
  5455          %end
  5456          !     Operation
  5457  
  5458          !                                              >> LOAD OPERATION <<
  5459          ! perform the operation OP on the top two elements of the stack.
  5460          !   (single element for unary operators)
  5461          ! This is a wrapper to Operation
  5462          ! It avoids multiple dumps of the Operation iCode instruction 
  5463          %routine  Load Operation(%integer op)
  5464  
  5465              ! JDM JDM debug show the iCode instruction
  5466              %if (ShowIcode=1) %start
  5467                  ListICodeNoOp
  5468              %finish
  5469              ! JDM JDM end debug
  5470  
  5471              Operation( op )
  5472          %end
  5473  
  5474          ! Store the item in RHS to LHS.  Encapsulates the difficulties
  5475          ! of variable length items and pushing things on the stack to
  5476          ! keep the rest of "Assign" looking tidy
  5477          %routine Store(%record(stackfm)%name lhs, rhs)
  5478              %integer pt, s, op
  5479  
  5480              %if (lhs_base = SP) %start
  5481                  ! it's a push
  5482                  %if (lhs_type = integer) %or (lhs_type = byte) %start
  5483                      %if (rhs_type = byte) %start
  5484                          loadreg(rhs, any)
  5485                      %else
  5486                          address(rhs)
  5487                      %finish
  5488                      dumpvpush(rhs)
  5489                  %else
  5490                      ! must be a real
  5491                      %if (lhs_type = real) %start
  5492                          s = 4
  5493                          op = FSTD
  5494                      %else
  5495                          s = 8
  5496                          op = FSTQ
  5497                      %finish
  5498                      loadreg(rhs, anyf)
  5499                      pt = ptreg
  5500                      dumpri(SUB, SP, s)
  5501                      dumprr(MOV, pt, SP)
  5502                      dumpfloprm(op, pt, 0, 0)
  5503                  %finish
  5504                  %return
  5505              %finish
  5506  
  5507              %if (lhs_type = integer) %start
  5508                  %if (rhs_form = constant) %and (rhs_scope = 0) %start
  5509                      dumpmi(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5510                  %else
  5511                      loadreg(rhs, any)
  5512                      dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  5513                  %finish
  5514              %else
  5515                  %if (lhs_type = byte) %start
  5516                      %if (rhs_form = constant) %and (rhs_scope = 0) %start
  5517                          dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5518                      %else
  5519                          %if (rhs_type = byte) %start
  5520                              ! try to avoid pointless promoting to an int
  5521                              ! We will reproduce a "Load" but without the word extension
  5522                              address(rhs)
  5523                              pt = gp reg
  5524                              dumprm8(MOV, pt+16, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5525                              release(rhs_base)
  5526                              rhs_base = pt
  5527                              rhs_form = V in R
  5528                              rhs_type = Integer
  5529                              claim(pt)
  5530                          %else
  5531                              loadreg(rhs, any)
  5532                              ! ABD - should add a capacity check here
  5533                          %finish
  5534                          dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  5535                      %finish
  5536                  %else
  5537                      loadreg(rhs, anyf)
  5538                      %if (lhs_type = real) %start
  5539                          op = FSTD
  5540                      %else
  5541                          ! long real
  5542                          op = FSTQ
  5543                      %finish
  5544                      dumpfloprm(op, lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  5545                  %finish
  5546              %finish
  5547          %end
  5548  
  5549          !                                                           >> ASSIGN <<
  5550          ! ASSOP =   -1:  parameter assignment
  5551          !            0:  == assignment
  5552          !            1:  =  assignment
  5553          !            2:  <- assignment
  5554          %routine  assign(%integer  assop )
  5555              %record(stackfm)%name  lh,rh
  5556              %record(stackfm)  temp
  5557              %integer  n, p, form, r
  5558  
  5559              abort("Assign Stack") %if (stp < 2)
  5560  
  5561              rh == top
  5562              lh == stack(stp-1)
  5563  
  5564              ! to avoid the ravages of amap, load etc
  5565              form = lh_form
  5566     
  5567              %if (diagnose&4 # 0) %start
  5568                  monitor(lh, "ASS LH")
  5569                  monitor(rh, "ASS RH")
  5570              %finish
  5571     
  5572              %if (same(lh, rh) # 0) %then %start
  5573                  pop rel
  5574                  pop rel
  5575                  %return
  5576              %finish
  5577  
  5578              %if (assop < 0) %start
  5579                  ! Parameter
  5580  
  5581                  %if (lh_base >= 128) %start
  5582                      ! Special - prim routine
  5583  
  5584                      ! JDM JDM comment
  5585                      ! The next iCode should be CALL (if not then an ERROR has arisen)
  5586                      ! So swop the stack entries ensuring the internal macro has valid parameters
  5587                      temp = lh
  5588                      lh = rh
  5589                      rh = temp
  5590                      %return
  5591                  %finish
  5592  
  5593                  ! Extract the next formal parameter and make it our target
  5594                  lh_pbase = lh_pbase - 1
  5595                  Stack Var(lh_pbase)
  5596                  ! Now make our destination look reasonable
  5597                  lh == top
  5598  
  5599                  ! target is the stack
  5600                  lh_base = SP
  5601   
  5602                  ! %name parameter is '=='
  5603                  assop = 0 %if (lh_form # V in S)
  5604  
  5605                  ! We need special treatment for procedure parameters
  5606                  %if (7 <= lh_aform <= 10) %start
  5607                      ! this is a procedure
  5608  
  5609                      ! we will treat it as a value assignment
  5610                      assop = 1
  5611  
  5612                      ! of an integer
  5613                      rh_type = integer
  5614                      lh_type = integer
  5615                      lh_form = V in S
  5616                      %if (rh_base # 0) %start
  5617                          ! RH is already a parameter
  5618                          rh_form = V in S
  5619                      %finish %else %if (rh_scope = EXT) %start
  5620                          ! it is an external procedure
  5621                          ! pick up the address
  5622                          rh_form = A V in S
  5623                      %finish %else %start
  5624                          ! it is a local procedure
  5625                          ! HACK: local procedures are Tags until Pass3 fixes them up.  The
  5626                          ! only way we have of converting tags to addresses is with the switch
  5627                          ! table - so we'll plant a fake switch entry for the label of the
  5628                          ! local routine, and then load that value!
  5629                          %if (swtp >= Max Switch) %then abort("Proc - Switch Table Full")
  5630                          swtab(swtp) = rh_disp
  5631                          rh_disp = swtp * word size
  5632                          swtp = swtp+1
  5633                          rh_scope = SWT
  5634                          rh_form = V in S
  5635                      %finish
  5636                  %finish
  5637              %finish
  5638  
  5639              %if (array <= rh_aform <= namearrayname) %start
  5640                  ! Arrayname
  5641                  ! An array name is two words - a pointer to the data and a
  5642                  ! pointer to the dope vector.  If the RHS is already one of these
  5643                  ! then we just want to copy the two words.  If it is a static
  5644                  ! array, we need to map the data to make a pointer, and its' dope
  5645                  ! vector will be in the constant table, so we fetch that.
  5646                  amap(lh)
  5647                  address(lh)
  5648  
  5649                  ! This works because arrays are stacked as V in S, arraynames are A in S
  5650                  amap(rh)
  5651                  address(rh)
  5652  
  5653                  ! We do the dope vector first - that makes it easier when we're parameter passing
  5654                  %if (rh_aform = array) %or (rh_aform = name array) %start
  5655                      ! simple static - DV in COT
  5656                      ! We will rustle up a dummy record for the DV address
  5657                      temp = 0
  5658                      temp_form = A V in S
  5659                      temp_type = integer
  5660                      temp_disp = rh_pbase
  5661                      temp_scope = COT
  5662                  %else
  5663                      ! already an array name
  5664                      temp = rh
  5665                      claim(temp_base)
  5666                      temp_disp = temp_disp + word size
  5667                  %finish
  5668                  lh_disp = lh_disp + word size
  5669                  store(lh, temp)
  5670                  release(temp_base)
  5671                  lh_disp = lh_disp - word size
  5672                  store(lh, rh)
  5673                  pop rel
  5674                  pop rel
  5675                  %return
  5676              %finish
  5677  
  5678              %if (lh_type = general) %start
  5679                  ! general %name parameter
  5680  
  5681                  ! Only '==' is allowed
  5682                  abort("Assign GenName") %unless (assop = 0)
  5683  
  5684                  ! A general name pointer is two words
  5685                  ! - the pointer itself
  5686                  ! and
  5687                  ! - a second word to convey type information.
  5688                  ! If the RHS is already one of these guys it's easy
  5689                  !   just copy the two words.
  5690                  ! else
  5691                  !   we must rustle up the second word at compile time
  5692  
  5693                  amap(lh)
  5694                  address(lh)
  5695                  %if (rh_type = general) %start
  5696                      ! RHS already a general pointer
  5697                      ! so, make a copy for the second word
  5698                      temp = rh
  5699                      claim(temp_base)
  5700                      temp_disp = temp_disp + word size
  5701                      amap(temp)
  5702                  %else
  5703                      ! RHS not a general pointer
  5704                      ! so, rustle up the second word
  5705                      temp = 0
  5706                      temp_type = integer
  5707                      temp_disp = (rh_size << 4) + gen map(rh_type)
  5708                  %finish
  5709  
  5710                  ! We do the words backwards, so that parameter push works
  5711                  lh_disp = lh_disp + word size
  5712                  store(lh, temp)
  5713                  release(temp_base)
  5714                  lh_disp = lh_disp-word size
  5715                  amap(rh)
  5716                  store(lh, rh)
  5717                  pop rel
  5718                  pop rel
  5719                  %return
  5720              %finish
  5721  
  5722              %if (assop = 0) %start
  5723                  ! ==
  5724                  ! destination
  5725                  amap(lh)
  5726  
  5727                  ! ABD %string(*)%name  NOT handled special here - should be?
  5728                  amap(rh)
  5729              %finish
  5730  
  5731              %if (Lh_Type = record) %start
  5732                  %if (lh_base = SP) %start
  5733                      ! pass record by value - destination is the stack
  5734                      n = lh_size
  5735                      hazard(DI)
  5736  					dumpri(SUB, SP, lh_size)
  5737                      dumprr(MOV, DI, SP)
  5738                      claim(DI)
  5739                      lh_base = DI
  5740                  %else
  5741                      n = Min Record Size(Lh, Rh)
  5742                      amap(lh)
  5743                      loadreg(lh, DI)
  5744                  %finish
  5745                  hazard(CX)
  5746  				dumpri(MOV, CX, n)
  5747                  %if (rh_Form = Constant) %start
  5748                      hazard(AX)
  5749                      ! Sneaky trick to get a zero
  5750                      dumprr(XOR, AX,AX)
  5751                      dumprepstosb
  5752                  %else
  5753                      amap(rh)
  5754                      loadreg(rh, SI)
  5755                      dumprepmovsb
  5756                  %finish
  5757                  pop rel
  5758                  pop rel
  5759                  %return
  5760              %finish
  5761  
  5762              %if (lh_type = string) %start
  5763                  %if (assop > 0) %and (rh_format = 1) %start
  5764                      ! null string as zero byte ?
  5765                      lh_type = byte
  5766  
  5767                      ! zap current RHS
  5768                      pop rel
  5769  
  5770                      ! get a zero
  5771                      push const(0)
  5772  
  5773                      ! and assign it
  5774                      assign(assop)
  5775                      %return
  5776                  %finish
  5777  
  5778                  ! our copy routines expect DEST then SOURCE then LENGTH on the stack
  5779                  %if (lh_base = SP) %start
  5780                      ! pass string by value - destination is the stack
  5781                      ! space is string size, plus one for length, plus make it even
  5782                      p = lh_size + 1; p = (p+align) & (\align)
  5783  					dumpri(SUB, SP, p)
  5784                      ! we want to Push SP here - sadly different versions of x86
  5785                      ! architecture have different interpretations of "PUSH SP", so...
  5786                      r = gp reg
  5787                      dumprr(MOV, r, SP)
  5788                      dumpur(PUSH, r)
  5789                  %else
  5790                      amap(lh)
  5791                      loadreg(lh, any)
  5792                      dumpur(PUSH, lh_base)
  5793                  %finish
  5794                  ! It is likely that the RH variable is a temporary work area
  5795                  ! Before we trash the information, we try to release it
  5796                  Return Work(rh_disp)
  5797                  amap(rh)
  5798                  loadreg(rh, any)
  5799                  dumpur(PUSH, rh_base)
  5800                  pop rel
  5801                  pop rel
  5802                  dumppushi(0, lh_size, 0)
  5803                  %if (assop = 2) %then perm(sjam, 3) %else perm(smove, 3)
  5804                  %return
  5805              %finish
  5806  
  5807              address(lh)
  5808              store(lh, rh)
  5809              pop rel
  5810              pop rel
  5811          %end
  5812          !  assign
  5813  
  5814          %routine  Load Assign(%integer  assop )
  5815  
  5816              ! JDM JDM debug show the iCode instruction
  5817              %if (ShowIcode=1) %start
  5818                  ListICodeNoOp
  5819              %finish
  5820              ! JDM JDM end debug
  5821  
  5822              assign( assop )
  5823          %end
  5824  
  5825          !                                                      >> ARRAY REF <<
  5826          ! Array references always use the PERM
  5827          ! unless they are 1 dimensional,
  5828          ! AND the %control bit has been turned off
  5829          %routine  array ref(%integer mode)
  5830              %record(stackfm)%name av
  5831              %integer type, form, size, format
  5832  
  5833              %if (mode # 0) %then %start
  5834                  ! Put non-terminal index onto stack for PERM
  5835                  %if (top_type = byte) %start
  5836                      loadreg(top, any)
  5837                  %else
  5838                      address(top)
  5839                  %finish
  5840                  dumpvpush(top)
  5841                  pop rel
  5842                  %return
  5843              %finish
  5844     
  5845              av == stack(stp-1)
  5846              size = av_size
  5847              size = size + 1 %if (av_type = string)
  5848              form = av_aform
  5849              %if (form=namearray) %or (form=namearrayname) %then size = word size
  5850  
  5851              %if (control&check array = 0) %and (av_dim = 1) %start
  5852                  ! This will be unchecked, the top of the stack is the only index (1D),
  5853                  ! so we can do a cheap multiplication here
  5854                  %if (size # 1) %start
  5855                      ! multiply offset by var size
  5856                      push const(size)
  5857                      Operation(MULx)
  5858                  %finish
  5859              %else
  5860                  ! This is the final (and perhaps only) subscript for a checked array,
  5861                  ! so we are going to use the Perm - therefore pass this as a parameter
  5862                  %if (top_type = byte) %start
  5863                      loadreg(top, any)
  5864                  %else
  5865                      address(top)
  5866                  %finish
  5867                  dumpvpush(top)
  5868                  pop rel
  5869              %finish
  5870  
  5871              ! How we do the rest of the access depends on whether this is a simple
  5872              ! static array, or an array name...
  5873  
  5874              %if (form = arrayname) %or (form = namearrayname) %start
  5875                  ! array is a "name"
  5876                  ! We will AMAP the name, so we remember the info and then put it all back later
  5877                  type = av_type
  5878                  format = av_format
  5879                  size = av_size
  5880                  %if (form = arrayname) %then form = V in S %else form = A in S
  5881                  amap(av)
  5882  
  5883                  %if (control&check array # 0) %or (av_dim > 1) %start
  5884                      ! do the rest of the check
  5885                      ! This is a bit clunky, because we may load registers in order
  5886                      ! to access AV, only to Hazard them for the PERM
  5887                      address(av)
  5888                      push copy(av)
  5889                      claim(top_base)
  5890  
  5891                      ! Dope Vector address follows A(0)
  5892                      top_disp = top_disp + word size
  5893                      dumpvpush(top)
  5894                      pop rel
  5895                      ! DV word, plus a word for every subscript
  5896                      perm(aref, av_dim + 1)
  5897                      push const(0)
  5898                      top_form = V in R
  5899                      top_base = AX
  5900                      claim(AX)
  5901                  %finish
  5902  
  5903                  ! make sure index is in a pointer register
  5904                  loadreg(top, anyp)
  5905                  Operation(ADDx)
  5906                  top_type = type
  5907                  top_form = form
  5908                  top_format = format
  5909                  top_size = size
  5910                  top_disp = 0
  5911              %else
  5912                  ! simple arrays are always 1D, but can still be checked
  5913                  %if (control&check array # 0) %start
  5914                      ! Pass a pointer to the Dope Vector
  5915                      ! simple arrays have compile-time DV's in the COT
  5916                      dumppushi(COT, av_pbase, 0)
  5917                      perm(aref, 2)
  5918                      push const(0)
  5919                      top_form = V in R
  5920                      top_base = AX
  5921                      claim(AX)
  5922                  %finish
  5923  
  5924                  address(av)
  5925                  %if (av_form # V in S) %then abort("Aref Form")
  5926                  %if (top_form = constant) %start
  5927                      ! simple constant a(k)
  5928                      ! just add it to the offset
  5929                      av_disp = av_disp + top_disp
  5930                  %else
  5931                      ! pick up index in a pointer
  5932                      loadreg(top, anyp)
  5933                      %if (av_base # 0) %start
  5934                          ! add the base we've already got
  5935                          dumprr(ADD, top_base, av_base)
  5936                          release(av_base)
  5937                      %finish
  5938                      av_base = top_base
  5939                  %finish
  5940                  %if (form = array) %then av_form = V in S %else av_form = A in S
  5941                  pop stack
  5942              %finish
  5943  
  5944              ! not an array any more
  5945              top_aform = 0
  5946  
  5947          %end
  5948          !  array ref
  5949  
  5950          %routine Load Array Ref( %integer mode )
  5951  
  5952              ! JDM JDM debug show the iCode instruction
  5953              %if (ShowIcode=1) %start
  5954                  ListICodeNoOp
  5955              %finish
  5956              ! JDM JDM end debug
  5957  
  5958              array ref( mode )
  5959          %end
  5960  
  5961          !                                              >> TEST ZERO <<
  5962          ! test a real/integer/byte variable against zero
  5963          %routine  test zero(%record(stackfm)%name  v)
  5964  
  5965              %if (v_type = integer) %or (v_type = byte) %start
  5966                  loadreg(v,any)
  5967  				dumpri(CMP, v_base, 0)
  5968              %else
  5969                  abort("Test Zero")
  5970              %finish
  5971          %end
  5972          ! test zero
  5973  
  5974          %routine Compare Records(%record(stackfm)%name L, R, %integer N)
  5975              ! JDM eventually compare the byte values of each record
  5976              ! in the interim, barf
  5977              abort("Compare Records")
  5978          %end
?N unused
?R unused
?L unused
  5979  
  5980          !                                              >> COMPARE REALS <<
  5981          %routine  compare reals(%record(stackfm)%name  l,r)
  5982              loadreg(l, anyf)
  5983              loadreg(r, anyf)
  5984              hazard(AX)
  5985              ! who's ended up on top?
  5986              ! l_base is the top of the FPU stack
  5987              %if (l_base > r_base) %start
  5988                  dumpfloprr(FCMP, r_base, l_base)
  5989              %else
  5990                  dumpfloprr(FCMP, l_base, r_base)
  5991                  invert = invert !! 1
  5992              %finish
  5993              ! puts status into AX
  5994              dumpflopspec(FSTSW)
  5995              ! and move it to flags
  5996              dumpsimple(SAHF)
  5997              ! because FPU reports as if operands were unsigned
  5998              compare unsign = 1
  5999          %end
  6000          ! compare reals
  6001  
  6002          !                                              >> COMPARE STRINGS <<
  6003          %routine  compare strings(%record(stackfm)%name  l,r)
  6004              %record(stackfm)%name  temp
  6005              %if (l_base = COT) %and (l_disp = null string) %start
  6006                  temp == r
  6007                  r == l
  6008                  l == temp
  6009                  invert = invert !! 1
  6010              %finish
  6011              %if (r_base = COT) %and (r_disp = null string) %start
  6012                  l_type = byte
  6013                  test zero(l)
  6014              %else
  6015                  amap(l)
  6016                  loadreg(l, any)
  6017                  dumpur(PUSH, l_base)
  6018                  amap(r)
  6019                  loadreg(r, any)
  6020                  dumpur(PUSH, r_base)
  6021                  perm(scomp, 2)
  6022  				dumpri(CMP, AX, 0)
  6023              %finish
  6024          %end
  6025          ! compare strings
  6026  
  6027          !                                              >> COMPARE <<
  6028          %routine  compare(%record(stackfm)%name  l,r)
  6029              %if (l_type = 0) %or (l_type = string) %start
  6030                  compare strings(l,r)
  6031                  %return
  6032              %finish
  6033              %if (floating(l) # 0) %or (floating(r) # 0) %start
  6034                  compare reals(l,r)
  6035                  %return
  6036              %finish
  6037              %if (zero(r) # 0) %start
  6038                  test zero(l)
  6039                  %return
  6040              %finish
  6041              %if (zero(l) # 0) %start
  6042                  test zero(r)
  6043                  invert = invert !! 1
  6044                  %return
  6045              %finish
  6046              %if (l_Type = Record) %start
  6047                  Compare Records(L, R, Min Record Size(L, R))
  6048                  %return
?access
  6049              %finish
  6050              loadreg(l,any)
  6051              %if (r_type = byte) %start
  6052                  loadreg(r, anyg)
  6053              %else
  6054                  address(r)
  6055              %finish
  6056              dumprv(CMP, l_base, r)
  6057          %end
  6058          ! compare
  6059  
  6060          !                                              >> RESOLVE <<
  6061          %routine  resolve( %integer  flag )
  6062  
  6063              ! JDM JDM debug show the iCode instruction
  6064              %if (ShowIcode=1) %start
  6065                  ListICode
  6066                  spaces(4)
  6067                  printstring( itos(flag,0) )
  6068                  newline
  6069              %finish
  6070              ! JDM JDM end debug
  6071  
  6072              !S -> A.(B).C
  6073              %if (flag&1 = 0) %then push const(0) %else amap(top); ! C missing?
  6074              loadreg(top, any)
  6075              dumpur(PUSH, top_base)
  6076              pop rel
  6077              amap(top);  ! B
  6078              loadreg(top, any)
  6079              dumpur(PUSH, top_base)
  6080              pop rel
  6081              %if (flag&2 = 0) %then push const(0) %else amap(top); ! A missing?
  6082              loadreg(top, any)
  6083              dumpur(PUSH, top_base)
  6084              pop rel
  6085              amap(top);  ! S
  6086              loadreg(top, any)
  6087              dumpur(PUSH, top_base)
  6088              pop rel
  6089              perm(sresln, 4)
  6090              %if (flag&4 # 0) %then dumpri(CMP, AX, 0)
  6091          %end
  6092          ! resolve
  6093  
  6094          %integerfn enter
  6095              %integer cad;
  6096  
  6097              uncond jump = -1; ! can get here
  6098  
  6099              ! This is a convenient place to include external definitions if needed
  6100              %if (potype >= external) %start
  6101                  fill external(CODE, next cad, external id)
  6102              %finish
  6103  
  6104              cad = nextcad;
  6105              dumpstaticalloc(cad, level, block name); ! plant dummy ENTER instruction and pass marker to pass 3
  6106              %result = cad;
  6107          %end
  6108  
  6109          !                                              >> DUMP RETURN <<
  6110          %routine  dump return
  6111              %return %if (uncond jump = next cad);          !  can't get here ?
  6112  
  6113              ! Pure 8086 would need these two
  6114              !	dumprr(MOV, SP, BP)
  6115              !	dumpur(POP, BP)
  6116              ! but now we use this instead...
  6117              dumpsimple(LEAVE)
  6118  
  6119              dumpsimple(RET);
  6120  
  6121              uncond jump = next cad
  6122          %end
  6123          ! return
  6124  
  6125          ! Routine to do "to string" as an in-line, either by making
  6126          ! a constant string in the CONST area, or putting one onto
  6127          ! the current workspace
  6128          %routine  compile to string(%record(stackfm)%name  v)
  6129              %integer tmp
  6130  
  6131              %if (const(v)#0) %start
  6132                  current string(0) = 1
  6133                  current string(1) = v_disp&255
  6134                  v_base = 0
  6135                  v_scope = COT
  6136                  v_disp = getcots(current string)
  6137              %else
  6138                  tmp = getwork(word size)
  6139                  loadreg(v,anyg);        ! Must be a byte-addressable register
  6140                  dumpmi(MOV, BP, tmp, 0, 1)
  6141                  dumpmr8(MOV, BP, tmp+1, 0, v_base+16)
  6142                  release(v_base)
  6143                  v_base = BP
  6144                  v_scope = 0
  6145                  v_disp = tmp
  6146              %finish
  6147              v_type = string
  6148              v_form = V in S
  6149              v_size = 1
  6150          %end
  6151  
  6152          !                                              >> COMPILE CALL <<
  6153          ! Call the routine on the top of the stack.  Note - the parameters
  6154          ! are all hidden underneath the routine, so we need to push them
  6155          ! here
  6156          %routine  Compile Call(%record(stackfm)%name  v)
  6157              %label form new type
  6158              ! switch b used for prim macro functions
  6159              %switch  b(0:15)
  6160              %string(255) tname
  6161              %integer     i
  6162  
  6163              !  0 = unknown/illegal macro call
  6164              !  1 = rem
  6165              !  2 = float
  6166              !  3 = to string
  6167              !  4 = addr
  6168              !  5 = integer
  6169              !  6 = byte integer
  6170              !  7 = string
  6171              !  8 = record
  6172              !  9 = real
  6173              ! 10 = long real
  6174              ! 11 = length
  6175              ! 12 = charno
  6176              ! 13 = type of ( type of general name parameter )
  6177              ! 14 = size of ( physical length in bytes )
  6178              ! 15 = int (from real)
  6179  
  6180              %conststring(15) %array macroname(0:15) =
  6181+             {  0 } "UNKNOWN",
  6182+             {  1 } "REM",
  6183+             {  2 } "FLOAT",
  6184+             {  3 } "TO STRING",
  6185+             {  4 } "ADDR",
  6186+             {  5 } "INTEGER",
  6187+             {  6 } "BYTE INTEGER",
  6188+             {  7 } "STRING",
  6189+             {  8 } "RECORD",
  6190+             {  9 } "REAL",
  6191+             { 10 } "LONG REAL",
  6192+             { 11 } "LENGTH",
  6193+             { 12 } "CHARNO",
  6194+             { 13 } "TYPEOF",
  6195+             { 14 } "SIZEOF",
  6196+             { 15 } "INT"
  6197  
  6198              %constbyteintegerarray  new type(5:12) =
  6199+                       integer, byte, string, record, real, lreal, byte, byte
  6200              %integer  t,l,p
  6201  
  6202              %if (v_base >= 128) %start
  6203                  !  built-in primitive
  6204                  l = 0;
  6205                  t = v_disp
  6206  
  6207                  ! 'sym=0' used as flag elsewhere
  6208                  sym = 0
  6209                  pop rel
  6210  
  6211                  ! JDM JDM defend against out-of-range value for t
  6212                  t = 0 %unless (0 < t < 16)
  6213  
  6214                  ! JDM JDM show start of macro "call" in listing
  6215                  ! Now to say which macro was requested
  6216                  selectoutput(listout)
  6217                  spaces(38)
  6218                  printstring( "Generating CODE for '" )
  6219                  printstring( macroname(t) )
  6220                  printstring( "' (MACRO ".itos(t,0).")")
  6221                  newline
  6222  
  6223                  -> b(t)
  6224  b(0):
  6225                  ! UNKNOWN/ILLEGAL macro
  6226                                                         -> esac
  6227  b(1):
  6228                  ! REM
  6229                  Operation(REMx)
  6230                                                         -> esac
  6231  b(2):
  6232                 ! FLOAT
  6233                 loadreg(top, anyf)
  6234                                                         -> esac
  6235  b(3):
  6236                 ! TO STRING
  6237                 compile to string(top)
  6238                                                         -> esac
  6239  b(4):
  6240                 ! ADDR
  6241                 amap(top)
  6242                                                         -> esac
  6243  b(5):
  6244                 ! INTEGER
  6245  b(6):
  6246                 ! BYTE
  6247  b(7):
  6248                 ! STRING
  6249  b(8):
  6250                ! RECORD
  6251  b(9):
  6252                ! REAL
  6253  b(10):
  6254                ! LONG REAL
  6255  
  6256  form new type:
  6257                  vmap(top)
  6258                  top_type = new type(t)
  6259                  top_size = v size(top_type)
  6260                                                         -> esac
  6261  
  6262  b(11):
  6263                  ! LENGTH
  6264                  push const(0);                      ! length is charno zero
  6265                  amap(stack(stp-1))
  6266                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  6267  
  6268                  ! JDM JDM avoid code duplication
  6269                                                         -> form new type
  6270  b(12):
  6271                  ! CHARNO
  6272                  amap(stack(stp-1))
  6273                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  6274  
  6275                  ! JDM JDM avoid code duplication
  6276                  -> form new type
  6277  
  6278  b(13):
  6279                  ! TYPE OF(..)
  6280                  %if (top_type = general) %start
  6281                      ! general type explicitly specified
  6282  
  6283                      ! reference property-word
  6284                      top_disp = top_disp + word size
  6285                      top_form = V in S
  6286                      top_type = integer
  6287                      push const(15)
  6288                      Operation(ANDx)
  6289  
  6290                  %finish %else %if (top_aform = simple) %start
  6291                      ! not a name or a bare array so get the core "typeof" value
  6292  
  6293                      ! convert top to be a constant
  6294                      release(top_base)
  6295                      top_type = integer
  6296                      top_form = constant
  6297                      top_aform = 0 {void}
  6298                      top_base = 0
  6299  
  6300                      ! store the expected datatype value as the constant value
  6301                      top_disp = gen map(top_type)
  6302  
  6303                  %finish %else %start
  6304                      ! unknown type explicitly specified
  6305  
  6306                      ! Now, to convert the top var into a constant
  6307                      ! Value to be loaded into top_disp
  6308                      ! The value stored should match the expected value of the
  6309                      ! datatype held in top
  6310                      ! The "typeof" extended value is a function of the top_type and top_aform
  6311                      
  6312                      ! Map the top var to the corresponding datatype value
  6313                      %if (top_aform = name) %start
  6314                          ! Ah, original var was a name
  6315                          ! give the extended "typeof" value for name
  6316                          ! should really define a constant for "typeof"=name
  6317                          p = 0
  6318                      %finish %else %if (array <= top_aform <= namearrayname) %start
  6319                          ! check if original var was an array (and no index values supplied)
  6320                          ! give the extended "typeof" value of array for the underlying type
  6321                          p = gen map(top_aform)
  6322                      %finish %else %start
  6323                          ! not a name or a bare array so get the core "typeof" value
  6324                          p = gen map(top_type)
  6325                      %finish
  6326  
  6327                      ! convert top to be a constant
  6328                      release(top_base)
  6329                      top_type = integer
  6330                      top_form = constant
  6331                      top_aform = 0 {void}
  6332                      top_base = 0
  6333                      ! store the expected data-type value as the constant value
  6334                      top_disp = p
  6335  
  6336  !                    ! JDM JDM new code to return extended "typeof" value
  6337  !                    ! release the top
  6338  !                    pop rel
  6339  !                    ! push a constant with the expected datatype value for "typeof" as the constant value
  6340  !                    push const(p)
  6341                  %finish
  6342  				                                       -> esac
  6343  b(14):
  6344                  ! SIZE OF(..)
  6345  
  6346                  %if (top_type = general) %start
  6347                      ! general type explicitly specified
  6348  
  6349                      ! reference property-word
  6350                      top_disp = top_disp + word size
  6351                      top_form = V in S
  6352                      top_type = integer
  6353                      push const(4)
  6354                      Operation(RSHx)
  6355  
  6356                  %finish %else %if (top_aform = simple) %start
  6357                      %if (top_type = string) %start
  6358                          ! string type explicitly specified
  6359   
  6360                          p = top_size + 1
  6361  
  6362                          release(top_base)
  6363                          top_type = integer
  6364                          top_form = constant
  6365                          top_base = 0
  6366                          top_disp = p
  6367                      %finish %else %start
  6368  
  6369                          p = top_size
  6370  
  6371                          release(top_base)
  6372                          top_type = integer
  6373                          top_form = constant
  6374                          top_base = 0
  6375                          top_disp = p
  6376                      %finish
  6377  
  6378                  %finish %else %if (array <= top_type <= namearrayname) %start
  6379                      ! array type explicitly specified
  6380  
  6381  !                    p = arraysize( top_pbase )
  6382  
  6383                      top_disp = top_disp + word size
  6384                      top_form = V in S
  6385                      top_type = integer
  6386                      push const(4)
  6387                      Operation(RSHx)
  6388  
  6389                  %finish %else %start
  6390                      ! other/unknown type explicitly specified
  6391  
  6392                      p = top_size
  6393  
  6394                      release(top_base)
  6395                      top_type = integer
  6396                      top_form = constant
  6397                      top_base = 0
  6398                      top_disp = p
  6399  
  6400                  %finish
  6401                                                         -> esac
  6402  b(15):
  6403                  ! INT(real)
  6404                  loadreg(top, anyf)
  6405                  release(top_base)
  6406                  p = getwork(word size)
  6407                  dumpfloprm(FSTI, BP, p, 0 )
  6408                  top_type = integer
  6409                  top_form = V in S
  6410                  top_base = BP
  6411                  top_disp = p
  6412  				                                       -> esac
  6413  esac:
  6414                  ! JDM JDM show macro "call" in listing
  6415                  ! Now to say which macro was requested
  6416                  selectoutput(listout)
  6417                  spaces(38)
  6418                  printstring( "CALL '" )
  6419                  printstring( macroname(t) )
  6420                  printstring( "' (MACRO ".itos(t,0).")")
  6421                  newline
  6422  
  6423  			%else
  6424                  !   -- normal routine calls --
  6425                  ! String functions have a hidden last parameter to point
  6426                  ! to the result area
  6427                  %if (v_type = string) %and (v_aform = 8) %start
  6428                      t = getwork(v_size+1)
  6429                      p = gp reg
  6430                      dumprm(LEA, p, BP, t, 0)
  6431                      dumpur(PUSH, p)
  6432                  %finish
  6433                  hazard all
  6434                  %if (v_scope = EXT) %start
  6435                      ! external
  6436                      dumpextcall(v_disp)
  6437                  %else
  6438                      %if (v_base # 0) %start
  6439                          ! procedure-as-parameter
  6440                          ! so, plant call indirect through variable
  6441                          dumpum(CALL, v_base, v_disp, v_extdisp )
  6442                      %else
  6443                          ! local routine
  6444                          ! plants fixup for the tag
  6445                          dumpjump(CALL, v_disp)
  6446                      %finish
  6447                  %finish
  6448                  ! adjust the stack
  6449                  %if (v_extra # 0) %then dumpri(ADD, SP, v_extra)
  6450                  %if (v_type = 0) %start
  6451                      ! not function or map
  6452                      pop rel
  6453                  %else
  6454                      ! Here we've got a result
  6455                      ! Result is local, even if the function wasn't
  6456                      v_scope = 0
  6457                      %if (v_type = string) %and (v_aform = 8) %start
  6458                          v_base = BP;             ! String result will have been copied back here
  6459                          v_disp = t
  6460                          v_form = V in S
  6461                      %else
  6462                          %if ((v_type = real) %or (v_type = lreal)) %and (v_aform = 8) %start
  6463                              ! Floating result will be on the FPU stack
  6464                              v_form = V in R
  6465                              v_base = FR0
  6466                              claim(FR0)
  6467                              fpu stack = 1
  6468                          %else
  6469                              ! Result is always in AX
  6470                              v_base = AX
  6471                              v_disp = 0;                ! Clear this for MAP results
  6472                              claim(AX)
  6473                          %finish
  6474                      %finish
  6475                  %finish
  6476  			%finish
  6477          %end;
?I unused
?TNAME unused
  6478               ;
  6478          !  Compile Call
  6479  
  6480          %routine Load Compile Call( %record(stackfm)%name  v )
  6481  
  6482              ! JDM JDM debug show the iCode instruction
  6483              %if (ShowIcode=1) %start
  6484                  ListICodeNoOp
  6485              %finish
  6486              ! JDM JDM end debug
  6487  
  6488              Compile Call( v )
  6489          %end
  6490  
  6491          !                                              >> COMPILE FOR <<
  6492          %routine  compile for( %integer lab )
  6493              %record(stackfm)%name  cv, iv, inc, fv
  6494              %integer  n
  6495  
  6496              ! JDM JDM debug show the iCode instruction
  6497              %if (ShowIcode=1) %start
  6498                  ListICode
  6499                  spaces(4)
  6500                  printstring( itos(lab,0) )
  6501                  newline
  6502              %finish
  6503              ! JDM JDM end debug
  6504  
  6505              ! Lock a value into a temporary to make sure it is invariant
  6506              %routine  stab(%record(stackfm)%name  v,  %integer  type)
  6507                  %integer  t,r
  6508                  %return %if (const(v) # 0)
  6509                  loadreg(v,any)
  6510                  r = v_base
  6511                  t = getwork(word size)
  6512                  dumpmr(MOV, BP,t, 0, r)
  6513                  v_base = BP
  6514                  v_disp = t
  6515                  v_scope = 0
  6516                  v_type = type
  6517                  v_form = V in S
  6518                  release(r)
  6519              %end
  6520  
  6521              iv == top
  6522              fv == stack(stp-1)
  6523              inc == stack(stp-2)
  6524              cv == stack(stp-3)
  6525  
  6526              stab(fv,integer)
  6527              stab(inc,integer)
  6528  
  6529              ! Check control variable is a plain value - otherwise save a pointer to it
  6530              ! in case it changes
  6531              %if (cv_form # v in s) %or ((0 < cv_base <= DI) %and (cv_base # BP)) %start
  6532                  n = cv_type
  6533                  amap(cv)
  6534                  stab(cv, n)
  6535                  cv_form = a in s
  6536              %finish
  6537     
  6538              push copy(cv)
  6539              push copy(iv)
  6540              push copy(inc);
  6541              Operation(SUBx)
  6542              assign(1);        ! cv = iv - inc
  6543  
  6544              define label(lab)
  6545              pop stack;! zap unwanted copy of IV
  6546  
  6547              ! Stack is now  top->[FV[INC[CV 
  6548              push copy(cv);		! in case compare alters it
  6549              compare(top, fv)
  6550              jump to(lab+1, JE, 1)
  6551              invert = 0; ! because the compare might have flipped this (N/A for JE)
  6552              ! Stack is now top->[CV'[FV[INC[CV where CV' is a register copy of CV
  6553              release(fv_base)
  6554  
  6555              ! trash FV and make a copy of CV' in that slot
  6556              fv = top
  6557  
  6558              ! discard the top copy
  6559              pop stack
  6560              ! stack is now top->[CV'[INC[CV
  6561              Operation(ADDx)
  6562              assign(1)
  6563          %end
  6564          ! for
  6565  
  6566  		%routine End of Block
  6567  			%if (amode >= 0) %start
  6568                  ! No return code for %endoffile
  6569  				dump return
  6570  
  6571                  ! don't include the display
  6572  				dumpstaticfill(staticalloc, frame+(level*word size), events, evep, evfrom)
  6573  			%finish
  6574  		%end
  6575  
  6576  		%routine Load End of Block
  6577  
  6578              ! JDM JDM debug show the iCode instruction
  6579              %if (ShowIcode=1) %start
  6580                  ListICodeNoOp
  6581              %finish
  6582              ! JDM JDM end debug
  6583  
  6584  			End of Block
  6585  		%end
  6586  
  6587  		%routine Compile Begin
  6588  			decvar == begin
  6589              decvar_disp = new tag
  6590  			otype = 0
  6591              spec = 0
  6592              potype = 0
  6593  			%if (level # 0) %start
  6594                  ! not outermost %begin
  6595  				push const(decvar_disp)
  6596  				top_type = 0;      ! it's not a function!
  6597  				compile call(top)
  6598  				skip proc = new tag
  6599  				dump jump(JMP, skip proc)
  6600  				dump label(decvar_disp);  ! this is where to call
  6601  			%finish
  6602  			assemble(0,labs,names)
  6603  			%if (level # 0) %start
  6604  				dump label(skip proc)
  6605  				last skip = next cad
  6606  				Uncond Jump = 0
  6607  			%finish
  6608  		%end
  6609  
  6610  		%routine Load Compile Begin
  6611  
  6612              ! JDM JDM debug show the iCode instruction
  6613              %if (ShowIcode=1) %start
  6614                  ListICodeNoOp
  6615              %finish
  6616              ! JDM JDM end debug
  6617  
  6618              Compile Begin
  6619          %end
  6620  
  6621          ! Utility routine used when dumping initialisers for OWNs
  6622          ! Note non-portable use of real values
  6623          %routine  adump
  6624              %integer i
  6625              %real		rv32
  6626              %switch ot(general:tlabel)
  6627  
  6628              ->ot(own type)
  6629  ot(general):
  6630              abort("General Own?")
  6631  ot(integer):
  6632              gput(ownval)
  6633              -> done
  6634  ot(real):
  6635              rv32 = rvalue
  6636              ! because our default variable is a 64 bit long real
  6637              %for i = 0,1,3 %cycle
  6638  				gbyte(byteinteger(addr(rv32)+i))
  6639  			%repeat
  6640  			-> done
  6641  ot(string):
  6642              %if (current string(0)+1 > data size) %start
  6643                  ! check for overflow
  6644  				! String constant too long - warn and truncate
  6645  				warn(5);  current string(0) = data size-1
  6646  			%finish
  6647  
  6648  			%for i = 0,1,data size-1 %cycle
  6649  				gbyte(current string(i))
  6650  			%repeat
  6651  			-> done
  6652  ot(record):
  6653              %for i = 1,1,data size %cycle
  6654  				gbyte(0)
  6655  			%repeat
  6656  			-> done
  6657  ot(byte):
  6658              gbyte(ownval)
  6659              -> done
  6660  ot(short):
  6661              gput(ownval)
  6662              -> done
  6663  ot(long):
  6664              gput(ownval)
  6665              -> done
  6666  ot(lreal):
  6667              %for i = 0,1,7 %cycle
  6668  				gbyte(byteinteger(addr(rvalue)+i))
  6669  			%repeat
  6670  			-> done
  6671  ot(tarray):
  6672              %for i = 1,1,data size %cycle
  6673  				gbyte(0)
  6674  			%repeat
  6675  			-> done
  6676  ot(tlabel):
  6677              gput(ownval)
  6678              -> done
  6679  
  6680  done:
  6681          %end
  6682  
  6683          %integerfn user label(%integer lab)
  6684              %record(varfm)%name v
  6685              %if (lab > names) %start
  6686                  names = lab
  6687                  v == var(lab)
  6688                  v = 0
  6689                  v_form = pgm label
  6690                  v_disp = new tag
  6691                  %result = v_disp
  6692              %finish
  6693              %result = var(lab)_disp
  6694          %end
  6695  
  6696  		%routine Compare Double
  6697  			LHS == stack(stp-1)
  6698  			RHS == top
  6699  			loadreg(rhs, any)
  6700  			! We happen to know that Compare loads the left parameter in a register.
  6701  			! We've already got RHS in a register, so we flip the LHS and RHS to the
  6702  			! comparison and set Invert accordingly
  6703  			compare(rhs, lhs)
  6704  			invert = 1
  6705  			! release LH and then overwrite it with RH
  6706  			release(lhs_base)
  6707  			lhs = rhs
  6708  			pop stack
  6709  		%end
  6710  
  6711  		%routine Load Compare Double
  6712  
  6713              ! JDM JDM debug show the iCode instruction
  6714              %if (ShowIcode=1) %start
  6715                  ListICodeNoOp
  6716              %finish
  6717              ! JDM JDM end debug
  6718  
  6719              Compare Double
  6720          %end
  6721  
  6722  		%routine Compare Values
  6723  			LHS == stack(stp-1)
  6724  			RHS == top
  6725  			compare(lhs,rhs)
  6726  			pop rel
  6727  			pop rel
  6728  		%end
  6729  
  6730  		%routine Load Compare Values
  6731  
  6732              ! JDM JDM debug show the iCode instruction
  6733              %if (ShowIcode=1) %start
  6734                  ListICodeNoOp
  6735              %finish
  6736              ! JDM JDM end debug
  6737  
  6738              Compare Values
  6739  		%end
  6740  
  6741  		%routine Compare Addresses
  6742  			amap(top);
  6743  			amap(stack(stp-1));                  ! Now do same as compare values
  6744  			Compare Values
  6745  		%end
  6746  
  6747  		%routine Load Compare Addresses
  6748  
  6749              ! JDM JDM debug show the iCode instruction
  6750              %if (ShowIcode=1) %start
  6751                  ListICodeNoOp
  6752              %finish
  6753              ! JDM JDM end debug
  6754  
  6755              Compare Addresses
  6756  		%end
  6757  
  6758  		%routine Define Compiler Label( %integer label)
  6759  
  6760              ! JDM JDM debug show the iCode instruction
  6761              %if (ShowIcode=1) %start
  6762                  ListICode
  6763                  spaces(4)
  6764                  printstring( itos(label,0) )
  6765                  newline
  6766              %finish
  6767              ! JDM JDM end debug
  6768  
  6769  			%if (label = 0) %start
  6770  				dump label(skipproc)
  6771  				last skip = next cad
  6772  				Uncond Jump = 0
  6773  			%else
  6774  				define label( label );
  6775  			%finish
  6776  		%end
  6777  
  6778  		%routine Init( %integer N )
  6779  			! N = Number of values to assign
  6780  			%integer j
  6781  
  6782              ! JDM JDM debug show the iCode instruction
  6783              %if (ShowIcode=1) %start
  6784                  ListICode
  6785                  spaces(4)
  6786                  printstring( itos(N,0) )
  6787                  newline
  6788              %finish
  6789              ! JDM JDM end debug
  6790  
  6791  			%if (stp # 0) %start
  6792                  ! Value supplied?
  6793  				own val = top_disp
  6794  				%if (own type = real) %or (own type = lreal) %start
  6795  					rvalue = own val %if (top_type = integer);  ! copy integer supplied into floater
  6796  				%finish
  6797  				pop stack
  6798  			%else
  6799                  ! initialise to default pattern
  6800  				ownval = 0
  6801  				current string(0) = 0;     ! in case it's a string
  6802  			%finish
  6803  
  6804  			%if (own form = array) %or (own form = name array) %start
  6805  				adump %for j = 1,1,N
  6806  			%else
  6807  				%if (otype = 0) %start
  6808                      ! %const .... %name
  6809  !					Abort("Constant Name");
  6810  					! JDM attempt to allow assignment of %const ... %name
  6811  					decvar_scope = COT
  6812  					decvar_level = 0
  6813  					decvar_disp = own val
  6814  				%else
  6815  					! non-array normal variables
  6816  					decvar_level = 0
  6817  					%if (otype = con) %start
  6818  						! constant - must be string or real type, because
  6819  						! const integers are substituted by value in Pass 1
  6820  						! Constant strings and reals are treated as literals
  6821  						decvar_scope = COT
  6822  						%if (own type = string) %start
  6823  							decvar_disp = getcots(current string)
  6824  						%else
  6825  							%if (own type = real) %or (own type = lreal) %start
  6826  								! constant reals are put in the COT.  Depending on how
  6827  								! the value was formed, ReadReal may have already planted this.
  6828  								! Not to worry, because "real constant" will find it again.
  6829  								decvar_disp = getcotdouble(rvalue)
  6830  							%else
  6831  								abort("Init?")
  6832  							%finish
  6833  						%finish
  6834  					%else
  6835  						! must be %own or %external - use adump to put it in DATA segment
  6836  						decvar_scope = DATA
  6837  						decvar_disp = datatp
  6838  						adump
  6839  					%finish
  6840  				%finish
  6841  			%finish
  6842  		%end
  6843  
  6844  		%routine User Jump( %integer label )
  6845  
  6846              ! JDM JDM debug show the iCode instruction
  6847              %if (ShowIcode=1) %start
  6848                  ListICode
  6849                  spaces(4)
  6850                  printstring( itos(label,0) )
  6851                  newline
  6852              %finish
  6853              ! JDM JDM end debug
  6854  
  6855  			dumpjump(JMP, user label( label ))
  6856  		%end
  6857  
  6858  		%routine Define User Label( %integer label )
  6859  
  6860              ! JDM JDM debug show the iCode instruction
  6861              %if (ShowIcode=1) %start
  6862                  ListICode
  6863                  spaces(4)
  6864                  printstring( itos(label,0) )
  6865                  newline
  6866              %finish
  6867              ! JDM JDM end debug
  6868  
  6869  			dump label(user label( label ))
  6870  		%end
  6871  
  6872  		%routine Return( %integer mode)
  6873  			%integer i
  6874  
  6875  			%if (mode = False) %start
  6876  				dumpri(MOV, AX, 0)
  6877  			%finish
  6878  
  6879  			%if (mode = True) %start
  6880  				dumpri(MOV, AX, -1)
  6881  			%finish
  6882  
  6883  			%if (mode = Map) %start
  6884  				amap(top)
  6885  				loadreg(top, AX)
  6886  				pop rel
  6887  			%finish
  6888  
  6889  			%if (mode = Fn) %start
  6890  				%if (procvar_type = integer) %start
  6891  					loadreg(top, AX)
  6892  					pop rel
  6893  				%else
  6894  					%if (procvar_type = real) %or (procvar_type = lreal) %start
  6895  						! Floating point results are put into store, and AX contains
  6896  						! the address
  6897  						! JDM - No, not for 32-bit code for IA-32 architecture ABI
  6898  						! JDM - floating point results go onto the floating point stack in ST(0)
  6899  						! JDM - that is the returned floating point stack should only be 1 deep
  6900  						! JDM: loadreg(top,anyf) should push the result onto the floating point stack
  6901  						loadreg(top, anyf);
  6902  						pop rel
  6903  					%else
  6904                          ! string or record - pass back through the hidden parameter
  6905  						push copy(top);            ! Make a copy of the thing on top
  6906  						lhs == stack(stp-1);       ! point to the (now spare) next item
  6907  						lhs_type = procvar_type;   ! and make it look like a destination
  6908  						lhs_size = procvar_size
  6909  						lhs_format = procvar_format
  6910  						lhs_base = BP
  6911  						lhs_disp = word size * 2;  ! At the offset of the last parameter
  6912  						lhs_form = a in s
  6913  						assign(1)
  6914  					%finish
  6915  				%finish
  6916  			%finish
  6917  
  6918  			%if (mode = Routine) %start
  6919  				! no need to do anything special
  6920  			%finish
  6921  
  6922  			dump return
  6923  		%end
?I unused
  6924  
  6925  		%routine Load Return( %integer mode )
  6926  
  6927              ! JDM JDM debug show the iCode instruction
  6928              %if (ShowIcode=1) %start
  6929                  ListICodeNoOp
  6930              %finish
  6931              ! JDM JDM end debug
  6932          
  6933              Return( mode )
  6934          %end
  6935  
  6936  		%routine Dimension( %integer dim, n )
  6937  			%integer i,j
  6938  
  6939              ! JDM JDM debug show the iCode instruction
  6940              %if (ShowIcode=1) %start
  6941                  ListICode
  6942                  spaces(4)
  6943                  printstring( itos(dim,0) )
  6944                  printsymbol( ',' )
  6945                  printstring( itos(n,0) )
  6946                  newline
  6947              %finish
  6948              ! JDM JDM end debug
  6949  
  6950  			! Validate the ICODE Parameters
  6951  			abort("Array Dim") %unless (0 < dim < 6)
  6952  
  6953  			%if (in params # 0) %start;         ! Array in record
  6954  				parms = parms + n
  6955  				vub = top_disp
  6956                  pop stack
  6957  				vlb = top_disp
  6958                  pop stack
  6959  				abort("Array Bounds") %if (vlb > vub)
  6960  				dv = set dope vector
  6961  			%else
  6962  				names = names - n
  6963  				! Now we need to plant code to manufacture a dope vector
  6964  				frame = (frame - ((dim * (2 * word size))+(2 * word size)))&(\align);  ! space for :Dim:<bound pairs>:DataSize:
  6965  				dv = frame
  6966  				! First store the dimension
  6967  				dumpmi(MOV, BP, dv, 0, dim)
  6968  				! And the data size is also constant
  6969  				dumpmi(MOV, BP, dv + (dim * (2 * word size)) + word size, 0, data size)
  6970  				! Now the bounds
  6971  				j = 0;                    ! points to before the first stack value
  6972  				%for i=1,1,dim*2 %cycle
  6973  					j = j + 1
  6974                      lhs == stack(j)
  6975  					%if (lhs_form = constant) %start
  6976  						dumpmi(MOV, BP, dv + (i*word size), 0, lhs_disp)
  6977  					%else
  6978  						loadreg(lhs, any)
  6979  						dumpmr(MOV, BP, dv + (i*word size), 0, lhs_base)
  6980  					%finish
  6981  				%repeat
  6982  				! Now we need to allocate the space for the array
  6983  				%if (dim > 1) %or (control&check array # 0) %start
  6984  					! Do it with the PERM
  6985  					%while (stp # 0) %cycle
  6986                          ! get rid of all the bounds - they are in the DV already
  6987  						pop rel
  6988  					%repeat
  6989  					dumprm(LEA, AX, BP, dv, 0)
  6990  					dumpur(PUSH, AX)
  6991  					perm(adef, 1)
  6992  					! We now need to make our result match the inline version
  6993  					! by putting AX and DX into stacklike variables
  6994  					push const(0)
  6995                      lhs == top
  6996  					
  6997                      push const(0)
  6998                      rhs == top
  6999  					
  7000                      lhs_base = AX
  7001                      lhs_form = V in R
  7002                      claim(AX)
  7003  
  7004  					rhs_base = DX
  7005                      rhs_form = V in R
  7006                      claim(DX)
  7007  
  7008  					pop stack
  7009  					pop stack
  7010  				%else
  7011  					push const(1)
  7012  					Operation(ADDx)
  7013  					push const(data size)
  7014  					Operation(MULx)
  7015  					push copy(stack(stp-1));   ! suck up the lower bound
  7016  					push const(data size)
  7017  					Operation(MULx)
  7018  					! top is now the lower bound, next is the upper, and a bogus copy of lb is next
  7019  					loadreg(top, any);   ! Make sure this is in a register
  7020  					lhs == top;          ! Point to it
  7021  					pop stack;           ! and drop (without release) this copy
  7022  					loadreg(top, any);   ! This is now UB - load it in a register as well
  7023  					rhs == top;          ! Point to it
  7024  					pop stack;           ! and keep RHS (Upper)
  7025  					pop stack;           ! dump the bogus lb
  7026  				%finish
  7027  				! Note - there are 4 GP registers, and we're going to need them ALL here
  7028  				t = gp reg;             ! get a working register for the dope vector address
  7029  				dumprm(LEA, t, BP, dv, 0); ! load it
  7030  				dv = t
  7031                  claim(dv);              ! use this to hold the register number
  7032  				t = gp reg;             ! the last one! (which we don't claim, 'cos we can't lose it)
  7033  				dumprr(MOV, t, SP);	   ! working copy of SP so that real SP is always "OK"
  7034  			%finish
  7035  
  7036  			%for i = 1,1,n %cycle
  7037  				decvar_dim = dim
  7038  				%if (in params = 0) %start
  7039                      !  array not in record
  7040  					names = names+1
  7041                      decvar == var(names)
  7042  					decvar_level = level
  7043  					frame = frame - (word size * 2);  ! 2-word header
  7044  					decvar_disp = frame
  7045  					%if (decvar_form = array) %or (decvar_form = namearray) %then decvar_form = decvar_form + 1;         ! force arrayname
  7046  					dumprr(SUB, t, rhs_base);
  7047  					dumpmr(MOV, BP, frame, 0, t);             ! store a(0) address
  7048  					dumpmr(MOV, BP, frame + word size, 0, dv);! store dope vector pointer
  7049  					dumprr(ADD, t, lhs_base);
  7050  				%else;          ! array-in-record
  7051  					parms = parms-1
  7052                      decvar == var(parms)
  7053  					decvar_disp = frame - vlb
  7054  					frame = frame + vub; ! noting that Set Dope Vector has changed VUB to the array size
  7055  					decvar_pbase = dv
  7056  				%finish
  7057  			%repeat
  7058  
  7059  			%if (in params = 0) %start
  7060  				! We need to keep the stack pointer word aligned - 8086's run faster that way,
  7061  				! and more importantly, Pentiums throw an exception if you don't!
  7062  				%if (data size&align # 0) %then dumpri(AND, t, \align)
  7063  				dumprr(MOV,SP,t)
  7064  				release(lhs_base)
  7065  				release(rhs_base)
  7066  				release(dv)
  7067  			%finish
  7068  		%end
  7069  
  7070  		%routine Update Line( %integer line )
  7071  
  7072              ! JDM JDM debug show the iCode instruction
  7073              %if (ShowIcode=1) %start
  7074                  ListICode
  7075                  spaces(4)
  7076                  printstring( itos( line,0) )
  7077                  newline
  7078              %finish
  7079              ! JDM JDM end debug
  7080  
  7081  			current line = line
  7082  			abort("Stack?") %if (stp # 0)
  7083  			abort("Claimed") %if (claimed # 0)
  7084  			! Pass1 sends the line number multiple times if there's more than
  7085  			! one statement per line - for debugging we only want "real" line numbers
  7086  			%if (echo line < current line) %start
  7087  				dump line number(current line)
  7088  				%while (echo line < current line) %cycle
  7089  					echo source line
  7090  				%repeat
  7091  			%finish
  7092  		%end
  7093  
  7094  		%routine Switch Jump( %integer switch id )
  7095  
  7096              ! JDM JDM debug show the iCode instruction
  7097              %if (ShowIcode=1) %start
  7098                  ListICode
  7099                  spaces(4)
  7100                  printstring( itos(switch id,0) )
  7101                  printsymbol( ',' )
  7102                  printsymbol( '=' )
  7103                  printsymbol( '"' )
  7104                  printstring( var( switch id)_idname )
  7105                  printsymbol( '"' )
  7106                  newline
  7107              %finish
  7108              ! JDM JDM end debug
  7109  
  7110  			v == var( switch id )
  7111  			push const(word size)
  7112              Operation(MULx);        ! subscript X Word Size
  7113  			loadreg(top, anyp)
  7114  			dumpum(JMP, SWT!top_base, v_disp * word size, 0);	! swtab is word-size
  7115  			pop rel
  7116  			uncond jump = next cad
  7117  		%end
  7118  
  7119  		%routine Set Record Format( %integer format id )
  7120  
  7121              ! JDM JDM debug show the iCode instruction
  7122              %if (ShowIcode=1) %start
  7123                  ListICode
  7124                  spaces(4)
  7125                  printstring( itos(format id,0) )
  7126                  printsymbol( ',' )
  7127                  printsymbol( '=' )
  7128                  printsymbol( '"' )
  7129                  printstring( var( format id)_idname )
  7130                  printsymbol( '"' )
  7131                  newline
  7132              %finish
  7133              ! JDM JDM end debug
  7134  
  7135  			top_format = format id
  7136  			top_type   = record
  7137  		%end
  7138  
  7139  		%routine Switch Label( %integer switch label )
  7140  
  7141              ! JDM JDM debug show the iCode instruction
  7142              %if (ShowIcode=1) %start
  7143                  ListICode
  7144                  spaces(4)
  7145                  printstring( itos(switch label,0) )
  7146                  printsymbol( ',' )
  7147                  printsymbol( '=' )
  7148                  printsymbol( '"' )
  7149                  printstring( var( switch label)_idname )
  7150                  printsymbol( '"' )
  7151                  newline
  7152              %finish
  7153              ! JDM JDM end debug
  7154  
  7155  			v == var( switch label )
  7156  			uncond jump = 0
  7157  			j = top_disp
  7158              pop stack
  7159              
  7160              t = new tag
  7161  			dumplabel(t);
  7162  			swtab(v_disp+j) = t;
  7163  		%end
  7164  
  7165  		%routine Constant Bounds
  7166  			vub = top_disp
  7167              pop stack
  7168  
  7169  			vlb = top_disp
  7170              pop stack
  7171  		%end
  7172  
  7173  		%routine Load Constant Bounds
  7174  
  7175              ! JDM JDM debug show the iCode instruction
  7176              %if (ShowIcode=1) %start
  7177                  ListICodeNoOp
  7178              %finish
  7179              ! JDM JDM end debug
  7180  
  7181              Constant Bounds
  7182          %end
  7183  
  7184  		%routine Internal Handler ( %integer id )
  7185  			push const(0) %while (stp < 2)
  7186  			push const( id )
  7187  			loadreg(top, any)
  7188              dumpur(PUSH, top_base)
  7189              pop rel
  7190  			
  7191              loadreg(top, any)
  7192              dumpur(PUSH, top_base)
  7193              pop rel
  7194  			
  7195              loadreg(top, any)
  7196              dumpur(PUSH, top_base)
  7197              pop rel
  7198  
  7199  			perm(signal, 3)
  7200  			uncond jump = next cad %if (id # -1);     ! %monitor will return
  7201  		%end
  7202  
  7203  		%routine Signal Event( %integer event id )
  7204  
  7205              ! JDM JDM debug show the iCode instruction
  7206              %if (ShowIcode=1) %start
  7207                  ListICode
  7208                  spaces(4)
  7209                  printstring( itos(event id,0) )
  7210                  newline
  7211              %finish
  7212              ! JDM JDM end debug
  7213  
  7214  			Internal Handler ( event id )
  7215  		%end
  7216  
  7217  		%routine Monitor
  7218  			Internal Handler ( -1 )
  7219  		%end
  7220  
  7221          %routine Load Monitor
  7222  
  7223              ! JDM JDM debug show the iCode instruction
  7224              %if (ShowIcode=1) %start
  7225                  ListICodeNoOp
  7226              %finish
  7227              ! JDM JDM end debug
  7228  
  7229              Monitor
  7230          %end
  7231  
  7232  		%routine SelectField( %integer field index )
  7233  
  7234              ! JDM JDM debug show the iCode instruction
  7235              %if (ShowIcode=1) %start
  7236                  ListICode
  7237                  spaces(4)
  7238                  printstring( itos(field index,0) )
  7239                  newline
  7240              %finish
  7241              ! JDM JDM end debug
  7242  
  7243  			! Contrary to earlier iCode versions, this one seems to use 'n' for
  7244  			! both normal record member access and alternate formats?
  7245  
  7246              ! Points to the base record
  7247  			lhs == top
  7248  
  7249              ! Push descriptor for the i-th member
  7250  			Stack Var(var(top_format)_pbase - field index)
  7251  
  7252  			%if (top_aform # recordformat) %start
  7253                  !  not record format - must be a member
  7254  				%if (lhs_form = V in S) %or (lhs_form = V in REC) %start
  7255  					top_disp = top_disp + lhs_disp
  7256  					lhs_form = lhs_form - V in S + top_form
  7257  				%else
  7258  					%if (lhs_form = A in REC) %start
  7259  						lhs_form = V in REC
  7260                          lhs_type = integer
  7261  						loadreg(lhs,any)
  7262  						lhs_form = top_form
  7263  					%else
  7264  						%if (lhs_form <= V in R) %start
  7265  							lhs_form = top_form;    ! ????
  7266  						%else
  7267                              ! A in S
  7268  							lhs_extra = lhs_disp
  7269  							lhs_form = top_form + 3
  7270  						%finish
  7271  					%finish
  7272  				%finish
  7273  				lhs_disp = top_disp
  7274  				lhs_type = top_type
  7275  				lhs_aform = top_aform
  7276  				lhs_dim = top_dim
  7277  			%finish
  7278  			lhs_size = top_size
  7279              lhs_format = top_format
  7280  			pop stack
  7281  		%end
  7282  
  7283  		%routine EventTrap( %integer anevent, evfrom )
  7284  			! events: Events to trap (then comma)
  7285  			! evfrom: Label to skip to
  7286  			%integer temp
  7287  
  7288              ! JDM JDM debug show the iCode instruction
  7289              %if (ShowIcode=1) %start
  7290                  ListICode
  7291                  spaces(4)
  7292                  printstring( itos(anevent,0) )
  7293                  printsymbol( ',' )
  7294                  printstring( itos(evfrom,0) )
  7295                  newline
  7296              %finish
  7297              ! JDM JDM end debug
  7298  
  7299  			events = anevent
  7300  			temp = getwork(word size);	    ! get a temp location for SP
  7301  			dumpmr(MOV, BP, temp, 0, SP);	! because our signaller doesn't restore it
  7302  			jump to(evfrom, JMP, 1);	    ! go there now
  7303  			! We need to make EVFROM into a label ID that pass 3 will recognise
  7304  			! to build the trap table, so Jump To sets a variable we pick up here...
  7305  			evfrom = J Tag
  7306  			evep = new tag;				    ! tag for the event body entry point
  7307  			dump label(evep);			    ! which is here
  7308  			dumprm(MOV, SP, BP, temp, 0);	! First thing we do is restore SP
  7309  		%end
  7310  
  7311  		%routine DoubleOp( %integer opr )
  7312  			%integer j,t
  7313  
  7314  			lhs == stack(stp-1)
  7315  			t = lhs_type;
  7316  			j = lhs_size
  7317  			j = j+1 %if t = string
  7318  			amap(lhs)
  7319  			abort("++/-- size") %if (j = 0)
  7320  			push const(j)
  7321  			Operation(MULx)
  7322  			Operation(opr)
  7323  			vmap(top)
  7324              top_type = t
  7325  		%end
  7326  
  7327  		%routine Set CD(%integer Value, %integername CD)
  7328  
  7329              ! JDM JDM debug show the iCode instruction
  7330              %if (ShowIcode=1) %start
  7331                  ListICode
  7332                  spaces(4)
  7333                  printstring( itos(value,0) )
  7334                  newline
  7335              %finish
  7336              ! JDM JDM end debug
  7337  
  7338              ! JDM set value for the appropriate compiler pass
  7339              ! In this case we are in pass2
  7340  			CD = Value&x'3FFF' %if (Value&x'C000' = (PassId&3)<<14)
  7341  		%end
  7342  
  7343  		%predicate Finish Params
  7344  			%integer j
  7345  
  7346              ! JDM JDM debug show the iCode instruction
  7347              %if (ShowIcode=1) %start
  7348                  ListICodeNoOp
  7349              %finish
  7350              ! JDM JDM end debug
  7351  
  7352              in params = 0
  7353  
  7354  			%true %if (amode < 0);            ! end of %record %format defn.
  7355  			%true %if (procvar_level = 128);  ! prim routine reference
  7356  
  7357  			! Here it's a real subroutine - copy any parameters to the PARM area
  7358  			%if (names > first name) %start
  7359                  procvar_pbase = parms;  ! Point one beyond the first parameter
  7360  				frame = (frame + align) & (\align);	! Even up the stack size
  7361  				%if (procvar_type = string) %and (procvar_form = 8) %start
  7362  					frame = frame + word size;  ! string functions have a hidden result parameter
  7363  				%finish
  7364  				procvar_extra = frame;             ! Remember the stack offset
  7365  				procvar_dim = names - first name;  ! and the number of parameters
  7366  				frame = frame + (2 * word size);   ! leave space for return linkage (IP + BP)
  7367  				%for j = first name+1, 1, names %cycle
  7368  					ap == var(j)
  7369  					parms = parms-1
  7370                      fp == var(parms)
  7371  					fp = ap
  7372  					! formal parameter base and displacement is implicit (on the stack)
  7373  					fp_level = 0
  7374  					! we also need to adjust the offsets of the actual parameters, because
  7375  					! they were allocated going "forwards", but will be pushed on the stack
  7376  					! "backwards" - that is, the first item passed will end up with the
  7377  					! highest address.  DefineVar has done part of the work for us by tagging
  7378  					! the displacements in the right style, but it can't tell the whole frame
  7379  					! offset, so we calculate the final offsets here...
  7380  					ap_disp = frame - ap_disp
  7381  				%repeat
  7382  				abort("Params") %if parms < names
  7383  			%finish
  7384  			%true %if (amode = 2);  ! this was just a spec
  7385  			dumplabel(procvar_disp)
  7386  			static alloc = enter
  7387  			frame = -(level * word size);  ! one word for each display entry
  7388  			%false
  7389  		%end
  7390  
  7391          %routine Start Params
  7392  
  7393              ! JDM JDM debug show the iCode instruction
  7394              %if (ShowIcode=1) %start
  7395                  ListICodeNoOp
  7396              %finish
  7397              ! JDM JDM end debug
  7398  
  7399              in params = -1
  7400  			! this is either
  7401              ! a record format,
  7402              ! a procedure,
  7403              ! or a proc spec;
  7404  			!   - block type was set by decvar to tell us which
  7405  			assemble(block type,labs,names);
  7406          %end
  7407  
  7408  		%predicate AlternateFormat( %integer N )
  7409  
  7410              ! JDM JDM debug show the iCode instruction
  7411              %if (ShowIcode=1) %start
  7412                  ListICode
  7413                  spaces(4)
  7414                  printsymbol( N )
  7415                  newline
  7416              %finish
  7417              ! JDM JDM end debug
  7418  
  7419  			! Check the ICODE for faults
  7420              ! and abort for any faulty intermediate code
  7421  			abort("Alt Record '".tostring(sym)."'.") %unless (N = 'A') %or (N = 'B') %or (N = 'C')
  7422  
  7423  			%true %if (N = 'B');             ! alt end
  7424  
  7425  			%if (N = 'A') %start
  7426                  ! alt start
  7427  				decvar == procvar
  7428  				assemble(-2,labs,names)
  7429  			%finish
  7430  
  7431  			%if (N = 'C') %start
  7432  				! Compile the next alternate - update limit and set frame back to where we started
  7433  				max frame = frame %if (frame > max frame)
  7434  				frame = old frame
  7435  			%finish
  7436  			%false
  7437  		%end
  7438  
  7439  ! ******************************************
  7440  ! JDM JDM attempt to include the plant icode and machine code icode
  7441          %routine  Plant
  7442              ! Plant in-line code values (from "*=constant")
  7443              %integer  j
  7444  
  7445              ! We only expect one item on the stack
  7446              abort("Machine Literal") %if (stp <> 1)
  7447  
  7448              %for j = 1, 1, stp %cycle
  7449  ! JDM JDM not sure what next 3 lines do, so commented out
  7450  !                lhs == stacked(j)
  7451  !                word (lhs_disp)
  7452  !                drop (lhs)
  7453  
  7454              %repeat
  7455              ! JDM empty the icode stack
  7456              stp = 0
  7457          %end
  7458  
  7459          %routine Load Plant
  7460  
  7461              ! JDM JDM debug show the iCode instruction
  7462              %if (ShowIcode=1) %start
  7463                  ListICodeNoOp
  7464              %finish
  7465              ! JDM JDM end debug
  7466  
  7467              Plant
  7468          %end
  7469  
  7470          ! JDM being lazy I created a dual purpose list to map
  7471          ! op (NOP:JMP) to a corresponding opX
  7472          ! op (NOP:JMP) to a text version of opX
  7473              
  7474          ! This list maps opId to internal opX
  7475          %constant %integer %array opGenericId(NOP:JMP) =
  7476+               -1,   -1,    -1,     -1,     -1,     -1,     -1,   NEGx,
  7477+         {    NOP,  CWD,   RET,   SAHF,  LEAVE,    DEC,    INC,    NEG, }
  7478+              NOTx,     POP,    PUSH,      -1,      -1,      -1,      -1,    ADDx,
  7479+         {    NOT,  POP,  PUSH,    LEA,    MOV,   XCHG,    ADC,    ADD, }
  7480+             ANDx,   -1,   ORx,   SUBx,   XORx,   LSHx,   RSHx,   DIVx,
  7481+         {    AND,  CMP,    OR,    SUB,    XOR,    SHL,    SHR,   IDIV, }
  7482+             MULx,   -1,    -1,     -1,     -1,     -1,     -1,     -1,
  7483+         {   IMUL, CALL,    JE,    JNE,     JG,    JGE,     JL,    JLE, }
  7484+               -1,   -1,    -1,     -1,     -1
  7485          {     JA,  JAE,    JB,    JBE,    JMP }
  7486  
  7487          ! This list maps opId to internal opX name
  7488          %constant %string(5) %array opGenericName(NOP:JMP) =
  7489+             "NOP",   "CWD",   "RET",  "SAHF", "LEAVE",   "DEC",   "INC",  "NEGx",
  7490+             "NOT",   "POP",  "PUSH",   "LEA",   "MOV",  "XCHG",   "ADC",   "ADD",
  7491+             "AND",   "CMP",    "OR",   "SUB",   "XOR",   "SHL",   "SHR",  "IDIV",
  7492+            "IMUL",  "CALL",    "JE",   "JNE",    "JG",   "JGE",    "JL",   "JLE",
  7493+              "JA",   "JAE",    "JB",   "JBE",   "JMP"
  7494  
  7495          !                                              >> MACHINE CODE <<
  7496          %routine Machine Code( %string(255) code )
  7497              ! This is meant to insert a machine code fragment into the code stream
  7498  
  7499              ! classify the type of the machine code instruction parameter
  7500              %constant %integer     unknown = 0, variable = 1, register = 2, number = 3, mask = 4,    name = 5,  pointer = 6
  7501              ! param type is one of unknown,     variable,     register,     number,     mask,        name,      pointer
  7502              ! param value is       ???,         tag,          reg id,       number,     32-bit mask, integer,   reg id,
  7503              ! param data  is       ???,         tag name,     reg name,     N/A,        N/A,         name,      reg name
  7504              ! param offset is      N/A,         N/A,          N/A,          N/A,        N/A,         N/A,       offset
  7505              !
  7506              ! ass-u-me that a machine code instruction has at most 8 parameters
  7507              %constant %integer param limit = 8;
  7508  
  7509              ! Remember number of CPU registers (1..register limit)
  7510              %constant %integer register limit = 8
  7511  
  7512              ! A machine code string has the form *op_ (item(',' item)*)?
  7513              ! where *,? have the usual regular grammar repetition semantics
  7514              ! op is an instruction name
  7515              !   - (a sequence of alphanumeric chars terminated by '_')
  7516              ! An item has one of the forms:
  7517              ! B such that 0 <= B <= 255
  7518              ! X such that 0 <= X <= 255 returning x = X - 128
  7519              ! 1) varname  == ' ' BB   (BB is a definition tag)
  7520              ! 2) constant == 'N' BBBB (BBBB is 32-bit signed integer)
  7521              ! 3) text     == X+       (X+ converted to an ASCII sequence of x)
  7522              ! The code string can also include ASCII chars
  7523              ! (excluding any varname,constant,text format)
  7524              ! 4) chars    == c*
  7525              ! (where c is one of '<','>','[',']','(',')','#',',')
  7526              !
  7527              ! An instruction can have 0.."param limit" parameters
  7528              ! where the parameters are separated by a ','
  7529              ! One parameter type is a register mask of form
  7530              !  mask == '<' number (',' number)* '>'
  7531              ! This is the ONLY other legal use of a ','
  7532              ! The following defines the legal opcode parameters
  7533              ! 1) register == constant
  7534              !                (a register index, beware register range)
  7535              ! 2) number   == # constant
  7536              !                (a 32-bit signed integer)
  7537              ! 3) mask     == '<' register (',' register)* '>'
  7538              !                (a bit set of registers)
  7539              !                beware limit on count of registers)
  7540              ! 4) modifier == text number
  7541              ! 5) variable == varname,
  7542              !                pointer
  7543              ! 6) pointer  == '[' register ']',
  7544              !                '[' register '+' offset ']',
  7545              !                '{ register '-' offset ']'
  7546              ! 7) offset   == constant
  7547              !                (a 32-bit signed integer)
  7548              !
  7549              ! N.B. a variable could be the value held in varname
  7550              !                 or the address of varname.
  7551              ! N.B. register always refers to its value,
  7552              ! N.B. pointer becomes an address
  7553              !
  7554              ! Legal Intel 386 instruction formats
  7555              ! The modifier, mask parameters are unused
  7556              ! No-op instruction
  7557              ! *op_
  7558              !
  7559              ! One-op instruction
  7560              ! *op_ register
  7561              ! *op_ number
  7562              ! *op_ variable
  7563              !
  7564              ! Two-op MOV instruction
  7565              ! N.B. *op_ A ',' B          == A := B 
  7566              ! *op_ register ',' register == register := register
  7567              ! *op_ register ',' number   == register := number
  7568              ! *op_ register ',' variable == register := variable
  7569              ! *op_ variable ',' register == variable := register
  7570              ! *op_ variable ',' number   == variable := number
  7571              !
  7572              ! Two-op instruction (non-MOV instruction)
  7573              ! *op_ register ',' register == register := register op register
  7574              ! *op_ register ',' number   == register := register op number
  7575              ! *op_ register ',' variable == register := register op variable
  7576              ! *op_ variable ',' register == variable := variable op register
  7577              ! *op_ variable ',' number   == variable := variable op number
  7578  
  7579              %recordformat paramFm(%string(255) data, param name,
  7580+                                   %integer scomma,
  7581+                                            pcomma,
  7582+                                            start,
  7583+                                            end,
  7584+                                            param type,
  7585+                                            param value,
  7586+                                            param offset)
  7587              %string(5) instruction
  7588              %integer params count
  7589              %record(paramFm)%array params(1:param limit)
  7590  
  7591              %routine dump parameter( %integer index )
  7592                  %string(255) t
  7593                  %integer tag,n
  7594                  %string(255) param name
  7595                  %integer param value
  7596                  %integer param offset 
  7597                  %switch sw(0:6)
  7598  
  7599                  param name = params( index )_param name
  7600                  param value = params( index )_param value
  7601                  param offset = params( index )_param offset
  7602  
  7603                  printstring( "Parameter(".itos(index,0).")='".param name."'")
  7604                  newline
  7605  
  7606                  ->sw(params(index)_param type)
  7607                  sw(variable):
  7608                      ! dump the variable data
  7609                      dump tag var( param value, "VAR" )
  7610                      -> esac
  7611                  sw(register):
  7612                      ! dump the register data
  7613                      printstring(" REG   id=".itos(param value,0))
  7614                      newline
  7615                      printstring(" REG name=".param name)
  7616                      newlines(2)
  7617                      -> esac
  7618                  sw(number):
  7619                      ! dump the number data
  7620                      printstring(" NUMBER value=".itos(param value,0))
  7621                      newlines(2)
  7622                      -> esac
  7623                  sw(mask):
  7624                      ! dump the mask data
  7625                      printstring(" MASK value=2_".int2ascii(param value,2,0))
  7626                      newlines(2)
  7627                  sw(name):
  7628                      ! dump the name data
  7629                      printstring(" NAME  name=".param name); newline
  7630                      printstring(" NAME value=2_".int2ascii(param value,2,0))
  7631                      newlines(2)
  7632                      -> esac
  7633                  sw(pointer):
  7634                      ! dump the pointer data
  7635                      printstring(" PTR   id=".itos(param value,0))
  7636                      newline
  7637                      printstring(" PTR name=[".param name)
  7638                      %if (param offset # 0) %start
  7639                          printstring(itos(param offset,0))
  7640                      %finish
  7641                      printstring("]")
  7642                      newline
  7643                      printstring(" PTR offset=".itos(param offset,0))
  7644                      newlines(2)
  7645                      -> esac
  7646                  sw(*):
  7647                      -> esac
  7648                  esac:
  7649              %end
?N unused
?TAG unused
?T unused
  7650  
  7651              %routine parseMachineCode( %string(255) code )
  7652                  %string(255) s,t
  7653                  %string(255) parameters
  7654                  %byte ch
  7655                  %byte inrbflag,insbflag,inabflag,hashflag,plusFlag,minusFlag
  7656                  %switch c(0:127)
  7657                  %label esac, default
  7658                  %integer i,j,k,n,plen,tag
  7659  
  7660                  code -> instruction.("_").parameters
  7661  
  7662                  s = ""
  7663  
  7664                  %if (parameters # "") %start
  7665                      ! parameters is a non-empty string so we ass-u-me at least one parameter
  7666                      params count = 1
  7667                      plen = length(parameters)
  7668                      inrbFlag  = 0; ! not inside round bracket sequence
  7669                      insbFlag  = 0; ! not inside square bracket sequence
  7670                      inabFlag  = 0; ! not inside angle bracket sequence
  7671                      hashFlag  = 0; ! not expecting a number to follow
  7672                      plusFlag  = 0; ! set to indicate a + constant offset (inside [...] sequence)
  7673                      minusFlag = 0; ! set to indicate a - constant offset (inside [...] sequence)
  7674  
  7675                      i = 1;
  7676                      %while (i <= plen) %cycle
  7677  
  7678                          ch = charno( parameters, i)
  7679                          -> c(ch) %if (ch < 128); ! this is an ordinary ASCII char
  7680  
  7681                          ! So, ch > 127, thus this "char" starts a tweaked "name"
  7682                          t = "%"
  7683                          %while (charno(parameters, i) > 127) %cycle
  7684                              ! Append the converted char
  7685                              length(t) = length(t) + 1
  7686                              ! tweak appended "char" to be a legal 7-bit ASCII char
  7687                              charno( t, length(t)) = charno(parameters, i) - 128
  7688                              i = i + 1
  7689                          %repeat
  7690  
  7691                          params( params count )_param type  = name
  7692                          params( params count )_param value = 0; ! value acquired by next N section
  7693  
  7694                          params( params count )_param name  = t
  7695                          s = s.t." "
  7696  
  7697                          -> esac
  7698  
  7699                   c(' '):
  7700                          ! a variable/pointer reference is prefixed by a space.
  7701                          n = (charno( parameters, i+1 ) << 8) + charno( parameters, i+2 )
  7702  
  7703                          ! now determine the variable name
  7704                          t = var( n )_idname
  7705  
  7706                          ! remember this parameter is a variable/pointer (and its tag)
  7707                          %if (insbflag = 1) %start
  7708                              params( params count )_param type = pointer
  7709                          %finish %else %start
  7710                              params( params count )_param type = variable
  7711                          %finish
  7712                          params( params count )_param value = n
  7713                          params( params count )_param name = t
  7714                          s = s.t
  7715  
  7716                          i = i + 3
  7717                          -> esac
  7718                   c('N'):
  7719                          ! A number is prefixed by an ASCII 'N'
  7720                          n = 0
  7721                          n = n + charno( parameters, i+1 ); n = n << 8
  7722                          n = n + charno( parameters, i+2 ); n = n << 8
  7723                          n = n + charno( parameters, i+3 ); n = n << 8
  7724                          n = n + charno( parameters, i+4 )
  7725  
  7726                          %if (params( params count )_param type  = name) %start
  7727                              ! this number is associated with a "name" (i.e. %shl 4)
  7728                              hashFlag = 0
  7729  
  7730                              ! we have the "name" (i.e %shl)
  7731                              ! but now to get the associated numeric value
  7732                              params( params count )_param value = n
  7733  
  7734                              ! convert number to text
  7735                              %if (n > 127) %start
  7736                                  t = "16_".int2ascii( n, 16, 0 )
  7737                              %finish %else %start
  7738                                  t = itos( n, 0 )
  7739                              %finish
  7740  
  7741                              ! now to add the associated number to the s string
  7742                              s = s.t
  7743  
  7744                          %finish %else %if (hash flag <> 0) %and (params( params count )_param type = unknown) %start
  7745                              ! hashflag indicates this is a genuine integer
  7746                              hashFlag = 0
  7747  
  7748                              ! remember this parameter is a number
  7749                              params( params count )_param type  = number
  7750                              params( params count )_param value = n
  7751                              params( params count )_param name  = ""
  7752  
  7753                              %if (n > 127) %start
  7754                                  t = "16_".int2ascii( n, 16, 0 )
  7755                              %finish %else %start
  7756                                  t = itos( n, 0 )
  7757                              %finish
  7758                              
  7759                              s = s.t
  7760                              params( params count )_param name  = t
  7761  
  7762                          %finish %else %if (params( params count )_param type  = mask) %start
  7763  
  7764                              ! Ah, we are between <> == mask
  7765                              ! So we need to update the mask
  7766                              %if (0 < n <= register limit) %start
  7767                                  ! ok, legal register mask range
  7768                                  k = 1<<(n - 1)
  7769                              %finish %else %if (0 < n <= 32) %start
  7770                                  ! oops, bad mask specifier for this CPU
  7771                                  k = 1<<(n - 1)
  7772                              %finish %else %start
  7773                                  ! oops, even worse! Is this a CPU with > 32 registers.
  7774                                  ! we can't fit this mask into a 32-bit integer
  7775                                  ! so, we won't try
  7776                                  k = 0
  7777                              %finish
  7778  
  7779                              ! add the register flag to the mask
  7780                              params( params count )_param value = params( params count )_param value!k
  7781  
  7782                              ! remember N represents the register number but add the reg name
  7783                              ! Ensure we are referencing a valid register
  7784                              ! Adjust register limit for a specific CPU
  7785                              %if (0 < n <= register limit) %start
  7786                                  s = s.regname(n)
  7787                              %finish %else %start
  7788                                  s = s."R??"
  7789                              %finish
  7790                              
  7791                          %finish %else %start
  7792                              ! ok this came from a constant integer in the IMP program
  7793                              ! ASS-U-ME that this constant represents a register
  7794                              ! So, replace the number with the register name
  7795                              ! Register name is specific to a processor architecture
  7796                              ! IMP code with embedded assembler should reference a
  7797                              ! register by number.
  7798                              ! The IMP pass2 for that processor should store a mapping
  7799                              ! between "register" number and register name.
  7800                              ! eg Intel eax or ebp
  7801  
  7802                              ! remember this parameter is a variable/pointer (and its tag)
  7803                              %if (insbflag = 1) %start
  7804                                  params( params count )_param type = pointer
  7805                              %finish %else %start
  7806                                  params( params count )_param type  = register
  7807                              %finish
  7808  
  7809                              %if (plusFlag = 1) %start
  7810                                  ! remember this "parameter" is a positives pointer offset
  7811                                  params( params count )_param offset = n
  7812                                  t = itos( n, 0)
  7813                              %finish %else %if (minusFlag = 1) %start
  7814                                  ! remember this "parameter" is a negative pointer offset
  7815                                  params( params count )_param offset = -n
  7816                                  ! however, negative sign (and or #) already output
  7817                                  t = itos( n, 0)
  7818                              %finish %else %start
  7819                                  ! remember this parameter is a register
  7820                                  params( params count )_param value = n
  7821  
  7822                                  ! Ensure we are referencing a valid register
  7823                                  ! Adjust register limit for a specific CPU
  7824                                  %if (0 < n <= register limit) %start
  7825                                      t = regname(n)
  7826                                  %finish %else %start
  7827                                      t = "R??"
  7828                                  %finish
  7829  
  7830                                  params( params count )_param name  = t
  7831                              %finish
  7832  
  7833                              s = s.t
  7834                          %finish
  7835                          i = i + 5
  7836                          -> esac
  7837  
  7838                   c('#'):
  7839                          ! let this char through
  7840                          ! BUT remember # is assumed to prefix a positive number
  7841                          hashFlag = 1
  7842                          -> default
  7843  
  7844                   c(','):
  7845                          ! let this char through
  7846                          ! comma separates instruction parameters
  7847                          ! (or values between brackets)
  7848  
  7849                          { ok, check to see if this is a parameter separator }
  7850                          %if ((inabFlag + inrbFlag + insbFlag) = 0) %start
  7851                             { ok, we are not inside one of the "bracket" types }
  7852                             ! REMEMBER, the parameter type and value should have been
  7853                             ! determined previously
  7854                             ! note comma location in the s string
  7855                             params(params count)_scomma = length(s) + 1
  7856  
  7857                             ! note comma location in the parameters string
  7858                             params(params count)_pcomma = i
  7859                             ! beware fence post error
  7860                             ! we are counting fence posts (,)
  7861                             ! and their locations
  7862                             ! So "last" fence post at end of parameters string
  7863  
  7864                             ! we have an additional parameter
  7865                             params count = params count + 1
  7866                             ! BUT set the param type appropriately
  7867                             params( params count )_param type = unknown
  7868                             params( params count )_param offset = 0
  7869  
  7870                          %finish
  7871                          -> default
  7872  
  7873                   c('+'):
  7874                          ! pass this char( only allowed between [] brackets
  7875                          plusFlag = 1
  7876                          minusFlag = 0
  7877                          -> default
  7878                      
  7879                   c('-'):
  7880                          ! pass this char( only allowed between [] brackets
  7881                          plusFlag = 0
  7882                          minusFlag = 1
  7883                          -> default
  7884                      
  7885                   c('('):
  7886                          ! pass this char (opening round brackets)
  7887                          inrbFlag = 1
  7888                          -> default
  7889  
  7890                   c(')'):
  7891                          ! pass this char (closing round brackets)
  7892                          inrbFlag = 0
  7893                          -> default
  7894  
  7895                   c('['):
  7896                          ! we are referencing an indirect variable
  7897                          params( params count )_param type = pointer
  7898                          ! initialise the name,value and offset
  7899                          params( params count )_param name  = ""
  7900                          params( params count )_param value = 0
  7901                          params( params count )_param offset = 0
  7902  
  7903                          ! pass this char (opening square brackets)
  7904                          insbFlag = 1
  7905                          -> default
  7906  
  7907                   c(']'):
  7908                          ! pass this char (closing square brackets)
  7909                          plusFlag = 0
  7910                          minusFlag = 0
  7911                          insbFlag = 0
  7912                          -> default
  7913  
  7914                   c('<'):
  7915                          ! We are starting a mask parameter
  7916                          params( params count )_param type  = mask
  7917                          ! initialise the value and name
  7918                          params( params count )_param name  = ""
  7919                          params( params count )_param value = 0
  7920                          params( params count )_param offset = 0
  7921                          ! pass this char (opening angle brackets)
  7922                          inabFlag = 1
  7923                          -> default
  7924  
  7925                   c('>'):
  7926                          ! pass this char (closing angle brackets)
  7927                          inabFlag = 0
  7928                          -> default
  7929  
  7930                  default:
  7931                   c(*):
  7932                          ! pass these chars
  7933                          ! chars > 127 are already dealt with
  7934                          ! So, this deals with remaining chars
  7935                          s = s.tostring( charno( parameters, i) )
  7936                          i = i + 1
  7937                          -> esac
  7938                      esac:
  7939  
  7940                      %repeat
  7941  
  7942                  %finish %else %start
  7943                      ! Oh, this instruction has no parameters
  7944                      params count = 0
  7945                  %finish
  7946  
  7947                  %if (params count # 0) %start
  7948                      ! now to identify each instruction parameter inside the s string
  7949                      %for i = 1,1,params count %cycle
  7950  
  7951                          %if (i = 1) %then params(i)_start = 1 %else params(i)_start = params(i-1)_scomma + 1
  7952                          %if (i = params count) %then params(i)_end = length(s) %else params(i)_end = params(i)_scomma - 1
  7953                          params(i)_data = ""
  7954                          %for j = params(i)_start,1,params(i)_end %cycle
  7955                              params(i)_data = params(i)_data.toString( charno(s,j) )
  7956                          %repeat
  7957  
  7958                      %repeat
  7959                  %finish
  7960  
  7961                  ! JDM JDM debug show the iCode instruction
  7962                  %if (ShowIcode=1) %start
  7963                      ListICode
  7964                      spaces(4)
  7965                      printstring( instruction )
  7966  
  7967                      %if (params count # 0) %start
  7968                          printsymbol( ' ' )
  7969                          ! now to identify each instruction parameter inside the s string
  7970                          %for i = 1,1,params count %cycle
  7971                              %if (i > 1) %start
  7972                                  printsymbol( ',' )
  7973                              %finish
  7974                              printstring( params(i)_data )
  7975                          %repeat
  7976                      %finish
  7977                      newline
  7978                  %finish
  7979                  ! JDM JDM end debug
  7980  
  7981              %end
?TAG unused
  7982  
  7983              %integer %fn validateMachineCode( %string(5) instruction )
  7984                  %string(5) opNameX
  7985                  %integer i
  7986                  %integer opId,opIdx
  7987  
  7988                  ! determine the opId for this instruction
  7989                  ! set a default "ILLEGAL" value for the opId
  7990                  ! Although Intel 386 has opCodes 0..255
  7991                  ! the count of opCode names is much less than 255
  7992                  ! so, we are safe to set opId and opIdx = 255
  7993                  opId = -1
  7994                  opIdx = -1
  7995                  %for i = NOP,1,JMP %cycle
  7996                      %if (instruction = opGenericName(i)) %start
  7997                          opId = i
  7998                          opIdx = opGenericId(opId)
  7999                          %if (opIdx # -1) %start
  8000                              opNameX = instruction
  8001                          %finish %else %start
  8002                              opNameX = itos(opId,0)
  8003                          %finish
  8004                      %finish
  8005                  %repeat
  8006  
  8007                  ! We are NOT allowing any floating point instructions
  8008  !                %for i = FILD,1,FLDPI %cycle
  8009  !                   %if instruction = flopname(i) %then opId = i
  8010  !                %repeat
  8011  !                %if (opId < FILD) %then instruction = opName(opId) %else instruction = flopName(opId)
  8012             
  8013                  ! use short form of %if statement (as an example)
  8014                  abort("MCODE has illegal/unknown instruction name") %if (opId = -1)
  8015  
  8016                  %result = opId
  8017              %end
  8018  
  8019              %routine insertMachineCode( %string(5) instruction, %integer opId )
  8020                  %integer opIdx
  8021                  
  8022                  opIdx = opGenericId(opId)
  8023  
  8024                  %if (params count = 0) %start
  8025                      selectoutput(listout)
  8026                      printstring( "**** Instructions with no parameters not yet implemented" ); newline
  8027                  %finish %else %if (params count = 1) %start
  8028                      %if (opId # -1) %start
  8029                          %if (params(1)_param type = variable) %start
  8030                              Stack Var( params(1)_param value )
  8031                              Operation(opIdx)
  8032                          %finish %else %if (params(1)_param type = register) %start
  8033                              dumpur(opId, params(1)_param value)
  8034                          %finish %else %if (params(1)_param type = pointer) %start
  8035                              abort( "Opcode ".instruction." with one parameter can only operate on an address/register ".params(1)_param name )
  8036                          %finish %else %start
  8037                              abort( "Opcode ".instruction." is attempting to operate on unexpected location ".params(1)_param name )
  8038                          %finish
  8039                      %finish %else %start
  8040                          abort( "Attempting to apply unknown opcode ".instruction )
  8041                      %finish
  8042                  %finish %else %if (params count = 2) %start
  8043                      ! 3) output the implied code fragment
  8044                      %if (opId = MOV) %start
  8045                          %if (params(1)_param type = variable) %start
  8046                              %if (params(2)_param type = register) %start
  8047                                  Stack Var( params(1)_param value )
  8048                                  %if (top_type = general) %or (top_type = integer) %or (top_type = byte) %or (top_type = record) %start
  8049                                      storeReg( top, params(2)_param value )
  8050                                      pop rel
  8051                                  %finish %else %start
  8052                                      pop rel
  8053                                      abort( "Attempting to store reg ".params(2)_param name." in a non-integer variable" )
  8054                                  %finish
  8055                              %finish %else %if (params(2)_param type = number) %start
  8056                                  Stack Var( params(1)_param value )
  8057                                  Push Const( params(2)_param value )
  8058                                  Assign(1)
  8059                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8060                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8061                              %finish %else %start
  8062                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8063                              %finish
  8064                          %finish %else %if (params(1)_param type = pointer) %start
  8065                              %if (params(2)_param type = register) %start
  8066                                  dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8067                              %finish %else %if (params(2)_param type = number) %start
  8068                                  selectoutput(listout)
  8069                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8070                                  dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8071                                  printstring(" NOT YET IMPLEMENTED"); newline
  8072                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8073                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8074                              %finish %else %start
  8075                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8076                              %finish
  8077                          %finish %else %if (params(1)_param type = register) %start
  8078                              %if (params(2)_param type = variable) %start
  8079                                  Stack Var( params(2)_param value )
  8080                                  LoadReg( top, params(1)_param value )
  8081                                  pop rel
  8082                              %finish %else %if (params(2)_param type = pointer) %start
  8083                                  dumprm(opId, params(1)_param value, params(2)_param value, params(2)_param offset, 0)
  8084                              %finish %else %if (params(2)_param type = register) %start
  8085                                  dumprr(opId, params(1)_param value, params(2)_param value )
  8086                              %finish %else %if (params(2)_param type = number) %start
  8087                                  Push Const( params(2)_param value )
  8088                                  LoadReg( top, params(1)_param value )
  8089                                  pop rel
  8090                              %finish %else %start
  8091                                  abort( "Attempting to store unexpected type in register ".params(1)_param name )
  8092                              %finish
  8093                          %finish %else %start
  8094                              abort( "Attempting to ".instruction." into non-variable/register location" )
  8095                          %finish
  8096                      %finish %else %if (opIdx # -1) %start
  8097                          %if (params(1)_param type = variable) %start
  8098                              %if (params(2)_param type = register) %start
  8099                                  Stack Var( params(1)_param value )
  8100                                  dumpmr(opId, top_base!top_scope, top_disp, top_extdisp, top_base)
  8101                                  pop rel
  8102                              %finish %else %if (params(2)_param type = number) %start
  8103                                  Stack Var( params(1)_param value )
  8104                                  Stack Var( params(1)_param value )
  8105                                  Push Const( params(2)_param value )
  8106                                  Operation(opIdx)
  8107                                  Assign(1)
  8108                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8109                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8110                              %finish %else %start
  8111                                  abort( "Opcode ".instruction." is attempting to store unexpected type in variable ".params(1)_param name )
  8112                              %finish
  8113                          %finish %else %if (params(1)_param type = pointer) %start
  8114                              %if (params(2)_param type = register) %start
  8115                                  dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8116                              %finish %else %if (params(2)_param type = number) %start
  8117                                  selectoutput(listout)
  8118                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8119                                  dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8120                                  printstring(" NOT YET IMPLEMENTED"); newline
  8121                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8122                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8123                              %finish %else %start
  8124                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8125                              %finish
  8126                          %finish %else %if (params(1)_param type = register) %start
  8127                              %if (params(2)_param type = variable) %start
  8128                                  Stack Var( params(2)_param value )
  8129                                  dumprv( opId, params(1)_param value, top)
  8130                                  pop rel;
  8131                              %finish %else %if (params(2)_param type = pointer) %start
  8132                                  selectoutput(listout)
  8133                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8134                                  dumprm(opId, params(1)_param value, params(2)_param value, params(1)_param offset, 0 )
  8135                                  printstring(" NOT YET IMPLEMENTED"); newline
  8136                              %finish %else %if (params(2)_param type = register) %start
  8137                                  dumprr(opId, params(1)_param value, params(2)_param value )
  8138                              %finish %else %if (params(2)_param type = number) %start
  8139                                  dumpri(opId, params(1)_param value, params(2)_param value )
  8140                              %finish %else %start
  8141                                  abort( "Opcode ".instruction." is attempting to store unexpected type in register ".params(1)_param name )
  8142                              %finish
  8143                          %finish %else %start
  8144                              abort( "Opcode ".instruction." is attempting to store in unexpected location ".params(1)_param name )
  8145                          %finish
  8146                      %finish %else %start
  8147                          abort( "Attempting to apply unknown opcode ".instruction )
  8148                      %finish
  8149                  %finish %else %start
  8150                      abort("Opcode ".instruction." has unexpected number ".itos(params count,0)."of parameters.")
  8151                  %finish
  8152              %end
  8153  
  8154              %integer opId
  8155  
  8156              ! ok, lets go
  8157              ! First, parse the machine code text
  8158              parseMachineCode( code )
  8159  
  8160              ! Next, check that we have a valid instruction
  8161              opId = validateMachineCode( instruction )
  8162  
  8163              ! Finally add the instruction to the output
  8164              insertMachineCode( instruction, opId )
  8165          %end
?DUMPPARAMETER unused
  8166  ! ******************************************
  8167  
  8168          !--------------------------------------------------------------
  8169          ! Code for ASSEMBLE starts here...
  8170          First Name = Names
  8171          First Label = Labs
  8172          Proc Var == Decvar
  8173          last skip = -1
  8174          old frame = frame
  8175          frame = 0
  8176          events = 0
  8177          evep = 0
  8178          evfrom = 0
  8179  
  8180          %if (amode >= 0) %start;                         ! NOT A RECORDFORMAT
  8181              level = level+1
  8182              abort("Level") %if (level > max level) %and (spec = 0)
  8183              worklist(level) = 0
  8184  
  8185              %if (amode = 0) %start;            ! %begin block
  8186                  %if (level = 1) %start;        ! Initial %begin ?
  8187                      block name = program ip;   ! For stack traceback readability
  8188                      external id = program ep;  ! linkage to program entry
  8189                      otype = external
  8190                      potype = otype
  8191                  %else
  8192                      block name = "%begin block"
  8193                  %finish
  8194                  static alloc = enter
  8195                  frame = -(level * word size);          ! 1 word for every display entry
  8196              %finish
  8197          %else
  8198              %if (amode = -1) %start;                   ! normal record format
  8199                  ProcVar_pbase = parms;                 ! where our members start
  8200              %else
  8201                  %if (amode = -2) %then frame = oldframe; ! alternates start at the current offset
  8202              %finish
  8203              max frame = frame;                         ! start counting space here
  8204          %finish
  8205  
  8206  		!  --- main compilation loop ---
  8207  		%cycle
  8208  			sym = Pending
  8209              read symbol(Pending)
  8210  
  8211              ! count how many iCode instructions have been read
  8212              iCodeCount = iCodeCount + 1
  8213  
  8214              ! defend against illegal iCode instructions
  8215              %if (getiCodeName(sym)="ILLEGAL") %start
  8216  				selectoutput(0)
  8217  				printsymbol('(')
  8218                  write(sym, 0)
  8219                  printsymbol(',')
  8220                  write(Pending, 0)
  8221                  printsymbol(')')
  8222  				abort("Bad I Code")
  8223  			%finish
  8224              ! From this point the iCode is a legal iCode
  8225              ! So we remember the current iCode instruction
  8226              ! Hopefully the iCode instruction parameters are valid
  8227              iCodeInst = sym
  8228  
  8229  			-> c(iCodeInst)
  8230  
  8231  c('!'):     Load Operation( ORx ); 				%continue
  8232  c('"'):	    Load Compare Double;				%continue
  8233  c('#'):		Jump Forward( ReadTag, NE );		%continue
  8234  c('$'):		Define Var( ReadTag, Get Ascii( ',' ), ReadTagComma, ReadTagComma, ReadTag );	%continue
  8235  c('%'):		Load Operation( XORx );				%continue
  8236  c('&'):		Load Operation( ANDx );				%continue
  8237  c(''''):	Input String Value( ReadString );	%continue;	! Stack string constant
  8238  c('('):		Jump Forward( ReadTag, LE );		%continue
  8239  c(')'):		Jump Forward( ReadTag, GE );		%continue
  8240  c('*'):		Load Operation( MULx );				%continue
  8241  c('+'):		Load Operation( ADDx );				%continue
  8242  c('-'):		Load Operation( SUBx );				%continue
  8243  c('.'):		Load Operation( CONCx );			%continue
  8244  c('/'):		Load Operation( DIVx );				%continue
  8245  c(':'):		Define Compiler Label( ReadTag );	%continue;	! Define compiler label
  8246  c(';'):		Load End of Block;					%exit
  8247  c('<'):		Jump Forward( ReadTag, LT );		%continue
  8248  c('='):		Jump Forward( ReadTag, EQ );		%continue
  8249  c('>'):		Jump Forward( ReadTag, GT );		%continue
  8250  c('?'):		Load Compare Values;				%continue;	! Compare values
  8251  c('@'):		Load Var( ReadTag );				%continue;	! Load variable descriptor (calls Stack Var)
  8252  c('A'):     Init( ReadTag );					%continue;	! Initialise OWN variable
  8253  c('B'):     Jump Backward( ReadTag );			%continue;	! Backward Jump
  8254  c('C'):     Load Compare Addresses;				%continue;	! Compare addresses
  8255  c('D'):		Input Real Value( ReadReal );		%continue;	! Stack real constant
  8256  c('E'):		Load Compile Call( top );			%continue
  8257  c('F'):     Jump Forward( ReadTag, Always );	%continue;	! Forward Jump
  8258  c('G'):		Get Alias Value( ReadString );		%continue;	! Alias for item about to be declared
  8259  c('H'):		Load Compile Begin;					%continue;	! Start of BEGIN block
  8260  c('I'):		Abort("Pascal?");					!%continue;	! {ESCAPE for Pascal etc.}
  8261  c('J'):		User Jump( ReadTag );				%continue;	! Jump to user label
  8262  c('K'):		Load Return( False );				%continue;	! %false
  8263  c('L'):		Define User Label( ReadTag );		%continue;	! Define user label
  8264  c('M'):		Load Return( Map );					%continue;	! MAP result
  8265  c('N'):		Load Const( ReadInteger );			%continue;	! Load integer constant (calls Push Const)
  8266  c('O'):		Update Line( ReadTag );				%continue;	! Set line number
  8267  c('P'):		Load Plant;			                %continue;	! Machine code literal
  8268  c('Q'):		Load Operation( RDIVx );			%continue
  8269  c('R'):		Load Return( Routine );				%continue;	! RETURN
  8270  c('S'):		Load Assign( 1 );					%continue;	! Normal value assignment
  8271  c('T'):		Load Return( True );				%continue;	! %true
  8272  c('U'):		Load Operation(NEGx);				%continue
  8273  c('V'):		Load Return ( Fn );					%continue;	! FN result
  8274  c('W'):		Switch Jump( ReadTag );				%continue;	! Jump to switch
  8275  c('X'):		Load Operation( EXPx );				%continue
  8276  !'Y' - UNUSED
  8277  c('Z'):		Load Assign( 0 );					%continue;	! Assign address '=='
  8278  c('['):		Load Operation( LSHx );				%continue
  8279  c('\'):		Load Operation( NOTx );				%continue
  8280  c(']'):		Load Operation( RSHx );				%continue
  8281  c('^'):		Set Record Format( ReadTag );		%continue;	!   {Set Format}
  8282  c('_'):		Switch Label( ReadTag );			%continue;	! Define switch label
  8283  c('a'):		Load Array Ref( 0 );				%continue
  8284  c('b'):		Load Constant Bounds;				%continue;	! Define constant bounded Dope Vector
  8285  !'c' NOT IMPLEMENTED
  8286  c('d'):		Dimension( ReadTagComma, ReadTag );	%continue;	! dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  8287  c('e'):		Signal Event( ReadTag);				%continue;	! %signal event
  8288  c('f'):     Compile For( ReadTag );				%continue
  8289  c('g'):		Dimension( ReadTagComma, ReadTag );	%continue;	! (different to PSR) dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  8290  c('h'):
  8291  			! compiler op(n)
  8292  !			compiler op(ReadTag)
  8293  			                                    %continue
  8294  c('i'):		Load Array Ref( 1 );				%continue
  8295  c('j'):		Load Assign( 2 );					%continue;	! JAM transfer
  8296  c('k'):		Jump Forward( ReadTag, FF );		%continue;	! Branch on FALSE (= 0)
  8297  c('l'):		Load Language Flags( ReadTag );		%continue;	! We currently only support standard IMP - who knows the future
  8298  c('m'):		Load Monitor;						%continue;	! %monitor
  8299  c('n'):		SelectField( ReadTag );				%continue;	! Select member from record format
  8300  c('o'):		EventTrap( ReadTagComma, ReadTag );	%continue;	! %on %event block
  8301  c('p'):		Load Assign( -1 );					%continue;	! Pass a parameter
  8302  c('q'):		DoubleOp( SUBx);					%continue;	!--
  8303  c('r'):		Resolve( ReadTag );					%continue
  8304  c('s'):		Load Perm(stop, 0);					%continue;	! %stop
  8305  c('t'):		Jump Forward( ReadTag, TT );		%continue;	! Branch on TRUE (# 0)
  8306  c('u'):		DoubleOp( ADDx );					%continue;	!++
  8307  c('v'):		Load Operation( ABSx );				%continue
  8308  c('w'):		Machine Code( Get Ascii( ';' ) );   %continue;	! JDM: allowed call to Machine code
  8309  c('x'):		Load Operation(REXPx);				%continue
  8310  c('y'):		Set CD( ReadTag, diagnose);			%continue;	! %diagnose n (what about pass3? how do we send to pass3)
  8311  c('z'):		Set CD( ReadTag, control );			%continue;	! %control n
  8312  c('{'):     StartParams;                        %continue;! Start of formal parameters
  8313  c('}'):     %exit %if Finish Params;            %continue;	! End of formal parameters
  8314  c('~'):		%exit %if AlternateFormat( ReadByte )
  8315                                                  %continue;	! alternate record format
  8316  c(*):		abort("Bad I Code");				!%continue;	! To catch the sinners!! (that is - an unimplemented iCode)
  8317  		%repeat
  8318   
  8319          %if (amode >= 0) %start;         ! end of declarative block
  8320              %while (worklist(level) # 0) %cycle
  8321                  worklist(level) = ret gp tag(worklist(level))
  8322              %repeat
  8323              level = level-1
  8324          %else;                        ! end of record format defn
  8325              %if (amode = -2) %start;    ! end of alternative only
  8326                  frame = max frame %if (max frame > frame);  ! use the longest alternative
  8327                  old frame = frame
  8328              %else
  8329                  frame = (frame+align)&(\align);  ! **** temporary ****
  8330                  procvar_size = frame
  8331              %finish
  8332          %finish
  8333          frame = old frame
  8334  
  8335      %end;  !  assemble
  8336  
  8337      !              -------- it all starts here ---------
  8338      ! JDM - Before we do any file I/O we need to get the source file name
  8339      ! (as used to feed the 'source' stream)
  8340      %string(255) the source file name 
  8341      select input( source )
  8342      the source file name = input name
  8343  
  8344      %if (length( getenv( getenvindex( "IMP_ICODE" ) ) ) # 0) %start
  8345          ! ok, we want to show the iCode records
  8346          ShowICode = 1
  8347      %finish
  8348  
  8349      ! JDM - ok, now we can really start
  8350      select input( icode )
  8351      select output( objout ) 
  8352  
  8353      var(0) = 0;              !  for %RECORD(*) . . . . .
  8354      parms = max vars
  8355  
  8356      ! Initialise the GP Tag ASL
  8357      %for i=1,1,Max GP %cycle
  8358          GP Tags(i)_link = i - 1
  8359      %repeat
  8360      gp asl = Max GP
  8361  
  8362      ! Tell the linker our source file name
  8363      dumpsourcename( the source file name );   ! JDM - hopefully not so bogus now!
  8364  
  8365      ! predefine the perms for the linker.  We ignore
  8366      ! the number (j) because we know they are in sequence
  8367      %for i=1,1,lastperm %cycle
  8368          j = externalref(permname(i))
  8369      %repeat
  8370  
  8371      read symbol(Pending);  !  Prime SYM/NEXT pair
  8372      Spec = 0
  8373      decvar == begin
  8374      assemble(-3,0,0)
  8375  
  8376      ! We flush constants
  8377      flush cot
  8378      flush data
  8379      flush switch
  8380  
  8381  %endofprogram
?DUMPRR8 unused
?IFCALL unused
?DUMPSTACKENTRY unused
?GETTYPEOFSTRING unused
?FPRESULTLOC unused
?NEGATED unused
?DISPLAY unused
?BSS unused
?FDIVR unused
?FSUBR unused
?XCHG unused
?PERMRT unused
?OWN unused
?XNAMEARRAY unused
?XARRAYNAME unused
?XARRAY unused
?DH unused
?CH unused
?AH unused
?BL unused
?DL unused
?CHECKUNASS unused

  5669 Statements compiled
