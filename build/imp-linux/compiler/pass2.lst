         Edinburgh IMP77 Compiler - Version 8.4

   1  !   Intel 80386 IMP77 compiler second pass
   2  
   3  ! Copyright 2002 NB Information Limited.  From an original
   4  ! version probably Copyright The University of Edinburgh and
   5  ! various contributions Copyright many other individuals, but
   6  ! most particularly Copyright 1977-1980 Peter Robertson
   7  
   8  ! Version 2.00 - February 2021
   9  !   * Enabled machine code to be embedded (NO floating point implemented)
   10  !
   11  ! Version 1.03 - October 2003
   12  !	* Properly cleaned up GP TAG list at end of a block
   13  !	* Tidied up some constant tables with names (a hangover from the SKIMP version)
   14  !	* Corrected ISWORK to only be true for full-size string work blocks
   15  
   16  %begin
   17  
   18      !SIZE CONSTANTS
   19      %constinteger  max vars  = 1024
   20      %constinteger  max stack = 16
   21      %constinteger  max labs  = 50
   22      %constinteger  max level = 16
   23      %constinteger  Max GP    = 120
   24  
   25      ! SOME WEE ENVIRONMENTAL THINGS
   26      %conststring(12) program ip = "Main Program"; ! Main program internal name
   27      %conststring(8)  program ep = "__impmain";    ! Main program external name
   28      %conststring(5)  system prefix = "_imp_";     ! prefixed to %system routine idents
   29  
   30      ! I/O file handles
   31      %constinteger icode   = 1
   32      %constinteger source  = 2
   33      %constinteger report  = 0
   34      %constinteger objout  = 1
   35      %constinteger listout = 2
   36  
   37      !DIAGNOSE BITS
   38      %constinteger  passId = 2;                 ! JDM Identify which IMP pass this is
   39      %constinteger  mcode level D = (1<<13);    ! JDM peak level D debug diagnostics of Machine Code
   40      %constinteger  mcode level C = (1<<12);    ! JDM next level C debug diagnostics of Machine Code
   41      %constinteger  mcode level B = (1<<11);    ! JDM next level B debug diagnostics of Machine Code
   42      %constinteger  mcode level A = (1<<10);    ! JDM base level A debug diagnostics of Machine Code
   43  
   44      !CONTROL BITS
   45      %constinteger  check capacity = 1
   46      %constinteger  check unass    = 2
   47      %constinteger  check array    = 4
   48      %constinteger  check bits     = check array;  ! The only one that does anything so far
   49  
   50      !REGISTERS - basic register number = actual value + 1
   51      %constinteger  AX = 1
   52      %constinteger  CX = 2
   53      %constinteger  DX = 3
   54      %constinteger  BX = 4
   55      %constinteger  SP = 5
   56      %constinteger  BP = 6
   57      %constinteger  SI = 7
   58      %constinteger  DI = 8
   59  
   60      ! Floating point coprocessor stack registers
   61      %constinteger  FR0	= 9
   62      !%constinteger  FR1	= 10
   63      !%constinteger  FR2	= 11
   64      !%constinteger  FR3	= 12
   65      !%constinteger  FR4	= 13
   66      !%constinteger  FR5	= 14
   67      !%constinteger  FR6	= 15
   68      %constinteger  FR7	= 16
   69  
   70      ! 8 bit registers - actual value + 17
   71      %constinteger	AL	= 17
   72      %constinteger	CL	= 18
   73      %constinteger	DL	= 19
   74      %constinteger	BL	= 20
   75      %constinteger	AH	= 21
   76      %constinteger	CH	= 22
   77      %constinteger	DH	= 23
   78      %constinteger	BH	= 24
   79  
   80      ! Pseudo Registers
   81      %constinteger  any   = 25  ; ! Truly any register
   82      %constinteger  anyg  = 26  ; ! A "General Purpose" byte accessible register (AX, BX, CX, DX)
   83      %constinteger  anyp  = 27  ; ! A pointing register (BX, SI, DI)
   84      %constinteger  anyf  = 28  ; ! Generally means the top of the 8087 stack
   85  
   86      !DATA FORMS
   87  
   88      ! EXTERNAL FORM
   89      %constinteger  simple         = 1
   90      %constinteger  name           = 2
   91      %constinteger  label          = 3
   92      %constinteger  recordformat   = 4
   93      %constinteger  switch         = 6
   94      %constinteger  array          = 11
   95      %constinteger  arrayname      = 12
   96      %constinteger  namearray      = 13
   97      %constinteger  namearrayname  = 14
   98  
   99      ! INTERNAL
  100      %constinteger  constant    = 0
  101      %constinteger  v in r      = 1
  102      %constinteger  av in r     = 2
  103      %constinteger  a in r      = 3
  104      %constinteger  v in s      = 4
  105      %constinteger  av in s     = 5
  106      %constinteger  a in s      = 6
  107      %constinteger  v in rec    = 7
  108      %constinteger  av in rec   = 8
  109      %constinteger  a in rec    = 9
  110      %constinteger  pgm label   = 10
  111  
  112      !DATA TYPES
  113      %constinteger  general  = 0
  114      %constinteger  integer  = 1
  115      %constinteger  real     = 2
  116      %constinteger  string   = 3
  117      %constinteger  record   = 4
  118      ! Private internal derived types
  119      %constinteger  byte     = 5
  120      %constinteger  lreal    = 6
  121  
  122      ! SIZE OF EACH OF THOSE TYPES IN BYTES
  123      %constbyteintegerarray  vsize(general:lreal) = 0,4,4,0,0,1,8
  124  
  125      ! Define type codes known externally (to pass 3 and user):
  126      %constbyteintegerarray  gen map(general:lreal) =
  127+       0,      1,     2,      3,     4,       6,     8
  128  
  129      ! GENERIC STORE ALIGNMENT - ASSUME 80386
  130      %constinteger  align    = 3
  131      %constinteger  wordsize = 4;  ! in bytes
  132  
  133      !OWN INFO
  134      %constinteger  own      = 1
  135      %constinteger  con      = 2
  136      %constinteger  external = 3
  137      %constinteger  system   = 4
  138      %constinteger  dynamic  = 5
  139      %constinteger  primrt   = 6
  140      %constinteger  permrt   = 7
  141  
  142  {Procedure end codes}
  143  
  144  	%constinteger	Map     = -2,
  145+ 					Fn      = -1,               {negative implies stacked result}
  146+ 					Routine =  0,
  147+ 					True    =  1,
  148+ 					False   =  2
  149  
  150      ! PERM ROUTINE INDEXES
  151      %constinteger  iexp   =  1;  ! Integer Exponent
  152      %constinteger  fexp   =  2;  ! floating exponent
  153      %constinteger  smove  =  3;  ! string copy (length checked)
  154      %constinteger  sjam   =  4;  ! string copy (whatever fits)
  155      %constinteger  sconc  =  5;  ! string concatenate (length checked)
  156      %constinteger  sjconc =  6;	 ! concatenate whatever fits
  157      %constinteger  sresln =  7;  ! string resolution
  158      %constinteger  scomp  =  8;  ! string compare
  159      %constinteger  aref   =  9;  ! array access
  160      %constinteger  adef   = 10;  ! array definition
  161      %constinteger  signal = 11;  ! %signal
  162      %constinteger  stop   = 12;  ! %stop
  163      %constinteger  lastperm = stop
  164  
  165      ! and the corresponding linkage names for the perms
  166      %const %string(12)%array permname(1:lastperm)=
  167+     "_IMPIEXP",
  168+     "_IMPFEXP",
  169+     "_IMPSTRCPY",
  170+     "_IMPSTRJAM",
  171+     "_IMPSTRCAT",
  172+     "_IMPSTRJCAT",
  173+     "_IMPSTRRES",
  174+     "_IMPSTRCMP",
  175+     "_IMPAREF",
  176+     "_IMPADEF",
  177+     "_IMPSIGNAL",
  178+     "_IMPSTOP"
  179  
  180      ! Compiler Internal Operations (not to be confused with OpCodes)
  181      %constinteger  ADDx    = 1
  182      %constinteger  SUBx    = 2
  183      %constinteger  MULx    = 3
  184      %constinteger  DIVx    = 4
  185      %constinteger  CONCx   = 5
  186      %constinteger  ANDx    = 6
  187      %constinteger  ORx     = 7
  188      %constinteger  XORx    = 8
  189      %constinteger  LSHx    = 9
  190      %constinteger  RSHx    = 10
  191      %constinteger  REMx    = 11
  192      %constinteger  EXPx    = 12
  193      %constinteger  REXPx   = 13
  194      %constinteger  RDIVx   = 14
  195      %constinteger  NOTx    = 15
  196      %constinteger  NEGx    = 16
  197      %constinteger  ABSx    = 17
  198      %constinteger  unaries = 15
  199  
  200      ! opcode indexes...
  201  
  202      ! simple (no operand) ones first
  203      %constinteger NOP	= 0
  204      %constinteger CWD   = 1
  205      %constinteger RET   = 2
  206      %constinteger SAHF  = 3
  207      %constinteger LEAVE = 4
  208  
  209      ! simple unary math functions
  210      %constinteger DEC = 5
  211      %constinteger INC = 6
  212      %constinteger NEG = 7
  213      %constinteger NOT = 8
  214  
  215      ! simple unary moves
  216      %constinteger POP  = 9
  217      %constinteger PUSH = 10
  218  
  219      ! two operand moves
  220      %constinteger LEA  = 11
  221      %constinteger MOV  = 12
  222      %constinteger XCHG = 13
  223  
  224      ! simple two operand math functions
  225      %constinteger ADC = 14
  226      %constinteger ADD = 15
  227      %constinteger AND = 16
  228      %constinteger CMP = 17
  229      %constinteger OR  = 18
  230      %constinteger SUB = 19
  231      %constinteger XOR = 20
  232      ! slightly more complicated two operand math
  233      %constinteger SHL  = 21
  234      %constinteger SHR  = 22
  235      %constinteger IDIV = 23
  236      %constinteger IMUL = 24
  237  
  238      ! calls and jumps
  239      %constinteger CALL = 25
  240      %constinteger JE   = 26
  241      %constinteger JNE  = 27
  242      %constinteger JG   = 28
  243      %constinteger JGE  = 29
  244      %constinteger JL   = 30
  245      %constinteger JLE  = 31
  246      %constinteger JA   = 32
  247      %constinteger JAE  = 33
  248      %constinteger JB   = 34
  249      %constinteger JBE  = 35
  250      %constinteger JMP  = 36
  251  
  252      ! Floating point instructions - note that these map directly onto
  253      ! 8087 sequences, unlike the generic MOV, ADD style of the base
  254      ! operations for the 8086
  255      %constinteger	FILD	= 37
  256      %constinteger	FLDD	= 38
  257      %constinteger	FLDQ	= 39
  258      %constinteger	FSTI	= 40
  259      %constinteger	FSTD	= 41
  260      %constinteger	FSTQ	= 42
  261      %constinteger	FADD	= 43
  262      %constinteger	FSUB	= 44
  263      %constinteger	FSUBR	= 45
  264      %constinteger	FMUL	= 46
  265      %constinteger	FDIV	= 47
  266      %constinteger	FDIVR	= 48
  267      %constinteger	FCMP	= 49
  268      %constinteger	FCHS	= 50
  269      %constinteger	FABS	= 51
  270      ! Special floating point things
  271      %constinteger	FSTSW	= 52
  272      %constinteger	FLDZ	= 53
  273      %constinteger	FLDPI	= 54
  274  
  275      ! modifiers to memory base for accessing global memory
  276      %constinteger	DATA	= 16_10
  277      %constinteger	COT		= 16_20
  278      %constinteger	BSS		= 16_30
  279      %constinteger	DISPLAY	= 16_40
  280      %constinteger	EXT		= 16_50
  281      %constinteger	SWT		= 16_60
  282      %constinteger	CODE	= 16_70
  283  
  284  	{Condition codes}
  285  
  286  	{ The "Never" test should never! be used. The others are all used } 
  287  	%constinteger	EQ = 1,   LT = 2,   GT = 4,   TT = 8,  Always = 7,
  288+ 					NE = 6,   LE = 3,   GE = 5,   FF = 9,  Never  = 0
  289  
  290  	%constbytearray Reverse(Never:FF) =	Never  {Never},
  291+ 										EQ     {EQ},
  292+ 										GT     {LT},
  293+ 										GE     {LE},
  294+ 										LT     {GT},
  295+ 										LE     {GE},
  296+ 										NE     {NE},
  297+ 										Always {Always},
  298+ 										TT     {TT},
  299+ 										FF     {FF}
  300  	%constbytearray Negated(Never:FF) =	Always {Never},
  301+ 										NE     {EQ},
  302+ 										GE     {LT},
  303+ 										GT     {LE},
  304+ 										LE     {GT},
  305+ 										LT     {GE},
  306+ 										EQ     {NE},
  307+ 										Never  {Always},
  308+ 										FF     {TT},
  309+ 										TT     {FF}
  310  	%constbytearray TestToOp(Never:FF) =	JMP {Never - This is added for completeness},
  311+ 											JE  {EQ},
  312+ 											JL  {LT},
  313+ 											JLE {LE},
  314+ 											JG  {GT},
  315+ 											JGE {GE},
  316+ 											JNE {NE},
  317+ 											JMP {Always},
  318+ 											JNE {TT},
  319+ 											JE  {FF}
  320  	%constbytearray TestToUnsignedOp(Never:FF) =	JMP {Never - This is added for completeness},
  321+ 													JE  {EQ},
  322+ 													JB  {LT},
  323+ 													JBE {LE},
  324+ 													JA  {GT},
  325+ 													JAE {GE},
  326+ 													JNE {NE},
  327+ 													JMP {Always},
  328+ 													JNE {TT},
  329+ 													JE  {FF}
  330  
  331      ! Standard IMPish data structures
  332  
  333      ! Variables are declared here
  334      ! JDM JDM added idname to remember the IMP variable names
  335      %recordformat  varfm( %string(255) idname, %byteinteger type, form, level, scope, dim, %integer  disp, format, size, pbase, extra, extdisp )
  336      %record(varfm)%array  var(0:max vars)
  337      %record(varfm)%name   decvar
  338      %record(varfm)     begin
  339  
  340      ! The compiler is stack based
  341      ! JDM JDM added idname to remember the IMP variable name
  342      %recordformat  stackfm(%string(255) idname, %byteinteger type, form, aform, base, scope, dim, %integer  disp, format, size, pbase, extra, extdisp, var no)
  343      %record(stackfm)%array  stack(1:max stack)
  344      %record(stackfm)   null
  345      %record(stackfm)%name top
  346  
  347      ! Pass 1 uses a lame label redefinition that forces us to map
  348      ! label ID's into unique labels for pass 3, using this database
  349      %recordformat LabelFm(%integer id, tag)
  350      %record(LabelFm)%array Labels(1:Max Labs)
  351      %integer J Tag;		! most recent Jump tag translation - needed when planting event blocks
  352  
  353      ! Status of registers
  354      %ownintegerarray  activity(0:fr7) = 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  355      %owninteger  claimed = 0
  356  
  357      ! Pointer registers may be pointing to non-local display - we remember
  358      ! them for future use
  359      %ownintegerarray displayhint(AX:DI) = 0, 0, 0, 0, 0, 0, 0, 0
  360  
  361      ! Math Co-processor uses a stack - we remember where it should be
  362      ! with this pointer
  363      %owninteger fpustack = 0
  364  
  365      ! A general purpose workspace resource
  366      %recordformat gp tag(%integer info, addr, flags, link)
  367      %record(gptag)%array gptags(0:Max GP)
  368      %integer gp asl;
  369  
  370      %owninteger control = check bits;   ! Current compiler flags (set by %control statement)
  371      %owninteger diagnose = 0;           ! Current diagnostic flags (set by %diagnose statement)
  372  	%owninteger Language Flags = 0;		! Special directive flags for languages (other than standard imp)
  373  
  374      %owninteger nextcad = 0;            ! notional code address (not real - pass3 shuffles stuff)
  375      %owninteger level = 0;              ! current contextual level
  376      %integer    sym, Pending;           ! CODE SYMBOL, NEXT SYMBOL
  377      %integer    vlb,vub;                ! VECTOR LOWER/UPPER BOUND
  378      %owninteger current line = 0;       ! SOURCE LINE NUMBER
  379      %owninteger stp = 0;                ! STACK POINTER
  380      %integer    data size;              ! CURRENT DATA ITEM SIZE
  381      %owninteger frame = 0;              ! LOCAL STACK FRAME EXTENT
  382      %integer    parms;                  ! START OF PARAMETER STACK
  383      %owninteger invert = 0;             ! CONDITION INVERSION FLAG
  384      %owninteger compare unsign = 0;     ! CONDITION WAS NON-STANDARD (GENERALLY FPU COMPARE)
  385      %owninteger uncond jump = 0;        ! ADDRESS OF CODE HOLE
  386      %owninteger block type = 1;         ! -1 = RECORDS, 1 = PROCEDURE, 2 = SPEC
  387      %owninteger in params = 0;          ! NON-ZERO INSIDE PARAMETER LISTS
  388      %integer    otype, owntype, ownform;  ! Information about OWNs currently being declared
  389      %integer    spec, potype;           ! More about current declaration
  390      %integer    i, j;                   ! used in the initialisation loops only
  391      %owninteger Fp Result Loc = -1;     ! Place to store Real and LReal function results
  392  
  393      %constinteger max switch = 1000;    ! Size in WORDS of switch segment table
  394      %integerarray swtab(0:max switch)
  395      %owninteger swtp = 0;               ! pointer to next switch segment entry
  396  
  397      %ownstring(255)  external id = "",
  398+ 	                 alias = "",
  399+ 					 block name = ""
  400  
  401      %byteintegerarray  current string(0:255);   ! current string literal
  402  
  403      %integer  xlen
  404      %byteintegerarray x sym buff(0:255);     ! current external string name
  405  
  406      ! WORK List - used to optimise use of temporary storage
  407      ! There is a head of list for each contextual level
  408      %ownintegerarray worklist(1:max level) = 
  409+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  410  
  411      %longreal rvalue;		! floating point value for constants and initialisers
  412  
  413      %owninteger ownval = 0; ! value to use when initialising OWNs
  414  
  415      !-----------------------------------------------------------
  416      ! Start with machine independent utility functions and stack
  417      ! manipulation and debug
  418      !-----------------------------------------------------------
  419  
  420      !                                                             >> SHOW <<
  421      %routine  show(%record(stackfm)%name  v)
  422          ! JDM The field widths have been tweaked to align columns
  423          write(v_varno,4)
  424          print string(" : Typ="); write(v_type,1)
  425          print string(" Frm="); write(v_form,1)
  426          print string(" Bse="); write(v_base,3);
  427          print string(" Dsp="); write(v_disp,5)
  428          print string(" ExtDsp="); write(v_extdisp,4)
  429          print string(" Siz="); write(v_size,3)
  430          print string(" Xtr="); write(v_extra,3)
  431          print string(" Fmt="); write(v_format,2)
  432          print string(" Dim="); write(v_dim,1)
  433          print string(" Pba="); write(v_pbase,4)
  434          %if (length(v_idname) # 0)%start
  435              print string(" Name='".v_idname."'") { JDM show the variable name also }
  436          %finish
  437          newline
  438      %end
  439  
  440      ! Simple ABORT routine
  441      %routine abort(%string(255) message)
  442          %integer j
  443  
  444          select output(report)
  445          printstring("Pass 2 abandoned at line ");
  446          write(current line, 1);
  447          printstring(" : ");
  448          printstring(message)
  449          newline
  450          %if stp # 0 %start
  451              print string("STACK:");  newline
  452              spaces(11) %and show(stack(j)) %for j = 1,1,stp
  453          %finish
  454          %stop
  455      %end
  456  
  457      !                                                             >> WARN <<
  458      %routine  warn(%integer  n)
  459          %switch  w(1:8)
  460          select output(report)
  461          print string("*WARNING: line")
  462          write(current line, 1);  print string(": ")
  463          -> w(n)
  464  w(1):   print string("division by zero");                     -> at
  465  w(2):   print string("Illegal FOR");                          -> at
  466  w(3):   print string("Non-local control variable?");          -> at
  467  w(4):   print string("Invalid parameter for READ SYMBOL");    -> at
  468  w(5):   print string("String constant too long");             -> at
  469  w(6):   print string("No. of shifts outwith 0..31");          -> at
  470  w(7):   print string("Illegal constant exponent");            -> at
  471  w(8):   print string("Numerical constant too big");           -> at
  472  at:     newline
  473          select output(objout)
  474      %end
  475  
  476      !                                                          >> MONITOR <<
  477      %routine  monitor(%record(stackfm)%name  v, %string(15) text)
  478          select output(report)
  479          print string(text);  print symbol(':')
  480          spaces(10-length(text))
  481          show(v)
  482          select output(objout)
  483      %end
  484  
  485      !                                                             >> GET GP TAG <<
  486      %integerfn get gp tag
  487          %integer l
  488  
  489          %if gp asl = 0 %then abort("GP Tags")
  490          l = gp asl
  491          gp asl = gp tags(l)_link
  492          %result = l
  493      %end
  494  
  495      !                                                             >> RET GP TAG <<
  496      %integerfn ret gp tag(%integer index)
  497          %integer link
  498  
  499          link = gp tags(index)_link
  500          gp tags(index)_link = gp asl
  501          gp asl = index
  502          %result = link
  503      %end
  504  
  505      !------------------------------------------------------
  506      ! Machine dependent utility routines
  507      !------------------------------------------------------
  508  
  509      ! Routines to write the intermediate file
  510      ! Record format is:
  511      ! <type><length><data>
  512      ! For debug purposes, the elements are all written as ascii
  513      ! characters, where <type> is a single letter, <length> is a single
  514      ! hex digit, length refers to the number of bytes (2 chars) of data.
  515  
  516      ! Intermediate file types:
  517      %constinteger IF OBJ		=  0; ! A - plain object code
  518      %constinteger IF DATA	    =  1; ! B - dataseg offset code word
  519      %constinteger IF CONST	    =  2; ! C - const seg offset code word
  520      %constinteger IF DISPLAY	=  3; ! D - display seg offset code word
  521      %constinteger IF JUMP		=  4; ! E - unconditional jump to label
  522      %constinteger IF JCOND	    =  5; ! F - cond jump to label JE, JNE, JLE, JL, JGE, JG
  523      %constinteger IF CALL		=  6; ! G - call a label
  524      %constinteger IF LABEL	    =  7; ! H - define a label
  525      %constinteger IF FIXUP	    =  8; ! I - define location for stack fixup instruction
  526      %constinteger IF SETFIX	    =  9; ! J - stack fixup <location> <amount>
  527      %constinteger IF REQEXT	    = 10; ! K - external name spec
  528      %constinteger IF REFLABEL   = 11; ! L - relative address of label (JDM JDM added new IBJ command)
  529      %constinteger IF REFEXT	    = 12; ! M - external name relative offset code word (call external)
  530      %constinteger IF BSS		= 13; ! N - BSS segment offset code word
  531      %constinteger IF COTWORD	= 14; ! O - Constant table word
  532      %constinteger IF DATWORD	= 15; ! P - Data segment word
  533      %constinteger IF SWTWORD	= 16; ! Q - switch table entry - actually a label ID
  534      %constinteger IF SOURCE	    = 17; ! R - name of the source file
  535      %constinteger IF DEFEXTCODE = 18; ! S - define a code label that is external
  536      %constinteger IF DEFEXTDATA = 19; ! T - define a data label that is external
  537      %constinteger IF SWT        = 20; ! U - switch table offset code word
  538      %constinteger IF LINE       = 21; ! V - line number info for debugger
  539      %constinteger IF ABSEXT     = 22; ! W - external name absolute offset code word (data external)
  540  
  541      %routine  writenibble(%integer n)
  542          n = n & 16_f;
  543          %if 0 <= n %and n <= 9 %start
  544              printsymbol(n + '0');
  545          %else
  546              printsymbol(n + ('A' - 10));
  547          %finish
  548      %end
  549  
  550      ! print a number in hexadecimal, to "places" size
  551      %routine write hex(%integer n, places)
  552          %integer p, shift
  553  
  554          shift = (places - 1) * 4
  555          %while shift > 0 %cycle
  556              p = n >> shift
  557              writenibble(p)
  558              shift = shift - 4
  559          %repeat
  560          writenibble(n)
  561      %end
  562  
  563      %routine  writeifrecord(%integer type, %integer length, %byteintegerarrayname buffer)
  564          %integer c1, c2, i;
  565  
  566          select output(objout)
  567          printsymbol('A'+type);
  568          %if (length > 255) %then abort("Intermediate file record too long");
  569          writenibble(length>>4);
  570          writenibble(length&15);
  571  	
  572          i = 0;
  573          %while (length > 0) %cycle
  574              c1 = buffer(i) >> 4;
  575              c2 = buffer(i) & 15;
  576              writenibble(c1);
  577              writenibble(c2);
  578              i = i + 1;
  579              length = length - 1;
  580          %repeat
  581          newline
  582      %end
  583  
  584      ! Simple buffered output of code bytes...
  585      %own %integer objectptr = 0;
  586  	%const %integer objbufmax = 20
  587      %own %byte %integer %array objectbytes(0:objbufmax);
  588      ! And corresponding bytes for the listing (not always the same for fudged opcodes)
  589      %own %integer listptr = 0;
  590  	%const %integer lstbufmax = 11
  591      %own %byte %integer %array listbytes(0:lstbufmax);
  592  
  593  	! routine to clean to object buffer
  594  	%routine ClearObjectBuffer
  595  		%integer i
  596  		%for i = 0,1,objbufmax %cycle
  597  			objectbytes(i) = 0
  598  		%repeat
  599  		objectptr = 0;
  600  	%end
  601  
  602      ! Routine to provide the address and hex opcode listing in the
  603      ! diagnostic output
  604      %routine  listpreamble
  605          %integer i;
  606  
  607          select output(listout)
  608          space; writehex(nextcad, 4); space;
  609          %for i = 0, 1, 7 %cycle
  610              %if i < listptr %start
  611                  writehex(listbytes(i), 2)
  612                  space
  613              %else
  614                  spaces(3)
  615              %finish
  616          %repeat
  617          spaces(8)
  618          nextcad = nextcad + listptr;
  619          listptr = 0;
  620      %end
  621  
  622      ! flush the code buffer
  623      %routine flushcode
  624          %if objectptr # 0 %start
  625              writeifrecord(IF OBJ, objectptr, objectbytes);
  626              ClearObjectBuffer;	! clear the output pipe
  627          %finish
  628      %end
  629  
  630      ! puts a normal code byte into the listing and code pipes
  631      %routine  putcodebyte(%integer b)
  632          objectbytes(objectptr) = b;
  633          objectptr = objectptr + 1;
  634      %end
  635  
  636      ! puts a normal code byte into the listing and code pipes
  637      %routine  putlistbyte(%integer b)
  638          listbytes(listptr) = b;
  639          listptr = listptr + 1;
  640      %end
  641  
  642      ! puts a normal code byte into the listing and code pipes
  643      %routine  putbyte(%integer b)
  644  		putlistbyte( b );
  645  		putcodebyte( b );
  646      %end
  647  
  648      ! A very handy little boolean function, used for instructions
  649      ! with variable size immediate operands
  650      %integerfn issmall(%integer i)
  651          %result = 1 %if i < 128 %and i > -128
  652          %result = 0;
  653      %end
  654  
  655      ! And aide-memoire of intel 80386 address modes...
  656      !-------------------------
  657      !     [EAX]
  658      !     [ECX]
  659      !     [EDX]
  660      !     [EBX]
  661      !     [][]
  662      !     [disp32]
  663      !     [ESI]
  664      !     [EDI]
  665      !-------------------------
  666      !     [EAX+disp8]
  667      !     [ECX+disp8]
  668      !     [EDX+disp8]
  669      !     [EBX+disp8]
  670      !     [][]
  671      !     [EBP+disp8]
  672      !     [ESI+disp8]
  673      !     [EDI+disp8]
  674      !-------------------------
  675      !     [EAX+disp32]
  676      !     [ECX+disp32]
  677      !     [EDX+disp32]
  678      !     [EBX+disp32]
  679      !     [][]
  680      !     [EBP+disp32]
  681      !     [ESI+disp32]
  682      !     [EDI+disp32]
  683      !-------------------------
  684  
  685      ! mod r/m format is:
  686      ! mod LHREG R/M
  687      ! where mod = 11 for rh registers
  688  
  689      ! plant a modrm reference where the rh operand is a register
  690      ! Both parameters are actual register numbers, not internal ID's
  691      %routine  modrmreg(%integer reg1, %integer reg2)
  692          putbyte(16_C0 ! (reg1 << 3) ! (reg2));
  693      %end
  694  
  695      ! tags corresponding to linker directives...
  696      %const %integer %array reltag(0:6) =
  697+     0,			{ no relocation }
  698+ 	IF DATA,    { dataseg offset code word }
  699+ 	IF CONST,   { const seg offset code word }
  700+ 	IF BSS,		{ BSS relative code word }
  701+ 	IF DISPLAY,	{ display seg offset code word }
  702+ 	IF ABSEXT, 	{ external name absolute offset code word }
  703+ 	IF SWT		{ switch table offset code word }
  704  
  705      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  706      %routine norelocateoffset( %integer offset )
  707          %integer i;
  708  
  709  		%for i=1,1,wordsize %cycle
  710  			putbyte(offset & 255)
  711  			offset = offset >> 8
  712  		%repeat
  713  
  714      %end
  715  
  716      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  717      %routine relocateoffset(%integer reloc, %integer offset, %integer extdisp)
  718          %integer tag, i;
  719  
  720  		%if reloc = 0 %start
  721  			norelocateoffset( offset )
  722  		%else
  723  			flushcode;	! so that only the offset is going into the queue
  724  
  725  			tag = reltag(reloc);
  726  			
  727  			%if tag = IF ABSEXT %start
  728  				putbyte(offset & 255); offset = offset >> 8;
  729  				putbyte(offset & 255); offset = offset >> 8;
  730  				putbyte(extdisp & 255); extdisp = extdisp >> 8;
  731  				putbyte(extdisp & 255); extdisp = extdisp >> 8;
  732  
  733  				writeifrecord(tag, wordsize, objectbytes);
  734  				ClearObjectBuffer;	! clear the queue
  735  			%else
  736  				%for i=1,1,wordsize %cycle
  737  					putbyte(offset & 255); offset = offset >> 8
  738  				%repeat
  739  				writeifrecord(tag, wordsize, objectbytes);
  740  				ClearObjectBuffer;	! clear the queue
  741  			%finish
  742  
  743  		%finish
  744  
  745      %end
  746  
  747      ! plant a modrm reference where the rh operand is in memory
  748      ! Parameter REG1 is an actual register number, but BASE is an internal ID
  749      %routine  modrmmem(%integer reg1, %integer base, %integer disp, %integer extdisp)
  750          %integer mod, reloc;
  751  
  752          reloc = base>>4;
  753          base = base & 15;
  754  
  755          %if base = 0 %start; 	! no register, just a displacement
  756              ! mod = 000, rm = 101
  757              putbyte((reg1 << 3) ! 5);
  758              relocateoffset(reloc, disp, extdisp );
  759          %else
  760              %if disp = 0 %and base # BP %start
  761                  mod = 0
  762              %else
  763                  %if issmall(disp) # 0 %start;		! fits in one byte
  764                      mod = 1
  765                  %else
  766                      mod = 2
  767                  %finish
  768              %finish
  769  
  770              ! unfortunately displacement (even zero) must be output in full if
  771              ! the offset is relocatable
  772              %if reloc # 0 %then mod = 2;
  773  
  774              %if base > DI %or base = SP %start
  775                  abort("Internal address mode error");
  776              %finish
  777  
  778              ! Note - base-1 maps internal ID to real register
  779  
  780              putbyte((mod << 6)!(reg1 << 3)!(base - 1));
  781  
  782              %if mod = 1 %start
  783                  putbyte(disp);
  784              %else
  785                  %if mod = 2 %then relocateoffset(reloc, disp, extdisp )
  786              %finish
  787          %finish
  788      %end
  789  
  790      %const %string(3) %array regname(AX:DI) =
  791+ 	"EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"
  792  
  793      %const %string(2) %array reg8name(AL:BH) =
  794+ 	"AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH"
  795  
  796      %const %string(7) %array relocname(0:6) =
  797+ 	"", "DATA", "COT", "BSS", "DISPLAY", "EXTERN", "SWTAB"
  798  
  799      ! Print the corresponding memory access string
  800      ! BASE is an internal ID, not an actual register number
  801      %routine  printmemref(%integer base, %integer disp)
  802          %integer reloc;
  803  
  804          reloc = base >> 4;
  805          base = base & 15;
  806          selectoutput(listout)
  807          printsymbol('[');
  808          %if base # 0 %start
  809              printstring(regname(base));
  810              %if reloc # 0 %start
  811                  printsymbol('+'); printstring(relocname(reloc));
  812              %finish
  813              %if disp # 0 %then %start
  814                  printsymbol('+') %if disp > 0
  815                  write(disp,1)
  816              %finish
  817          %else
  818              %if reloc # 0 %start
  819                  printstring(relocname(reloc)); printsymbol('+')
  820              %finish
  821              writehex(disp, 4)
  822          %finish
  823          printsymbol(']');
  824      %end
  825  
  826      ! opcodes
  827      %const %string(5) %array opname(NOP:JMP) =
  828+ 	"NOP", "CWD", "RET", "SAHF", "LEAVE",
  829+ 	"DEC", "INC", "NEG", "NOT",
  830+ 	"POP", "PUSH",
  831+ 	"LEA", "MOV", "XCHG",
  832+ 	"ADC", "ADD", "AND", "CMP", "OR", "SUB", "XOR",
  833+ 	"SHL", "SHR", "IDIV", "IMUL",
  834+ 	"CALL", "JE", "JNE",
  835+     "JG", "JGE", "JL", "JLE",
  836+     "JA", "JAE", "JB", "JBE", "JMP"
  837  
  838      %const %byte %integer %array opvalue(NOP:JMP) =
  839+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9,
  840+ 	16_FF, 16_FF, 16_F7, 16_F7,
  841+ 	16_8F, 16_FF,
  842+ 	16_8B, 16_89, 16_87,		{ LEA is fudged as if it were m <- r, to allow the flip }
  843+ 	16_11, 16_01, 16_21, 16_39, 16_09, 16_29, 16_31,
  844+ 	16_D1, 16_D1, 16_F7, 16_F7,
  845+ 	16_E8, 16_74, 16_75,
  846+     16_7F, 16_7D, 16_7C, 16_7E,
  847+     16_77, 16_73, 16_72, 16_76, 16_EB
  848  
  849      ! 8 bit equivalent opcodes
  850      %const %byte %integer %array op8value(NOP:JMP) =
  851+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9,      { not 8 bit, included for completeness }
  852+ 	16_FE, 16_FE, 16_F6, 16_F6,
  853+ 	16_8F, 16_FF,                           { not 8 bit, included for completeness }
  854+ 	16_8B, 16_88, 16_86,                    { LEA is not applicable for 8 bit }
  855+ 	16_10, 16_00, 16_20, 16_38, 16_08, 16_28, 16_30,
  856+ 	16_D0, 16_D0, 16_F6, 16_F6,
  857+ 	16_E8, 16_74, 16_75,
  858+     16_7F, 16_7D, 16_7C, 16_7E,
  859+     16_77, 16_73, 16_72, 16_76, 16_EB       { not 8 bit, included for completeness }
  860  
  861      ! An opcode with no operands (eg RET)
  862      %routine dumpsimple(%integer opn)
  863  
  864          putbyte(opvalue(opn));
  865  
  866          listpreamble;
  867          printstring(opname(opn));
  868          newline
  869          flushcode;
  870      %end
  871  
  872      ! A special bit of magic, used in record assignment
  873      %routine dumprepmovsb
  874          putbyte(16_f3);	! rep
  875          putbyte(16_a4);	! movsb
  876  
  877          listpreamble;
  878          printstring("REP MOVSB");
  879          newline
  880          flushcode;
  881      %end
  882  
  883      ! Used in record = 0 assignment
  884      %routine dumprepstosb
  885          putbyte(16_f3);	! rep
  886          putbyte(16_aa);	! stosb
  887  
  888          listpreamble;
  889          printstring("REP STOSB");
  890          newline
  891          flushcode;
  892      %end
  893  
  894      ! unary register operation - DEC, INC, NEG, NOT, POP, PUSH, IDIV, IMUL
  895      ! REG is an internal ID, not an actual register number
  896      %routine dumpur(%integer opn, %integer reg)
  897          %switch ops(DEC:IMUL)
  898  
  899          displayhint(reg) = 0;
  900  
  901          ->ops(opn)
  902  
  903  ops(DEC):   putbyte(16_48 + reg - AX);              ->break;
  904  ops(INC):   putbyte(16_40 + reg - AX);             	->break;
  905  ops(NEG):   putbyte(16_F7); modrmreg(3, reg - AX);  ->break;
  906  ops(NOT):   putbyte(16_F7); modrmreg(2, reg - AX);  ->break;
  907  ops(POP):   putbyte(16_58 + reg - AX);              ->break;
  908  ops(PUSH):  putbyte(16_50 + reg - AX);              ->break;
  909  ops(IDIV):  putbyte(16_F7); modrmreg(7, reg - AX);  ->break;
  910  ops(IMUL):  putbyte(16_F7); modrmreg(5, reg - AX);  ->break;
  911  
  912  break:
  913          listpreamble;
  914          printstring(opname(opn))
  915          space
  916          printstring(regname(reg));
  917          newline
  918          flushcode
  919      %end
  920  
  921      ! Plant code for a unary operation on memory
  922      ! BASE is an internal ID, not the actual register number
  923      %routine dumpum(%integer opn, %integer base, %integer disp, %integer extdisp)
  924          %switch ops(DEC:JMP)
  925  
  926          ->ops(opn)
  927  
  928  ops(DEC):   putbyte(16_FF); modrmmem(1, base, disp, extdisp);  ->break;
  929  ops(INC):   putbyte(16_FF); modrmmem(0, base, disp, extdisp);  ->break;
  930  ops(NEG):   putbyte(16_F7); modrmmem(3, base, disp, extdisp);  ->break;
  931  ops(NOT):   putbyte(16_F7); modrmmem(2, base, disp, extdisp);  ->break;
  932  ops(POP):   putbyte(16_8F); modrmmem(0, base, disp, extdisp);  ->break;
  933  ops(PUSH):  putbyte(16_FF); modrmmem(6, base, disp, extdisp);  ->break;
  934  ops(IDIV):  putbyte(16_F7); modrmmem(7, base, disp, extdisp);  ->break;
  935  ops(IMUL):  putbyte(16_F7); modrmmem(5, base, disp, extdisp);  ->break;
  936  ops(JMP):   putbyte(16_FF); modrmmem(4, base, disp, extdisp);  ->break;
  937  ops(CALL):  putbyte(16_FF); modrmmem(2, base, disp, extdisp);  ->break;
  938  
  939  break:
  940          listpreamble;
  941          printstring(opname(opn))
  942          printstring(" WORD ");	! otherwise it's ambiguous for the reader
  943          printmemref(base, disp);
  944          newline
  945          flushcode;
  946      %end
  947  
  948      ! Plant code for a unary operation on an 8 bit memory location
  949      ! Not all of the possible unary ops make sense as 8 bit destinations
  950      ! BASE is an internal ID, not the actual register number
  951      %routine dumpum8(%integer opn, %integer base, %integer disp, %integer extdisp)
  952          %integer base op, index
  953  
  954          %if opn = DEC %or opn = INC %start
  955              base op = 16_FE
  956              %if opn = DEC %then index = 1 %else index = 0
  957          %else
  958              %if opn = NOT %or opn = NEG %start
  959                  base op = 16_F6
  960                  %if opn = NOT %then index = 2 %else index = 3
  961              %else
  962                  Abort("Invalid UM8")
  963              %finish
  964          %finish
  965  
  966          putbyte(base op)
  967          modrmmem(index, base, disp, extdisp )
  968  
  969          listpreamble;
  970          printstring(opname(opn))
  971          printstring(" BYTE ");	! otherwise it's ambiguous for the reader
  972          printmemref(base, disp);
  973          newline
  974          flushcode;
  975      %end
  976  
  977      ! Plant a Memory <- Reg operation
  978      ! Both BASE and REG are internal ID's, not actual register numbers
  979      %routine dumpmr(%integer opn, %integer base, %integer disp, %integer extdisp, %integer reg)
  980  
  981          %if opn = SHL %start;	! special "shift by CL"
  982              putbyte(16_D3);
  983              modrmmem(4, base, disp, extdisp );
  984          %else
  985              %if opn = SHR %start
  986                  putbyte(16_D3);
  987                  modrmmem(5, base, disp, extdisp );
  988              %else;               ! normal stuff
  989                  putbyte(opvalue(opn));
  990                  modrmmem(reg - AX, base, disp, extdisp );
  991              %finish
  992          %finish
  993  
  994          listpreamble;
  995          printstring(opname(opn))
  996          space
  997          printmemref(base, disp);
  998          printsymbol(',')
  999          printstring(regname(reg));
  1000          newline
  1001          flushcode;
  1002      %end
  1003  
  1004      ! Plant an 8 bit Memory <- Reg operation
  1005      ! Both BASE and REG are internal ID's, not actual register numbers
  1006      %routine dumpmr8(%integer opn, %integer base, %integer disp, %integer extdisp, %integer reg)
  1007  
  1008          %if opn = SHL %start;	! special "shift by CL"
  1009              putbyte(16_D2);
  1010              modrmmem(4, base, disp, extdisp );
  1011          %else
  1012              %if opn = SHR %start
  1013                  putbyte(16_D2);
  1014                  modrmmem(5, base, disp, extdisp );
  1015              %else;               ! normal stuff
  1016                  putbyte(op8value(opn));
  1017                  modrmmem(reg - AL, base, disp, extdisp );
  1018              %finish
  1019          %finish
  1020  
  1021          listpreamble;
  1022          printstring(opname(opn))
  1023          space
  1024          printmemref(base, disp);
  1025          printsymbol(',')
  1026          printstring(reg8name(reg));
  1027          newline
  1028          flushcode;
  1029      %end
  1030  
  1031      ! Plant a 16 bit Reg <- Memory operation
  1032      ! Both BASE and REG are internal ID's, not actual register numbers
  1033      %routine dumprm(%integer opn, %integer reg, %integer base, %integer disp, %integer extdisp)
  1034  
  1035          ! We optimise the fairly common instruction MOV AX,[disp] with
  1036          ! the special short-form quirk of the 8086...
  1037  
  1038          %if reg = AX %and opn = MOV %and base & 15 = 0 %start
  1039              putbyte(16_A1)
  1040              relocateoffset(base>>4, disp, extdisp)
  1041          %else
  1042              displayhint(reg) = 0;
  1043  
  1044              putbyte(opvalue(opn)+2);
  1045              modrmmem(reg - AX, base, disp, extdisp);
  1046          %finish
  1047  
  1048          listpreamble;
  1049          printstring(opname(opn))
  1050          space
  1051          printstring(regname(reg));
  1052          printsymbol(',')
  1053          printmemref(base, disp);
  1054          newline
  1055          flushcode;
  1056      %end
  1057  
  1058      ! Plant an 8 bit Reg <- Memory operation
  1059      ! Both BASE and REG are internal ID's, not actual register numbers
  1060      %routine dumprm8(%integer opn, %integer reg, %integer base, %integer disp, %integer extdisp )
  1061  
  1062          putbyte(op8value(opn)+2);
  1063          modrmmem(reg - AL, base, disp, extdisp );
  1064  
  1065          listpreamble;
  1066          printstring(opname(opn))
  1067          space
  1068          printstring(reg8name(reg));
  1069          printsymbol(',')
  1070          printmemref(base, disp);
  1071          newline
  1072          flushcode;
  1073      %end
  1074  
  1075      ! Plant a word Reg <- Reg operation
  1076      ! Both register parameters are internal ID's
  1077      %routine dumprr(%integer opn, %integer reg1, %integer reg2)
  1078  
  1079          displayhint(reg1) = 0;
  1080  
  1081          %if opn = SHL %start;	! special "shift by CL"
  1082              putbyte(16_D3);
  1083              modrmreg(4, reg1 - AX);
  1084          %else
  1085              %if opn = SHR %start
  1086                  putbyte(16_D3);
  1087                  modrmreg(5, reg1 - AX);
  1088              %else;               ! normal stuff
  1089                  putbyte(opvalue(opn));
  1090                  modrmreg(reg2 - AX, reg1 - AX);
  1091              %finish
  1092          %finish
  1093  
  1094          listpreamble;
  1095          printstring(opname(opn))
  1096          space
  1097          printstring(regname(reg1));
  1098          printsymbol(',')
  1099          printstring(regname(reg2));
  1100          newline
  1101          flushcode;
  1102      %end
  1103  
  1104      %routine dumprr8(%integer opn, %integer reg1, %integer reg2)
  1105  
  1106          %if opn = SHL %start;	! special "shift by CL"
  1107              putbyte(16_D2);
  1108              modrmreg(4, reg1 - AL);
  1109          %else
  1110              %if opn = SHR %start
  1111                  putbyte(16_D2);
  1112                  modrmreg(5, reg1 - AL);
  1113              %else
  1114                  putbyte(op8value(opn));
  1115                  modrmreg(reg2 - AL, reg1 - AL);
  1116              %finish
  1117          %finish
  1118  
  1119          listpreamble;
  1120          printstring(opname(opn))
  1121          space
  1122          printstring(reg8name(reg1));
  1123          printsymbol(',')
  1124          printstring(reg8name(reg2));
  1125          newline
  1126          flushcode;
  1127      %end
  1128  
  1129      %const %byte %integer %array aximmediatevalue(NOP:XOR) =
  1130+     0, 0, 0, 0, 0,
  1131+ 	0, 0, 0, 0,
  1132+ 	0, 0,
  1133+ 	0, 16_B8, 0,
  1134+ 	16_15, 16_05, 16_25, 16_3D, 16_0D, 16_2D, 16_35
  1135  
  1136      ! Register immediate operations - can be MOV, Math, or Shift
  1137      ! The immediate operand may be a relocated offset as part of
  1138      ! an address calculation
  1139      %routine dumprioffset(%integer opn, %integer reg, %integer reloc, %integer immed, %integer extdisp)
  1140          %integer subop;
  1141          %switch ops(MOV:SHR)
  1142  
  1143          displayhint(reg) = 0;
  1144          reloc = reloc >> 4;			! because we pass around the or-able version
  1145  
  1146          %if reg = AX %and opn <= XOR %start
  1147              putbyte(aximmediatevalue(opn));
  1148              relocateoffset(reloc, immed, extdisp);
  1149              ->break
  1150          %else
  1151              ->ops(opn)
  1152          %finish
  1153  
  1154  ops(MOV):
  1155          putbyte(16_B8 + reg - AX); relocateoffset(reloc, immed, extdisp );    ->break;
  1156  ops(ADD):
  1157          subop = 0
  1158          %if issmall(immed) # 0 %and reloc = 0 %start
  1159              putbyte(16_83);
  1160              modrmreg(subop, reg - AX);
  1161              putbyte(immed & 255);
  1162          %else
  1163              putbyte(16_81);
  1164              modrmreg(subop, reg - AX);
  1165              relocateoffset(reloc, immed, extdisp );
  1166          %finish;                                                    ->break;
  1167  ops(ADC):
  1168          subop = 2
  1169          %if issmall(immed) # 0 %and reloc = 0 %start
  1170              putbyte(16_83);
  1171              modrmreg(subop, reg - AX);
  1172              putbyte(immed & 255);
  1173          %else
  1174              putbyte(16_81);
  1175              modrmreg(subop, reg - AX);
  1176              relocateoffset(reloc, immed, extdisp );
  1177          %finish;                                                    ->break;
  1178  ops(CMP):
  1179          subop = 7
  1180          %if issmall(immed) # 0 %and reloc = 0 %start
  1181              putbyte(16_83);
  1182              modrmreg(subop, reg - AX);
  1183              putbyte(immed & 255);
  1184          %else
  1185              putbyte(16_81);
  1186              modrmreg(subop, reg - AX);
  1187              relocateoffset(reloc, immed, extdisp );
  1188          %finish;                                                    ->break;
  1189  ops(SUB):
  1190          subop = 5
  1191          %if issmall(immed) # 0 %and reloc = 0 %start
  1192              putbyte(16_83);
  1193              modrmreg(subop, reg - AX);
  1194              putbyte(immed & 255);
  1195          %else
  1196              putbyte(16_81);
  1197              modrmreg(subop, reg - AX);
  1198              relocateoffset(reloc, immed, extdisp );
  1199          %finish;                                                    ->break;
  1200  ops(AND):
  1201          subop = 4
  1202          putbyte(16_81);
  1203          modrmreg(subop, reg - AX);
  1204          relocateoffset(reloc, immed, extdisp );                     ->break;
  1205  ops(OR):
  1206          subop = 1
  1207          putbyte(16_81);
  1208          modrmreg(subop, reg - AX);
  1209          relocateoffset(reloc, immed, extdisp );                     ->break;
  1210  ops(XOR):
  1211          subop = 6
  1212          putbyte(16_81);
  1213          modrmreg(subop, reg - AX);
  1214          relocateoffset(reloc, immed, extdisp );                     ->break;
  1215  ops(SHL):
  1216          subop = 4
  1217          %if immed = 1 %start;   ! special shift-by-one instruction
  1218              putbyte(16_D1)
  1219              modrmreg(subop, reg - AX)
  1220          %else
  1221              putbyte(16_C1)
  1222              modrmreg(subop, reg - AX)
  1223              putbyte(immed)
  1224          %finish;                                                    ->break;
  1225  ops(SHR):
  1226          subop = 5
  1227          %if immed = 1 %start;   ! special shift-by-one instruction
  1228              putbyte(16_D1)
  1229              modrmreg(subop, reg - AX)
  1230          %else
  1231              putbyte(16_C1)
  1232              modrmreg(subop, reg - AX)
  1233              putbyte(immed)
  1234          %finish;                                                    ->break;
  1235  
  1236  break:
  1237          listpreamble;
  1238          printstring(opname(opn))
  1239          space
  1240          printstring(regname(reg));
  1241          printsymbol(',')
  1242          %if reloc # 0 %start
  1243              printstring(relocname(reloc)); printsymbol('+')
  1244          %finish
  1245          write(immed, 1)
  1246          newline
  1247          flushcode;
  1248      %end
  1249  
  1250      ! Register immediate operations - can be MOV, Math, or Shift
  1251      %routine dumpri(%integer opn, %integer reg, %integer immed)
  1252          %integer subop;
  1253          %switch ops(MOV:SHR)
  1254  
  1255          displayhint(reg) = 0;
  1256  
  1257          %if reg = AX %and opn <= XOR %start
  1258              putbyte(aximmediatevalue(opn));
  1259              norelocateoffset( immed );
  1260              ->break
  1261          %else
  1262              ->ops(opn)
  1263          %finish
  1264  
  1265  ops(MOV):
  1266          putbyte(16_B8 + reg - AX); norelocateoffset( immed );    ->break;
  1267  ops(ADD):
  1268          subop = 0
  1269          %if issmall(immed) # 0 %start
  1270              putbyte(16_83);
  1271              modrmreg(subop, reg - AX);
  1272              putbyte(immed & 255);
  1273          %else
  1274              putbyte(16_81);
  1275              modrmreg(subop, reg - AX);
  1276              norelocateoffset( immed );
  1277          %finish;                                                    ->break;
  1278  ops(ADC):
  1279          subop = 2
  1280          %if issmall(immed) # 0 %start
  1281              putbyte(16_83);
  1282              modrmreg(subop, reg - AX);
  1283              putbyte(immed & 255);
  1284          %else
  1285              putbyte(16_81);
  1286              modrmreg(subop, reg - AX);
  1287              norelocateoffset( immed );
  1288          %finish;                                                    ->break;
  1289  ops(CMP):
  1290          subop = 7
  1291          %if issmall(immed) # 0 %start
  1292              putbyte(16_83);
  1293              modrmreg(subop, reg - AX);
  1294              putbyte(immed & 255);
  1295          %else
  1296              putbyte(16_81);
  1297              modrmreg(subop, reg - AX);
  1298              norelocateoffset( immed );
  1299          %finish;                                                    ->break;
  1300  ops(SUB):
  1301          subop = 5
  1302          %if issmall(immed) # 0 %start
  1303              putbyte(16_83);
  1304              modrmreg(subop, reg - AX);
  1305              putbyte(immed & 255);
  1306          %else
  1307              putbyte(16_81);
  1308              modrmreg(subop, reg - AX);
  1309              norelocateoffset( immed );
  1310          %finish;                                                    ->break;
  1311  ops(AND):
  1312          subop = 4
  1313          putbyte(16_81);
  1314          modrmreg(subop, reg - AX);
  1315          norelocateoffset( immed );                               ->break;
  1316  ops(OR):
  1317          subop = 1
  1318          putbyte(16_81);
  1319          modrmreg(subop, reg - AX);
  1320          norelocateoffset( immed );                               ->break;
  1321  ops(XOR):
  1322          subop = 6
  1323          putbyte(16_81);
  1324          modrmreg(subop, reg - AX);
  1325          norelocateoffset( immed );                               ->break;
  1326  ops(SHL):
  1327          subop = 4
  1328          %if immed = 1 %start;   ! special shift-by-one instruction
  1329              putbyte(16_D1)
  1330              modrmreg(subop, reg - AX)
  1331          %else
  1332              putbyte(16_C1)
  1333              modrmreg(subop, reg - AX)
  1334              putbyte(immed)
  1335          %finish;                                                    ->break;
  1336  ops(SHR):
  1337          subop = 5
  1338          %if immed = 1 %start;   ! special shift-by-one instruction
  1339              putbyte(16_D1)
  1340              modrmreg(subop, reg - AX)
  1341          %else
  1342              putbyte(16_C1)
  1343              modrmreg(subop, reg - AX)
  1344              putbyte(immed)
  1345          %finish;                                                    ->break;
  1346  
  1347  break:
  1348          listpreamble;
  1349          printstring(opname(opn))
  1350          space
  1351          printstring(regname(reg));
  1352          printsymbol(',')
  1353          write(immed, 1)
  1354          newline
  1355          flushcode;
  1356      %end
  1357  
  1358      ! Memory (word) immediate operations - can be MOV, Math, or Shift
  1359      %routine dumpmi(%integer opn, %integer base, disp, extdisp, %integer immed)
  1360          %integer subop;
  1361          %switch ops(MOV:SHR)
  1362  
  1363          ->ops(opn)
  1364  
  1365  ops(MOV):
  1366          putbyte(16_C7)
  1367          modrmmem(0, base, disp, extdisp )
  1368          norelocateoffset( immed );                                  ->break;
  1369  ops(ADD):
  1370          subop = 0
  1371          %if issmall(immed) # 0 %start
  1372              putbyte(16_83);
  1373              modrmmem(subop, base, disp, extdisp )
  1374              putbyte(immed & 255);
  1375          %else
  1376              putbyte(16_81);
  1377              modrmmem(subop, base, disp, extdisp )
  1378              norelocateoffset( immed )
  1379          %finish;                                                    ->break;
  1380  ops(ADC):
  1381          subop = 2
  1382          %if issmall(immed) # 0 %start
  1383              putbyte(16_83);
  1384              modrmmem(subop, base, disp, extdisp )
  1385              putbyte(immed & 255);
  1386          %else
  1387              putbyte(16_81);
  1388              modrmmem(subop, base, disp, extdisp )
  1389              norelocateoffset( immed )
  1390          %finish;                                                    ->break;
  1391  ops(CMP):
  1392          subop = 7
  1393          %if issmall(immed) # 0 %start
  1394              putbyte(16_83);
  1395              modrmmem(subop, base, disp, extdisp )
  1396              putbyte(immed & 255);
  1397          %else
  1398              putbyte(16_81);
  1399              modrmmem(subop, base, disp, extdisp )
  1400              norelocateoffset( immed )
  1401          %finish;                                                    ->break;
  1402  ops(SUB):
  1403          subop = 5
  1404          %if issmall(immed) # 0 %start
  1405              putbyte(16_83);
  1406              modrmmem(subop, base, disp, extdisp )
  1407              putbyte(immed & 255);
  1408          %else
  1409              putbyte(16_81);
  1410              modrmmem(subop, base, disp, extdisp )
  1411              norelocateoffset( immed )
  1412          %finish;                                                    ->break;
  1413  ops(AND):
  1414          subop = 4
  1415          putbyte(16_81)
  1416          modrmmem(subop, base, disp, extdisp )
  1417          norelocateoffset( immed );                                  ->break;
  1418  ops(OR):
  1419          subop = 1
  1420          putbyte(16_81)
  1421          modrmmem(subop, base, disp, extdisp )
  1422          norelocateoffset( immed );                                  ->break;
  1423  ops(XOR):
  1424          subop = 6
  1425          putbyte(16_81)
  1426          modrmmem(subop, base, disp, extdisp )
  1427          norelocateoffset( immed );                                  ->break;
  1428  ops(SHL):
  1429          subop = 4;
  1430          %if immed = 1 %start;   ! special shift-by-one instruction
  1431              putbyte(16_D1);
  1432              modrmmem(subop, base, disp, extdisp )
  1433          %else
  1434              putbyte(16_C1);
  1435              modrmmem(subop, base, disp, extdisp )
  1436              putbyte(immed)
  1437          %finish;                                                    ->break;
  1438  ops(SHR):
  1439          subop = 5
  1440          %if immed = 1 %start;   ! special shift-by-one instruction
  1441              putbyte(16_D1);
  1442              modrmmem(subop, base, disp, extdisp )
  1443          %else
  1444              putbyte(16_C1);
  1445              modrmmem(subop, base, disp, extdisp )
  1446              putbyte(immed)
  1447          %finish;                                                    ->break;
  1448  break:
  1449          listpreamble;
  1450          printstring(opname(opn))
  1451          printstring(" WORD ");	! otherwise it's ambiguous for the reader
  1452          printmemref(base, disp);
  1453          printsymbol(',')
  1454          write(immed, 1)
  1455          newline
  1456          flushcode;
  1457      %end
  1458  
  1459      ! Memory (8 bit) immediate operations - can be MOV, Math, or Shift
  1460      %routine dumpmi8(%integer opn, %integer base, disp, extdisp, %integer immed)
  1461          %integer subop;
  1462          %switch ops(MOV:SHR)
  1463  
  1464  		->ops(opn)
  1465  
  1466  ops(MOV):
  1467          subop = 0
  1468          putbyte(16_C6)
  1469          modrmmem(subop, base, disp, extdisp )
  1470          putbyte(immed & 255);                                       ->break;
  1471  ops(ADD):
  1472          subop = 0
  1473          putbyte(16_80)
  1474          modrmmem(subop, base, disp, extdisp )
  1475          putbyte(immed & 255);                                       ->break;
  1476  ops(ADC):
  1477          subop = 2
  1478          putbyte(16_80)
  1479          modrmmem(subop, base, disp, extdisp )
  1480          putbyte(immed & 255);                                       ->break;
  1481  ops(CMP):
  1482          subop = 7
  1483          putbyte(16_80)
  1484          modrmmem(subop, base, disp, extdisp )
  1485          putbyte(immed & 255);                                       ->break;
  1486  ops(SUB):
  1487          subop = 5
  1488          putbyte(16_80)
  1489          modrmmem(subop, base, disp, extdisp )
  1490          putbyte(immed & 255);                                       ->break;
  1491  ops(AND):
  1492          subop = 4
  1493          putbyte(16_80)
  1494          modrmmem(subop, base, disp, extdisp )
  1495          putbyte(immed & 255);                                       ->break;
  1496  ops(OR):
  1497          subop = 1
  1498          putbyte(16_80)
  1499          modrmmem(subop, base, disp, extdisp )
  1500          putbyte(immed & 255);                                       ->break;
  1501  ops(XOR):
  1502          subop = 6
  1503          putbyte(16_80)
  1504          modrmmem(subop, base, disp, extdisp )
  1505          putbyte(immed & 255);                                       ->break;
  1506  ops(SHL):
  1507          subop = 4
  1508          %if immed = 1 %start;   ! special shift-by-one instruction
  1509              putbyte(16_D0)
  1510              modrmmem(subop, base, disp, extdisp )
  1511          %else
  1512              putbyte(16_C0)
  1513              modrmmem(subop, base, disp, extdisp )
  1514              putbyte(immed)
  1515          %finish;                                                    ->break;
  1516  ops(SHR):
  1517          subop = 5
  1518          %if immed = 1 %start;   ! special shift-by-one instruction
  1519              putbyte(16_D0)
  1520              modrmmem(subop, base, disp, extdisp )
  1521          %else
  1522              putbyte(16_C0)
  1523              modrmmem(subop, base, disp, extdisp )
  1524              putbyte(immed)
  1525          %finish;                                                    ->break;
  1526  break:
  1527          listpreamble;
  1528          printstring(opname(opn))
  1529          printstring(" BYTE ");	! otherwise it's ambiguous for the reader
  1530          printmemref(base, disp);
  1531          printsymbol(',')
  1532          write(immed, 1)
  1533          newline
  1534          flushcode;
  1535      %end
  1536  
  1537      ! Finally, a catch-all that recasts operations using generic
  1538      ! Var Stack structures
  1539      ! Plant a 16 bit Reg <- Var operation
  1540      %routine dumprv(%integer opn, %integer reg, %record(stackfm)%name v)
  1541  
  1542          %if v_form = V in R %start
  1543              dumprr(opn, reg, v_base)
  1544          %else
  1545              %if v_form = V in S %start
  1546                  dumprm(opn, reg, v_base!v_scope, v_disp, v_extdisp )
  1547              %else
  1548                  %if v_form = constant %start
  1549                      dumprioffset(opn, reg, v_scope, v_disp, v_extdisp )
  1550                  %else
  1551                      abort("Address Mode")
  1552                  %finish
  1553              %finish
  1554          %finish
  1555      %end
  1556  
  1557      ! Another special dumper - the only "Unary" operation that
  1558      ! takes an immediate operand is PUSH
  1559      %routine dumppushi(%integer reloc, %integer immed, %integer extdisp )
  1560  
  1561          reloc = reloc >> 4;			! because we pass around the or-able version
  1562  
  1563          %if reloc = 0 %and is small(immed) # 0 %start
  1564              putbyte(16_6A);
  1565              putbyte(immed & 255);
  1566          %else
  1567              putbyte(16_68);
  1568              relocateoffset(reloc, immed, extdisp );
  1569          %finish
  1570  
  1571          listpreamble;
  1572          printstring("PUSH")
  1573          space
  1574          %if reloc # 0 %start
  1575              printstring(relocname(reloc)); printsymbol('+')
  1576          %finish
  1577          write(immed, 1)
  1578          newline
  1579          flushcode
  1580      %end
  1581  
  1582      %routine dumpvpush(%record(stackfm)%name v)
  1583  
  1584          %if v_form = V in R %start
  1585              dumpur(PUSH, v_base)
  1586          %else
  1587              %if v_form = V in S %start
  1588                  dumpum(PUSH, v_base!v_scope, v_disp, v_extdisp )
  1589              %else
  1590                  %if v_form = constant %start
  1591                      dumppushi(v_scope, v_disp, v_extdisp )
  1592                  %else
  1593                      abort("Push Mode")
  1594                  %finish
  1595              %finish
  1596          %finish
  1597      %end
  1598        
  1599      !----------------------------------------------------------
  1600      ! Floating point instructions - much simpler since there are
  1601      ! only two forms - RR and RM
  1602  
  1603      %conststring(10)%array flopname(FILD:FLDPI) =
  1604+     "FILD", "FLD DWORD", "FLD QWORD", "FISTP",
  1605+     "FSTP DWORD", "FSTP QWORD", "FADDP", "FSUBP",
  1606+     "FSUBRP", "FMULP", "FDIVP", "FDIVRP",
  1607+     "FCOMPP", "FCHS", "FABS",
  1608+     "FSTSW AX", "FLDZ", "FLDPI"
  1609  
  1610      ! The prefix opcode
  1611      %constbyteintegerarray flprefix(FILD:FLDPI) =
  1612+     16_DB, 16_D9, 16_DD, 16_DB,
  1613+     16_D9, 16_DD, 16_DE, 16_DE,
  1614+     16_DE, 16_DE, 16_DE, 16_DE,
  1615+     16_DE, 16_D9, 16_D9,
  1616+     16_DF, 16_D9, 16_D9
  1617  
  1618      ! The function selector to put in the field in the second byte
  1619      ! (or the second byte)
  1620      %constbyteintegerarray flindex(FILD:FLDPI) =
  1621+     16_00, 16_00, 16_00, 16_03,
  1622+     16_03, 16_03, 16_C0, 16_E8,
  1623+     16_E0, 16_C8, 16_F8, 16_F0,
  1624+     16_D8, 16_E0, 16_E1,
  1625+     16_E0, 16_EE, 16_EB
  1626  
  1627      ! Plant a Floating Point Reg <- Memory operation
  1628      ! BASE is an internal ID, not actual register number
  1629      ! Destination register is implicitly the stack top
  1630      %routine dumpfloprm(%integer opn, %integer base, %integer disp, %integer extdisp )
  1631  
  1632          %if opn <= FLDQ %start;	! a load type
  1633              fpu stack = fpu stack + 1
  1634              %if fpu stack > 8 %then abort("FPU Stack Overflow")
  1635          %else
  1636              fpu stack = fpu stack - 1
  1637              %if fpu stack < 0 %then abort("FPU Stack Underflow")
  1638          %finish
  1639  
  1640  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  1641          putbyte(flprefix(opn));
  1642          modrmmem(flindex(opn), base, disp, extdisp );
  1643  
  1644          listpreamble;
  1645          printstring(flopname(opn))
  1646          space
  1647          printmemref(base, disp);
  1648          newline
  1649          flushcode;
  1650      %end
  1651  
  1652      ! Plant a Floating Point Reg <- Reg operation
  1653      ! Both register parameters are internal ID's that we
  1654      ! convert to stack offsets
  1655      %routine dumpfloprr(%integer opn, %integer reg1, %integer reg2)
  1656          %integer top
  1657  
  1658          top = fpustack + (FR0 - 1)
  1659  
  1660          %if reg2 # top %then abort("FPU Stack Address")
  1661  
  1662          %if opn < FCHS %start;	! two operands - will pop one
  1663              fpu stack = fpu stack - 1
  1664              %if opn = FCMP %then fpu stack = fpu stack - 1;   ! COMPP pops both registers
  1665              %if fpu stack < 0 %then abort("FPU Stack Underflow")
  1666          %finish
  1667  
  1668  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  1669          putbyte(flprefix(opn));
  1670          putbyte(flindex(opn)!(top - reg1))
  1671  
  1672          listpreamble;
  1673          printstring(flopname(opn))
  1674          space
  1675          printstring("ST(");
  1676          write(top-reg1, 1)
  1677          printstring("),ST")
  1678          newline
  1679          flushcode;
  1680      %end
  1681  
  1682      ! Plant a "special" floating point operation
  1683      %routine dumpflopspec(%integer opn)
  1684  
  1685          %if opn >= FLDZ %start;       ! load a constant
  1686              fpu stack = fpu stack + 1
  1687              %if fpu stack > 8 %then abort("FPU Stack Overflow")
  1688          %finish
  1689  
  1690  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  1691          putbyte(flprefix(opn));
  1692          putbyte(flindex(opn))
  1693  
  1694          listpreamble
  1695          printstring(flopname(opn))
  1696          newline
  1697          flushcode
  1698      %end
  1699  
  1700      %routine dumpjump(%integer opn, %integer labelid)
  1701          ! we put conventional assembler into the pipe for the listing
  1702          ! (with a zero jump offset) but then re-use the pipe for the
  1703          ! pseudo-code for the jump
  1704          putbyte(opvalue(opn));
  1705          putbyte(0);
  1706          %if opn = CALL %then putbyte(0);
  1707  
  1708          listpreamble;
  1709          printstring(opname(opn))
  1710          space
  1711          { JDM JDM }
  1712          %if (opn = CALL) %start
  1713              ! See if we can show the routine name
  1714              printstring("'".top_idname."' (INTERNAL ")
  1715              printsymbol('L');
  1716              write(labelid,1)
  1717              printstring(" )")
  1718          %else
  1719              printsymbol('L')
  1720              write(labelid,1)
  1721          %finish
  1722          { JDM JDM }
  1723          newline
  1724  
  1725          ClearObjectBuffer;		! zap the current contents of the pipe
  1726          %if (opn = JMP) %start
  1727  			putcodebyte(labelid & 255)
  1728  			putcodebyte(labelid >> 8)
  1729  			writeifrecord(IF JUMP, 2, objectbytes)
  1730  			ClearObjectBuffer;		! zap the current contents of the pipe
  1731          %finish %else %if (opn = CALL) %start
  1732  ! JDM replaced use of IF CALL command by IF REFLABEL command
  1733  !           ! Generated code using IF CALL ibj command
  1734  !           putcodebyte(labelid & 255)
  1735  !           putcodebyte(labelid >> 8)
  1736  !           writeifrecord(IF CALL, 2, objectbytes)
  1737  !           ClearObjectBuffer;     ! zap the current contents of the pipe
  1738  
  1739              ! JDM JDM Generated code using IF REFLABEL ibj command
  1740              ! plant the CALL code
  1741              putcodebyte( 16_E8 );   ! call with relative address
  1742              writeifrecord(IF OBJ, 1, objectbytes);
  1743              ClearObjectBuffer;      ! zap the current contents of the pipe
  1744              ! plant the relative address of the label
  1745              putcodebyte(labelid & 255)
  1746              putcodebyte(labelid >> 8)
  1747              putcodebyte(0); ! JDM set offset to zero
  1748              putcodebyte(0)
  1749              writeifrecord(IF REFLABEL, 4, objectbytes);
  1750              ClearObjectBuffer;      ! zap the current contents of the pipe
  1751          %finish %else %start
  1752              ! not an unconditional JMP or a CALL
  1753              ! assume it is a conditional JMP (i.e. JE,JNE, etc.)
  1754              putcodebyte(opn - JE)
  1755              putcodebyte(labelid & 255)
  1756              putcodebyte(labelid >> 8)
  1757              writeifrecord(IF JCOND, 3, objectbytes)
  1758              ClearObjectBuffer;      ! zap the current contents of the pipe
  1759          %finish
  1760  
  1761          ! finally, calls may trash registers...
  1762          %if opn = CALL %start
  1763              displayhint(BX) = 0
  1764              displayhint(SI) = 0
  1765              displayhint(DI) = 0
  1766          %finish
  1767      %end
  1768  
  1769      ! call the n'th external routine we've spec'ed
  1770      %routine dumpextcall(%integer labelid)
  1771  
  1772          displayhint(BX) = 0
  1773          displayhint(SI) = 0
  1774          displayhint(DI) = 0
  1775  
  1776          putbyte(opvalue(CALL))
  1777          flushcode;	! plant the "CALL" instruction
  1778          putbyte(labelid & 255)
  1779          putbyte(labelid >> 8)
  1780          listpreamble
  1781          ! JDM JDM attempt to show external routine name
  1782          printstring("CALL ")
  1783          %if (labelid <= lastperm) %start
  1784              ! This is an internal "perm" routine
  1785              ! So, show the name
  1786              printstring("'".permname(labelid)."'")
  1787          %else
  1788              ! this is an external routine
  1789              printstring("'".top_idname."'")
  1790          %finish
  1791          printstring(" (EXTERN ")
  1792          write(labelid, 1)
  1793          printstring(")")
  1794          newline
  1795          ! JDM JDM
  1796  
  1797          writeifrecord(IF REFEXT, wordsize, objectbytes);
  1798  !        writeifrecord(IF REFEXT, 2, objectbytes);
  1799          ClearObjectBuffer;	! zap the current contents of the pipe
  1800      %end
  1801  
  1802      %routine dumplabel(%integer labelid)
  1803  
  1804          select output(listout)
  1805          space; writehex(nextcad, 4); spaces(22);
  1806          printsymbol('L');
  1807          write(labelid, 1);
  1808          printstring("  EQU $")
  1809          newline
  1810  
  1811          ClearObjectBuffer;	! zap the current contents of the pipe
  1812  		putcodebyte(labelid & 255)
  1813  		putcodebyte(labelid >> 8)
  1814          writeifrecord(IF LABEL, 2, objectbytes);
  1815          ClearObjectBuffer;	! zap the current contents of the pipe
  1816  
  1817          displayhint(BX) = 0
  1818          displayhint(SI) = 0
  1819          displayhint(DI) = 0
  1820      %end
  1821  
  1822      %routine dumpstaticalloc(%integer which, level, %string(255)%name name)
  1823          %integer i, len
  1824          ! we pretend to dump "C8 00 00 lev  ENTER 0000,lev" but we actually plant a special pass 2 directive
  1825  
  1826          putbyte(16_C8)
  1827          putbyte(16_00)
  1828          putbyte(16_00)
  1829          putbyte(level)
  1830          listpreamble
  1831          printstring("ENTER 0000,"); write(level, 1)
  1832          newline
  1833  
  1834          ClearObjectBuffer;	! zap the current contents of the pipe
  1835  		putcodebyte(which & 255)
  1836  		putcodebyte(which >> 8)
  1837  		putcodebyte(level)
  1838  
  1839          ! we also pass the (truncated) name of the routine for pass3 diagnostic use
  1840  
  1841          len = length(name)
  1842          %if len > 16 %then len = 16
  1843          %for i=1,1,len %cycle
  1844              putcodebyte(charno(name,i))
  1845          %repeat
  1846          writeifrecord(IF FIXUP, len+3, objectbytes);
  1847          ClearObjectBuffer;	! zap the current contents of the pipe
  1848      %end
  1849  
  1850      ! Pass 3 goes back and plants the correct preamble code for
  1851      ! the static allocation based on this directive, and also fills
  1852      ! in the event trap block as appropriate
  1853      %routine dumpstaticfill(%integer which, size, events, evep, evfrom)
  1854  
  1855          ClearObjectBuffer;	! zap the current contents of the pipe
  1856          putcodebyte(which & 255);	putcodebyte(which >> 8);
  1857          putcodebyte(size & 255);	putcodebyte(size >> 8);
  1858          putcodebyte(events & 255);	putcodebyte(events >> 8);
  1859          putcodebyte(evep & 255);	putcodebyte(evep >> 8);
  1860          putcodebyte(evfrom & 255);	putcodebyte(evfrom >> 8);
  1861          writeifrecord(IF SETFIX, 10, objectbytes);
  1862          ClearObjectBuffer;	! zap the current contents of the pipe
  1863      %end
  1864  
  1865      ! dump words for the constant segment or the data segment
  1866      ! Adjusts CAD so that the diagnostic listing looks sensible
  1867      %routine dumpcdword(%integer word, %integer which)
  1868  
  1869          %integer tag, tmpcad, hi, lo
  1870          %owninteger cptr = 0
  1871          %owninteger dptr = 0
  1872          %owninteger sptr = 0
  1873  
  1874          tmpcad = next cad
  1875          %if which = 2 %start
  1876              tag = IF SWTWORD;
  1877              next cad = sptr; sptr = sptr + 2
  1878          %else
  1879              %if which = 1 %start
  1880                  tag = IF COTWORD;
  1881                  next cad = cptr; cptr = cptr + 2
  1882              %else
  1883                  tag = IF DATWORD;
  1884                  next cad = dptr; dptr = dptr + 2
  1885              %finish
  1886          %finish
  1887  
  1888          hi = word >> 8
  1889          lo = word & 255
  1890          putbyte(lo);
  1891          putbyte(hi);
  1892          listpreamble;
  1893          printstring("db ")
  1894          writehex(lo, 2); printsymbol(','); writehex(hi, 2);
  1895          printstring(" ; ")
  1896          %if lo > 32 %and lo < 127 %then printsymbol(lo) %else printsymbol('.')
  1897          %if hi > 32 %and hi < 127 %then printsymbol(hi) %else printsymbol('.')
  1898          newline
  1899          writeifrecord(tag, 2, objectbytes);
  1900          ClearObjectBuffer;	! clear the pipe
  1901          nextcad = tmp cad;	! restore the real CAD
  1902      %end
  1903  
  1904      ! tell the object file maker what source line we are on
  1905      %routine dumplinenumber(%integer line)
  1906  
  1907          %byteintegerarray buffer(0:1);
  1908  
  1909          buffer(0) = (line & 255);
  1910          buffer(1) = (line >> 8);
  1911          writeifrecord(IF LINE, 2, buffer);
  1912  
  1913      %end
  1914  
  1915      ! utility to copy an IMP string into a simple buffer to
  1916      ! pass to the IF Record routine
  1917      %routine str to xsym(%string(255)%name s)
  1918          %integer l
  1919  
  1920          l = length(s)
  1921          xlen = 0
  1922          %while xlen < l %cycle
  1923              x sym buff(xlen) = charno(s, xlen+1)
  1924              xlen = xlen + 1
  1925          %repeat
  1926      %end
  1927  
  1928      ! tell the object maker the source file name
  1929      %routine dumpsourcename(%string(255) filename)
  1930  
  1931          str to xsym(filename)
  1932          writeifrecord(IF SOURCE, xlen, x sym buff);
  1933  
  1934      %end
  1935  
  1936      ! Plant a request to the linker for the external name, and
  1937      ! return an index number to refer to it with in future
  1938      %integerfn externalref(%string(255) extname)
  1939          %owninteger nextextref=1
  1940  
  1941          str to xsym(extname)
  1942          writeifrecord(IF REQEXT, xlen, x sym buff);
  1943          nextextref = nextextref + 1
  1944          %result = nextextref - 1;
  1945      %end
  1946  
  1947      ! tell the linker about an external definition
  1948      %routine fill external(%integer seg, offset, %string(255) extname)
  1949  
  1950          str to xsym(extname)
  1951          %if seg = CODE %start
  1952              writeifrecord(IF DEFEXTCODE, xlen, x sym buff);
  1953          %else
  1954              writeifrecord(IF DEFEXTDATA, xlen, x sym buff);
  1955              ! er, this doesn't actually work yet!
  1956          %finish
  1957      %end
?OFFSET unused
  1958  
  1959      !------------------------------------------------------
  1960      ! Constant table utility routines
  1961      !
  1962      ! Rather than dump literal constants as they occur, we
  1963      ! collect them in a table.  Whenever the compiler wants
  1964      ! any kind of literal, we look to see if we already
  1965      ! have it.  Note this automatically solves re-use of
  1966      ! things like floating point constants, string newline,
  1967      ! and fixed array dope vectors.  When the table starts
  1968      ! to get fairly full, we flush it.  Obviously that means
  1969      ! in a large program we might not actually get full re-use
  1970      ! of constants after we've flushed, but the idea is sound.
  1971      !
  1972      ! For the convenience of the caller, several versions of
  1973      ! pretty much the same thing are provided.
  1974      !------------------------------------------------------
  1975      %constinteger cot size = 2000
  1976      %ownbyteintegerarray contable(0:cot size)
  1977      %owninteger cotp = 0
  1978      %owninteger cotoffset = 0;       ! updated on a flush
  1979  
  1980      %routine flushcot
  1981          %integer i
  1982  
  1983          ! We output a position hint to the diagnostic stream
  1984          ! Note that although this is intended to look like
  1985          ! 8086 assembly directives the real work is done by
  1986          ! pass 3 - this is only to guide the human reader as
  1987          ! to what is going on
  1988  
  1989          selectoutput(listout)
  1990          printstring("      _TEXT  ENDS"); newline;
  1991          printstring("      CONST  SEGMENT WORD PUBLIC 'CONST'"); newline;
  1992  
  1993          i = 0
  1994          %while i < cotp %cycle
  1995              dumpcdword((contable(i+1) << 8) ! contable(i), 1)
  1996              i = i + 2;
  1997          %repeat
  1998  
  1999          ! Update the pointers
  2000          cotp = 0
  2001          cotoffset = cotoffset + i
  2002  
  2003          ! and send another hint
  2004          selectoutput(listout)
  2005          printstring("      CONST  ENDS"); newline;
  2006          printstring("      _TEXT  SEGMENT WORD PUBLIC 'CODE'"); newline
  2007  
  2008      %end
  2009  
  2010      ! return the offset in the const segment of a byte
  2011      ! with value b
  2012      %integerfn getcotb(%byteinteger b)
  2013          %integer i
  2014  
  2015          i = 0
  2016          %while i < cotp %cycle
  2017              %if contable(i) = b %then %result = i + cotoffset
  2018              i = i + 1
  2019          %repeat
  2020  
  2021          ! value wasn't there
  2022          %if cotp = cotsize %then flushcot
  2023  
  2024          contable(cotp) = b
  2025          cotp = cotp + 1
  2026          %result = (cotp - 1) + cotoffset
  2027      %end
  2028  
  2029      ! return the offset in the const segment of a word
  2030      ! with value w
  2031      %integerfn getcotw(%integer w)
  2032          %integer i, cw
  2033  
  2034          i = 0
  2035          %while i < cotp-3 %cycle
  2036              cw = contable(i)!(contable(i+1)<<8)!(contable(i+2)<<16)!(contable(i+3)<<24)
  2037              %if cw = w %then %result = i + cotoffset
  2038              i = i + wordsize
  2039          %repeat
  2040  
  2041          ! value wasn't there - first make sure there is space
  2042          %if cotp > cotsize-wordsize %then flushcot
  2043  
  2044          ! now round off the COT
  2045          cotp = (cotp + align) & (\align)
  2046  
  2047          %for i=1,1,wordsize %cycle
  2048              contable(cotp) = w & 255
  2049              w = w >> 8
  2050              cotp = cotp + 1
  2051          %repeat
  2052  
  2053          %result = (cotp - wordsize) + cotoffset
  2054      %end
  2055  
  2056      ! return the offset in the const segment of double precision real number
  2057      %integerfn getcotdouble(%longreal double)
  2058          %integer i
  2059  
  2060          i = 0
  2061          %while i < cotp-7 %cycle
  2062              %if contable(i)   = byteinteger(addr(double))   %and %c
  2063+                 contable(i+1) = byteinteger(addr(double)+1) %and %c
  2064+                 contable(i+2) = byteinteger(addr(double)+2) %and %c
  2065+                 contable(i+3) = byteinteger(addr(double)+3) %and %c
  2066+                 contable(i+4) = byteinteger(addr(double)+4) %and %c
  2067+                 contable(i+5) = byteinteger(addr(double)+5) %and %c
  2068+                 contable(i+6) = byteinteger(addr(double)+6) %and %c
  2069+                 contable(i+7) = byteinteger(addr(double)+7) %then %result = i + cotoffset
  2070              i = i + 4
  2071          %repeat
  2072  
  2073          ! value wasn't there - first make sure there is space
  2074          %if cotp > cotsize-8 %then flushcot
  2075  
  2076          ! now round off the COT
  2077          cotp = (cotp + align) & (\align)
  2078  
  2079          %for i=0,1,7 %cycle
  2080              contable(cotp) = byteinteger(addr(double)+i)
  2081              cotp = cotp + 1
  2082          %repeat
  2083  
  2084          %result = (cotp - 8) + cotoffset
  2085      %end
  2086  
  2087      ! return the offset in the const segment of a quad word
  2088      ! with value q0:q1:q2:q3 (lo to hi)
  2089      %integerfn getcot4(%integer q0, q1, q2, q3)
  2090          %integer i, cw0, cw1, cw2, cw3
  2091  
  2092          i = 0
  2093          cw0 = contable(i)!(contable(i+1)<<8)!(contable(i+2)<<16)!(contable(i+3)<<24)
  2094          cw1 = contable(i+4)!(contable(i+5)<<8)!(contable(i+6)<<16)!(contable(i+7)<<24)
  2095          cw2 = contable(i+8)!(contable(i+9)<<8)!(contable(i+10)<<16)!(contable(i+11)<<24)
  2096          %while i < cotp-15 %cycle
  2097              cw3 = contable(i+12)!(contable(i+13)<<8)!(contable(i+14)<<16)!(contable(i+15)<<24)
  2098              %if cw0 = q0 %and cw1 = q1 %and cw2 = q2 %and cw3 = q3 %then %result = i + cotoffset
  2099              i = i + word size
  2100              cw0 = cw1
  2101              cw1 = cw2
  2102              cw2 = cw3
  2103          %repeat
  2104  
  2105          ! value wasn't there - first make sure there is space
  2106          %if cotp > cotsize-16 %then flushcot
  2107  
  2108          ! now round off the COT
  2109          cotp = (cotp + align) & (\align)
  2110  
  2111          %for i=1,1,wordsize %cycle
  2112              contable(cotp) = q0 & 255
  2113              q0 = q0 >> 8
  2114              cotp = cotp + 1
  2115          %repeat
  2116  
  2117          %for i=1,1,wordsize %cycle
  2118              contable(cotp) = q1 & 255
  2119              q1 = q1 >> 8
  2120              cotp = cotp + 1
  2121          %repeat
  2122  
  2123          %for i=1,1,wordsize %cycle
  2124              contable(cotp) = q2 & 255
  2125              q2 = q2 >> 8
  2126              cotp = cotp + 1
  2127          %repeat
  2128  
  2129          %for i=1,1,wordsize %cycle
  2130              contable(cotp) = q3 & 255
  2131              q3 = q3 >> 8
  2132              cotp = cotp + 1
  2133          %repeat
  2134  
  2135          %result = (cotp - 16) + cotoffset
  2136      %end
  2137  
  2138      %owninteger null string = -1
  2139  
  2140      ! get an index into the constant table for the string literal
  2141      ! in the array s
  2142      %integerfn getcots(%byteintegerarrayname b)
  2143          %integer i, first, slen, match;
  2144  
  2145  		slen = b(0)
  2146  
  2147          ! We optimise the Null String "" in comparisons, so we remember
  2148          ! the location here
  2149          %if slen = 0 %start
  2150              null string = getcotb(0)
  2151              %result = null string
  2152          %finish
  2153  
  2154          first = 0;           ! offset to search in contable
  2155  
  2156          %while first + slen < cotp %cycle;   ! so long as there are that many bytes left
  2157              match = 1
  2158  			! Simple check of string lengths
  2159              %if slen # contable(first) %start
  2160                  match = 0
  2161                  %exit
  2162              %finish
  2163  			! ok, so lengths match but do the contents
  2164              %for i = 1, 1, slen %cycle
  2165                  %if b(i) # contable(first + i) %start
  2166                      match = 0
  2167                      %exit
  2168                  %finish
  2169              %repeat
  2170              %if match = 1 %then %result = first + cotoffset
  2171              first = first + 1;               ! try the next solution
  2172          %repeat
  2173  
  2174          ! if we get here, it wasn't already in the constant table
  2175  		! Ok, so will we overflow the buffer
  2176          %if (cotp + slen + 1) >= cotsize %then flushcot
  2177  
  2178  		! dump the string length
  2179          first = cotp
  2180          contable(cotp) = slen
  2181          cotp = cotp + 1
  2182  		! Now, dump the string contents
  2183  		%for i = 1,1,slen %cycle
  2184              contable(cotp) = b(i)
  2185              cotp = cotp + 1
  2186          %repeat
  2187          %result = first + cotoffset
  2188      %end
  2189  
  2190      !------------------------------------------------------
  2191      ! Data segment utility routines
  2192      !
  2193      ! Unlike constants, we can't re-use data segment items,
  2194      ! which makes this much simpler.  We still accumulate
  2195      ! the bytes in a table because (1) we can make life
  2196      ! more efficient for Pass 3 that way and (2) by collecting
  2197      ! the bytes together we can produce more convincing debug
  2198      ! code listings, especially for programs that don't need
  2199      ! to flush the table in the middle of the code.
  2200      ! Note that because data segment offsets are used directly
  2201      ! as variable displacements, our pointer DATATP doesn't
  2202      ! wrap like the COTP does, and instead we subtract the
  2203      ! offset before we use it...
  2204      !------------------------------------------------------
  2205      %constinteger datat limit = 1999;   ! Size in bytes of data segment table
  2206      %byteintegerarray datat(0:datat limit)
  2207      %owninteger datatp = 0;             ! pointer to next data segment byte
  2208      %owninteger datat offset = 0;       ! updated on a flush
  2209  
  2210      ! Flush the accumulated data table
  2211      %routine flush data
  2212          %integer i, limit
  2213  
  2214          ! We output a position hint to the diagnostic stream
  2215  
  2216          selectoutput(listout)
  2217          printstring("            ENDS"); newline
  2218          printstring("      DATA  SEGMENT WORD PUBLIC 'DATA'"); newline
  2219  
  2220          i = 0
  2221          limit = datatp - datat offset
  2222          %while i < limit %cycle
  2223              dumpcdword((datat(i+1) << 8) ! datat(i), 0)
  2224              i = i + 2;
  2225          %repeat
  2226  
  2227          datat offset = datat p
  2228  
  2229          ! and send another hint
  2230          selectoutput(listout)
  2231          printstring("      DATA    ENDS"); newline
  2232      %end
  2233  
  2234      !                                                            >> GBYTE <<
  2235      ! Simple byte in data segment
  2236      %routine  gbyte(%integer  n)
  2237  
  2238          flush data %if (datatp - datat offset) > datat limit   
  2239          datat(datatp - datat offset) = n & 255;
  2240          datatp = datatp + 1
  2241      %end
  2242  
  2243      !                                                            >> GPUT <<
  2244      ! Put a word into data segment
  2245      %routine  gput(%integer  n)
  2246          %integer i
  2247  
  2248          %for i=1,1,wordsize %cycle
  2249              gbyte(n)
  2250              n = n >> 8;
  2251          %repeat
  2252      %end
  2253  
  2254      !                                                             >> GFIX <<
  2255      ! round off the datasegment pointer for alignment
  2256      %routine  gfix(%integer align)
  2257          gbyte(0) %while datatp & align # 0
  2258      %end
  2259  
  2260      !-----------------------------------------------------
  2261      ! The last table we collect as we go along is the switch
  2262      ! table.  We don't provide individual routines to fill
  2263      ! it in, but for tidyness we provide this routine to send
  2264      ! the contents to pass 3
  2265  
  2266      %routine flush switch
  2267          %integer i
  2268  
  2269          select output(listout)
  2270          printstring("              ENDS"); newline
  2271          printstring("      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'"); newline
  2272          i = 0
  2273          %while i < swtp %cycle
  2274              dumpcdword(swtab(i), 2)
  2275              i = i + 1
  2276          %repeat
  2277  
  2278          ! and send another hint
  2279          selectoutput(listout)
  2280          printstring("      _SWTAB   ENDS"); newline
  2281      %end
  2282  
  2283      !-------------------------------------------------------------
  2284      ! Print the source code lines up to the indicated line
  2285      ! number - these will interleave with the diagnostic assembly
  2286      ! output
  2287      %owninteger echoline = 0
  2288  
  2289      %routine echo source line
  2290          %integer ch
  2291          %owninteger source eof = 0
  2292  
  2293          echoline = echoline + 1;            ! update the count even if there's no input
  2294  
  2295          %if source eof # 0 %then %return;   ! silently ignore lack of source file
  2296  
  2297          select input(source)
  2298          select output(listout)
  2299          %cycle
  2300              readsymbol(ch)
  2301              printsymbol(ch)
  2302              %exit %if ch = 10 %or ch < 0
  2303          %repeat
  2304  
  2305          %if ch < 0 %then source eof = 1
  2306  
  2307          select input(icode)
  2308          select output(objout)
  2309      %end
  2310  
  2311      !-----------------------------------------------------------
  2312      ! General descriptor and register manipulation routines
  2313      !-----------------------------------------------------------
  2314  
  2315      !                                                         >> FLOATING <<
  2316      %integerfn  floating(%record(stackfm)%name v)
  2317          ! check descriptor for floating point quantity
  2318          %result = 1 %if v_type = real %or v_type = lreal
  2319          %result = 0
  2320      %end
  2321  
  2322      !                                                             >> ZERO <<
  2323      %integerfn  zero(%record(stackfm)%name  v)
  2324          ! CHECK DESCRIPTOR FOR (INTEGER) ZERO
  2325          %result = 0 %if v_disp # 0 %or v_base # 0 %or (v_form # constant %and v_form # AV in S)
  2326          %result = 1
  2327      %end
  2328  
  2329      !                                                            >> CONST <<
  2330      %integerfn  const(%record(stackfm)%name  v)
  2331          ! CHECK DESCRIPTOR FOR CONSTANT (INTEGER) VALUE
  2332          %result = 0 %unless v_form = constant
  2333          %result = 0 %if v_type > byte
  2334          %result = 1
  2335      %end
  2336  
  2337      %integerfn Min Record Size(%record(stackfm)%name A, B)
  2338          %integer N, M
  2339          N = A_format;  N = var(N)_size & 16_7FFF %if N # 0
  2340          M = B_format;  M = var(M)_size & 16_7FFF %if M # 0
  2341          N = M %if N = 0 %or (M # 0 %and M < N)
  2342          %result = N %if N > 0
  2343          Abort("Min Rec Size")
  2344      %end
  2345  
  2346      !                                                             >> MULSHIFT <<
  2347      %integerfn mulshift(%integer n)
  2348          %integer shift, ref
  2349          ref = 1
  2350          %for shift = 1, 1, 14 %cycle
  2351              ref = ref<<1
  2352              %if ref >= n %start
  2353                  %if ref = n %then %result = shift %else %result = -1
  2354              %finish
  2355          %repeat
  2356          %result = -1
  2357      %end
  2358  
  2359      !                                                             >> SAME <<
  2360      %integerfn  same(%record(stackfm)%name  v,w)
  2361          ! Test whether or not V and W describe the same object.
  2362          %result = 0 %if v_disp # w_disp %or v_base # w_base
  2363          %result = 0 %if v_type # w_type %or v_form # w_form
  2364          %result = 0 %if v_extra # w_extra %or v_scope # w_scope
  2365          %result = 1
  2366      %end
  2367  
  2368  
  2369      ! grab a slab of working store in the local stack
  2370      %integerfn getwork(%integer size)
  2371          %integer cell;
  2372  
  2373          cell = worklist(level);
  2374          %while cell # 0 %cycle
  2375              %if gp tags(cell)_info = size %and gp tags(cell)_flags = 0 %start; ! suitable candidate?
  2376                  gp tags(cell)_flags = 1;		! mark it as in use
  2377                  %result = gp tags(cell)_addr;
  2378              %finish
  2379              cell = gp tags(cell)_link;
  2380          %repeat
  2381  
  2382          ! no space available already - make more
  2383          cell = get gp tag
  2384          frame = (frame - size) & (\align);   ! make them all even boundaries
  2385          gp tags(cell)_addr = frame;
  2386          gp tags(cell)_info = size;
  2387          gp tags(cell)_link = worklist(level);
  2388          worklist(level) = cell;
  2389          gp tags(cell)_flags = 1;		! in use
  2390          %result = frame;
  2391      %end
  2392  
  2393      ! Return a slab of working store to the free pool.  Note that
  2394      ! ReturnWork is cautious about what it accepts - it only takes
  2395      ! in items it has previously given out, so we can call it
  2396      ! fairly liberally with any old rubbish and it will do the
  2397      ! right thing
  2398      %routine Return Work(%integer addr)
  2399          %integer cell
  2400  
  2401          cell = worklist(level);
  2402          %while cell # 0 %cycle
  2403              %if gp tags(cell)_addr = addr %start
  2404                  %if gp tags(cell)_flags = 0 %then abort("Return Work")
  2405                  gp tags(cell)_flags = 0;		! mark it as free
  2406                  %return
  2407              %finish
  2408              cell = gp tags(cell)_link;
  2409          %repeat
  2410  
  2411          ! Here, work area was not found - it probably wasn't a work area!
  2412      %end
  2413  
  2414      ! Check to see if a variable is in a work list assigned block.  Used
  2415      ! in string expression compilation to avoid un-necessary copying, hence
  2416      ! only marked true for 256 byte chunks
  2417      %integerfn Is Work(%record(stackfm)%name v)
  2418          %integer cell
  2419  
  2420          %if v_base # BP %or v_disp >= 0 %or v_scope # 0 %or v_form # v in s %then %result = 0
  2421  
  2422          cell = worklist(level);
  2423          %while cell # 0 %cycle
  2424              %if gp tags(cell)_addr = v_disp %start
  2425                  %if gp tags(cell)_flags = 0 %then abort("Is Work")
  2426                  %if gp tags(cell)_info # 256 %then %result = 0
  2427                  %result = 1
  2428              %finish
  2429              cell = gp tags(cell)_link;
  2430          %repeat
  2431  
  2432          %result = 0
  2433      %end
  2434  
  2435      !                                                          >> RELEASE <<
  2436      %routine  release(%integer  reg)
  2437          ! Hazard the value in a register
  2438          !   abort("Release bad register") %if reg > fr7
  2439          %return %if reg = 0 %or reg > fr7 %or activity(reg) < 0;  ! LOCKED
  2440          activity(reg) = activity(reg)-1
  2441          abort("Release inactive") %if activity(reg) < 0
  2442          claimed = claimed - 1
  2443      %end
  2444  
  2445      !                                                            >> CLAIM <<
  2446      %routine  claim(%integer  reg)
  2447          ! Cherish the value in a register
  2448          abort("Claim bad register") %if reg > fr7
  2449          %return %if reg = 0 %or activity(reg) < 0
  2450          activity(reg) = activity(reg)+1
  2451          claimed = claimed+1
  2452      %end
  2453  
  2454      !                                                           >> HAZARD <<
  2455      ! Protect any value in register REG by storing in a temporary.
  2456      %routine  hazard(%integer  reg)
  2457          %integer  i, n, t, type
  2458  
  2459          %routine  mod(%record(stackfm)%name  v)
  2460              %switch  sw(0:a in rec)
  2461              v_base = BP
  2462              n = n-1
  2463              -> sw(v_form)
  2464  sw(a in rec):
  2465  sw(av in rec):
  2466  sw(v in rec):
  2467  sw(constant):
  2468              abort("Mod")
  2469  sw(v in s):
  2470              %if v_disp = 0 %and v_scope = 0 %start
  2471                  v_disp = t
  2472                  v_form = a in s
  2473              %else
  2474                  !  change (X in S) to (X in REC)
  2475                  v_form = v_form + 3
  2476                  v_extra = t
  2477              %finish; -> out1
  2478  sw(a in s):
  2479  sw(av in s):
  2480              v_form = v_form + 3
  2481              v_extra = t; -> out1;    !  change (X in S) to (X in REC)
  2482  sw(v in r):
  2483              v_form = v in s
  2484              v_disp = t
  2485              v_type = type; -> out1
  2486  out1:
  2487          %end
  2488  
  2489          n = activity(reg);  %return %if n <= 0;  ! NOT IN USE OR CLAIMED
  2490          claimed = claimed - n
  2491          activity(reg) = 0
  2492          %if reg >= fr0 %start
  2493              ! Note that the FPU can only save the top of the stack.
  2494              ! If we need to save something lower down, we need to pop
  2495              ! the things above me first...
  2496              %if reg - FR0 >= FPU Stack %then hazard(reg+1); ! and recurse as required
  2497              type = lreal
  2498              t = getwork(8)
  2499              dumpfloprm(FSTQ, BP, t, 0)
  2500          %else
  2501              type = integer
  2502              t = getwork(word size)
  2503              dumpmr(MOV, BP,t, 0, reg)
  2504          %finish
  2505          %for i = 1, 1, stp %cycle
  2506              mod(stack(i)) %if stack(i)_base = reg
  2507          %repeat
  2508          abort("Usage Outstanding") %if n # 0;      ! USE STILL OUTSTANDING
  2509      %end
  2510  
  2511      !                                                               >> HAZARD ALL <<
  2512      %routine  hazard all
  2513          %integer  j
  2514  
  2515          %if claimed # 0 %start;            ! at least one register claimed
  2516              hazard(j) %for j = AX,1,FR7
  2517          %finish
  2518      %end
  2519  
  2520      !                                                          >> GP REG <<
  2521      ! Get a general (integer) register
  2522      ! Note that registers AX, CX, DX, BX are, in order
  2523      ! numbers 1, 2, 3 and 4 (which is convenient)
  2524      %integerfn  gpreg
  2525          %integer  r
  2526  
  2527          ! look for an empty one
  2528          %for r = AX,1,BX %cycle
  2529              %result = r %if activity(r) = 0
  2530          %repeat
  2531  
  2532          ! look for an unlocked one
  2533          %for r = AX,1,BX %cycle
  2534              %if activity(r) > 0 %start
  2535                  hazard(r)
  2536                  %result = r
  2537              %finish
  2538          %repeat
  2539  
  2540          abort("Get Reg")
  2541      %end
  2542  
  2543      !                                                          >> PT REG <<
  2544      %integerfn  pt reg
  2545          ! Get a register we can use as a pointer.  We deliberately rotate
  2546          ! around the candidates to make re-use more likely
  2547          %constbyteintegerarray  pt pref(0:2) =
  2548+            7,  8,  4
  2549          ! SI, DI, BX
  2550          %owninteger next = 0
  2551          %integer  r,j
  2552  
  2553          ! look for an empty one
  2554          %for j = 1,1,3 %cycle
  2555              r = pt pref(next)
  2556              next = next+1; next = 0 %if next = 3
  2557              %result = r %if activity(r) = 0
  2558          %repeat
  2559  
  2560          ! look for an unlocked one
  2561          %for j = 1,1,3 %cycle
  2562              r = pt pref(j)
  2563              %if activity(r) > 0 %start
  2564                  hazard(r)
  2565                  %result = r
  2566              %finish
  2567          %repeat
  2568  
  2569          abort("Get PT Reg")
  2570      %end
  2571  
  2572      !                                                          >> GET DISPLAY <<
  2573      ! return the register to use to access display level <n>
  2574      %integerfn getdisplay(%integer l)
  2575          %integer r, lev
  2576  
  2577          lev = l & 15;                  ! get rid of any relocation info
  2578          %if lev = 0 %then %result = l; ! global
  2579          %if lev = level %then %result = BP; ! local
  2580  
  2581          ! We now try the 3 pointer register - they are not contiguously
  2582          ! numbered, which is why this is unrolled!
  2583          %if displayhint(BX) = lev %then %result = BX
  2584          %if displayhint(SI) = lev %then %result = SI
  2585          %if displayhint(DI) = lev %then %result = DI
  2586  
  2587          r = pt reg
  2588          dumprm(MOV, r, BP, -(lev * word size), 0 ); ! displays are first words in frame
  2589          displayhint(r) = lev
  2590          %result = r
  2591      %end
  2592  
  2593      !                                                          >> SET DOPE VECTOR <<
  2594      ! Plants a dope vector for a 1-D constant bound array (usually
  2595      ! OWN or CONST arrays) in the CONST segment, returns the offset
  2596      ! Note that it also modifies the vlb and vub variables - after
  2597      ! the call, VLB contains the byte offset for the first member
  2598      ! and VUB contains the size to allocate for the array in bytes.
  2599      %integerfn  set dope vector
  2600          %integer  t, dv
  2601  
  2602          t = vub-vlb+1
  2603          dv = getcot4(1, vlb, vub, data size)
  2604          vub = t*data size;  vlb = vlb*data size
  2605          %result = dv
  2606      %end
  2607  
  2608      !                                                          >> PERM <<
  2609      ! calls a PERM and adjusts the stack by SPACE words afterwards
  2610      %routine  perm(%integer  n, space)
  2611          ! PERM routines are written in MS C, and they preserve SI and DI,
  2612          ! but trash the general purpose registers
  2613          hazard(AX)
  2614          hazard(CX)
  2615          hazard(DX)
  2616          hazard(BX)
  2617          ! JDM perm routines now implemented as IMP routines
  2618          ! so be more careful and hazard the SI,DI registers as well
  2619          hazard(SI)
  2620          hazard(DI)
  2621          dumpextcall(n)
  2622          %if space # 0 %then dumpri( ADD, SP, space * word size)
  2623      %end
  2624  
  2625      !                                                          >> ASSEMBLE <<
  2626      ! AMODE:
  2627      !  -3: initial call
  2628      !  -2: alternate record format
  2629      !  -1: record format
  2630      !   0: begin block
  2631      !   1: procedure
  2632      !   2: %spec
  2633      %routine Assemble(%integer  amode, labs, names)
  2634          %switch c(33:127)
  2635          %record(varfm)%name   v;       ! General purpose pointer
  2636          %record(varfm)%name   procvar; ! Var of the current procedure we're compiling
  2637          %record(varfm)%name   ap;      ! Actual parameter ptr, used to copy parms to parm area
  2638          %record(varfm)%name   fp;      ! formal parameter ptr, used to copy parms to parm area
  2639          %record(stackfm)%name lhs;     ! General stack pointer
  2640          %record(stackfm)%name rhs;     ! General stack pointers
  2641          %integer max frame;	           ! Used for alternate records to find the largest alternate
  2642          %integer first name;           ! First descriptor at this level
  2643          %integer staticalloc;          ! Tag used by pass 3 to fix up this level's stack allocation
  2644          %integer skipproc, lastskip;   ! Used to jump around routines
  2645          %integer events, evep, evfrom; ! Event info (mask, entry point, block start)
  2646          %integer First label;          ! First label at this level
  2647          %integer old frame;            ! Previous level's static allocation
  2648          %integer j, t
  2649          %integer dv
  2650  
  2651          %routinespec   compile to string(%record(stackfm)%name v)
  2652          %routinespec   loadreg(%record(stackfm)%name  v, %integer  reg);    ! JDM change name from load()
  2653          %routinespec   storereg(%record(stackfm)%name  v, %integer  reg);   ! JDM new code
  2654          %routinespec   assign(%integer  assop)
  2655          %routinespec   array ref(%integer  mode)
  2656          %routinespec   Operation(%integer n)
  2657          %routinespec   compare(%record(stackfm)%name  l,r)
  2658          %routinespec   test zero(%record(stackfm)%name v)
  2659          %integerfnspec new tag
  2660  
  2661          ! Actual code for Assemble is down around label NEXT
  2662  
  2663  		! The following functions "parse" the parameters attached to an iCode instruction
  2664  		! It is intended that these functions are the only places where the iCode stream is read
  2665  		!                                                      >> READ TAG, and COMMA, INTEGER, REAL <<
  2666  		%integerfn  ReadTag
  2667  			%integer s1, s2
  2668  			s1 = Pending
  2669  			readsymbol(s2)
  2670  			readsymbol(Pending)
  2671  			%result = s1<<8!s2
  2672  		%end
  2673  
  2674  		%integerfn  ReadTagComma
  2675  			%integer t
  2676  			t = ReadTag
  2677  			readsymbol(Pending)
  2678  			%result = t
  2679  		%end
  2680  
  2681  		%integerfn  ReadInteger
  2682  			%integer s1, s2, s3, s4
  2683  			s1 = Pending
  2684  			readsymbol(s2)
  2685  			readsymbol(s3)
  2686  			readsymbol(s4)
  2687  			readsymbol(Pending)
  2688  			%result = (s1<<24)!(s2<<16)!(s3<<8)!s4
  2689  		%end
  2690  
  2691  		%integerfn ReadByte
  2692  			%integer s1
  2693  			s1 = Pending
  2694  			readsymbol(Pending)
  2695  			%result = s1
  2696  		%end
  2697  
  2698  		!                                                      >> READ REAL <<
  2699  		! Read a floating point literal.  Pass 1 treats these as strings
  2700  		! and leaves it up to us to make a floating point number out of it
  2701  		! We therefore expect [COUNT]NNN.NNN@NN
  2702  		%longrealfn  ReadReal
  2703  			%integer n
  2704  			%longreal p, r
  2705  			n = ReadTagComma;	! char count, skip comma
  2706  
  2707  			r = 0
  2708  			! Start with the bit ahead of the decimal point
  2709  			%cycle
  2710  				sym = Pending;  read symbol(Pending)
  2711  				%exit %if sym = '.'
  2712  				n = n-1
  2713  				-> power %if sym = '@'
  2714  				r = r*10+(sym-'0')
  2715  				-> SIGN %if n = 0
  2716  			%repeat
  2717  			p = 1
  2718  			%cycle
  2719  				n = n-1;  -> SIGN %if n = 0
  2720  				sym = Pending;  read symbol(Pending)
  2721  				-> POWER %if sym = '@'
  2722  				p = p/10
  2723  				r = r + (sym-'0')*p
  2724  			%repeat
  2725  
  2726  POWER:
  2727  			n = ReadTag
  2728              ! Tag is unsigned 16-bit integer (0..65535)
  2729              ! but is read into a 32-bit signed integer
  2730              ! and so 0 < n < 65535
  2731              ! BUT - tag is to be regarded as a 16-bit signed integer
  2732              ! So 0 < n < 32768 is to be regarded as a positive integer
  2733              ! and 32767 < n < 65536 is a negative integer
  2734              ! n     => correct n
  2735              ! 65536 =>  0
  2736              ! 65535 => -1      (65536 - n)
  2737              ! 65534 => -2      (65536 - n)
  2738              ! ..
  2739              ! 32768 => -32768  (65536 - n)
  2740  
  2741              ! Now to tweak the floating point value. This method is
  2742  			! somewhat clunky so that we can be portable to a system that
  2743  			! doesn't do exponents
  2744  
  2745              ! This version of the pass2 code generator targets the 8087
  2746              ! and later versions as the numeric processor for floating
  2747              ! point arithmetic
  2748              ! e.g. double real (== %longreal)
  2749              ! Double real uses an 11-bit exponent so we should ensure
  2750              ! that the tag represents an exponent in the range
  2751              !             -1023 <= exp <= 1023
  2752              ! -1024 is omitted to ensure no overflow for reciprocals
  2753              ! The exponent however, has a bias of 1023 so the actual
  2754              ! 8087 exponent is in the range 0 <= exp <= 2046
  2755  
  2756              ! Currently don't bother to check that the exponent is in
  2757              ! the range -1023 < exp < 1023
  2758              %if n # 0 %start
  2759                  ! ok, non-zero exponent
  2760                  %if 0 < n < 32768 %start
  2761                      ! positive exponent
  2762                      %while n > 0 %cycle
  2763                          r = r * 10
  2764                          n = n - 1
  2765                      %repeat
  2766                  %else
  2767                      ! a negative exponent
  2768                      ! So, convert to negative value
  2769                      n = n - 65536
  2770  
  2771                      ! Now, attempt to update the float value
  2772                      %while n < 0 %cycle
  2773                          r = r / 10
  2774                          n = n + 1
  2775                      %repeat
  2776                  %finish
  2777              %finish
  2778  SIGN:
  2779              ! sign of whole value
  2780  			%if Pending = 'U' %start
  2781  				read symbol(Pending)
  2782  				r = -r
  2783  			%finish
  2784  
  2785  			%result = r
  2786  		%end
  2787  
  2788  		%string(255)%function ReadString
  2789  			%integer J, Sym, Limit
  2790  			%string(255) s
  2791  
  2792  			Limit = Size of(s)-1
  2793  			s = ""
  2794  			%for J = Pending, -1,1 %cycle
  2795  				Readsymbol(Sym)
  2796  				s = s.Tostring(Sym) %if Length(s) < Limit
  2797  			%repeat
  2798  			Readsymbol(Pending)
  2799  			
  2800  			%result = s
  2801  		%end
  2802  
  2803  		%string(255)%function Get Ascii( %integer terminator)
  2804  			%string(255) a
  2805  			%integer Sym
  2806  			a = ""
  2807  			%cycle
  2808  				sym = Pending;  read symbol(Pending);  %exit %if sym = terminator
  2809  				%if length( a ) # 255 %start
  2810  					a = a.to string(sym)
  2811  				%finish
  2812  			%repeat
  2813  			%result = a
  2814  		%end
  2815  		! End of parsing routines
  2816  
  2817          !                                              >> DEFINE VAR <<
  2818          %routine  Define Var( %integer decl, %string(255) internal id, %integer tf, size, scope )
  2819              %integer  type, form, format, s, new, round, dimension
  2820              %integer  dv;              ! dope vector offset
  2821              %owninteger  prim no = 0
  2822  
  2823              new = 0
  2824              round = align
  2825  
  2826              ! Get the var index
  2827              %if decl = 0 %start
  2828                  ! RECORD FORMAT ELEMENT NAME
  2829                  parms = parms-1
  2830                  abort("Def Var Parms") %if parms <= names
  2831                  decvar == var(parms)
  2832                  decvar = 0
  2833              %else
  2834                  abort("Def Var Names (decl=".itos(decl,0)." parms=".itos(parms,0).")") %if decl >= parms
  2835                  decvar == var(decl)
  2836                  %if decl > names %start
  2837                      names = decl
  2838                      new = 1
  2839                      decvar = 0
  2840                  %finish
  2841              %finish
  2842  
  2843              ! Now parse the type and form word
  2844              type = tf>>4
  2845              form = tf&15
  2846  
  2847              ! Map external type numbers into internal equivalents,
  2848              ! and adjust for short/byte/long things
  2849              %if (type = integer) %and (size # 1) %start
  2850                  ! INTEGER
  2851                  type = byte  %and round = 0 %if size = 2
  2852                  size = vsize(type)
  2853              %finish %else %if (type = real) %start
  2854                  ! REAL
  2855                  type = lreal %if size = 4;             ! LONG REAL
  2856                  size = vsize(type)
  2857              %finish %else %if (type = record) %start
  2858                  ! record
  2859                  format = size
  2860                  decvar_format = format
  2861                  size = var(format)_size %if format <= names
  2862              %finish %else %if (type = string) %start
  2863                  ! string
  2864                  round = 0
  2865                  decvar_size = size
  2866                  size = size + 1
  2867              %else
  2868                  size = vsize(type)
  2869              %finish
  2870  
  2871              ! JDM JDM remember the variable name
  2872              ! Needed should an embedded code fragment refer to an IMP variable
  2873              var(decl)_idname = internal id
  2874  
  2875              decvar_size = size %if type # string
  2876              decvar_type = type
  2877              decvar_form = form
  2878  
  2879              ! Now analyse the Scope word
  2880              spec = (scope>>3)&1
  2881              dimension = (scope>>8)&255
  2882              otype = scope&7
  2883  
  2884              %if (otype # 0) %start
  2885                  ! Set external linkage name if appropriate
  2886                  %if (otype >= external) %start
  2887                      %if length(alias) # 0 %start
  2888                          external id = alias
  2889                      %finish %else %if (otype = system) %start
  2890                          external id = system prefix.internal id
  2891                      %else
  2892                          external id = "_".internal id
  2893                      %finish
  2894                      otype = external %if otype <= dynamic
  2895                      ! external, system, dynamic
  2896                  %finish
  2897              %finish
  2898              alias = ""
  2899  
  2900  			! JDM: Ensure the external displacement is zero
  2901  			decvar_extdisp = 0
  2902  
  2903              %if (switch < form) %and (form < array) %start
  2904                  ! PROCEDURE
  2905                  block type = 1 + spec;             ! 1 for normal proc, 2 for spec
  2906                  %if (otype # 0) %and (spec # 0) %start
  2907                      ! external spec
  2908                      %if otype = primrt %start
  2909                          primno = primno + 1
  2910                          decvar_level = 128
  2911                          decvar_disp = prim no
  2912                          %return
  2913                      %finish
  2914                      decvar_disp = externalref(external id)
  2915  					decvar_extdisp = decvar_disp;		! JDM: Remember the base external displacement
  2916                      decvar_level = 0
  2917                      decvar_scope = EXT
  2918                      %return
  2919                  %finish
  2920  
  2921                  %if (in params = 0) %start
  2922                      ! NOT A PARAMETER
  2923                      potype = otype
  2924                      %if new # 0 %start
  2925                          ! NEW NAME
  2926                          decvar_disp = new tag
  2927                          ! Procedure ID
  2928                      %finish
  2929                      block name = internal id %if spec = 0
  2930                      %return
  2931                  %finish
  2932  
  2933                  otype = 0
  2934                  size = word size
  2935                  data size = word size
  2936                  ! procedure parameter
  2937  
  2938              %else
  2939                  ! This is not a procedure declaration
  2940                  data size = size
  2941                  %if (form # simple) %start
  2942                      Round = Align
  2943                      %if (type = general) %start
  2944                          ! General %name
  2945                          decvar_extra = in params;          ! FOR LABELS
  2946                          size = word size * 2
  2947                      %finish %else %if (form = array) %or (form = name array) %start
  2948                          ! We will fill in dimensions and allocate space when
  2949                          ! we are told the bounds later
  2950                          size = 0
  2951                          data size = word size %if (form = name array)
  2952                      %finish %else %if (form = array name) %or (form = name array name) %start
  2953                          decvar_dim = dimension
  2954                          size = word size * 2
  2955                          round = align;   ! array header
  2956                      %else
  2957                          size = word size;                       ! integer (etc) %name
  2958                      %finish
  2959                  %finish
  2960              %finish
  2961  
  2962              ! Now deal with OWN (or const/extern/etc) data items
  2963              %if (otype # 0) %start
  2964                  ! OWN DATA
  2965                  %if (otype = con) %start
  2966                      ! CONST INTEGER ETC.
  2967                      data size = 0 %if (type = string) %and (form = simple);    ! use actual size for plain strings
  2968                      %if (form = name) %or (form = arrayname) %or (form = namearrayname) %start
  2969                          otype = 0;        ! Treat as special later
  2970                      %finish
  2971                  %else
  2972                      ! OWN, not CONST
  2973                      gfix(round);         ! so make it even if needed
  2974                  %finish
  2975                  ! set globals used by our data collection utilities
  2976                  own type = type
  2977                  own form = form
  2978                  own type = integer %and data size = word size %if form = 2; ! %name's are really integers
  2979  
  2980                  %if (spec = 0) %start
  2981                      %if (form = array) %or (form = name array) %start
  2982                          gfix(align)
  2983                          dv = set dope vector;      ! N.B.  changes vlb, vub
  2984                          ! We treat OWN and CONST arrays identically - both are in data segment
  2985                          gfix(align)
  2986                          decvar_disp = datatp - vlb;
  2987                          decvar_level = 0
  2988                          decvar_scope = DATA
  2989                          decvar_pbase = dv;                  ! save the dope vector pointer here
  2990                          decvar_dim = 1;                     ! own arrays are always 1-D
  2991                      %finish
  2992                      fill external(DATA, decvar_disp, external id) %if otype = external
  2993                  %else
  2994                      decvar_level = 0
  2995                      decvar_scope = EXT
  2996                      decvar_disp = external ref(external id)
  2997  					! JDM: We have a reference to external data so note the external ref id
  2998  					!      inside the _extdisp field
  2999  					!      _extdisp will NEVER be modified unlike _disp
  3000  					!      Eventually it will be used when generating ABSEXT ibj records
  3001                      !      The difference between _disp and _extdisp represents the offset
  3002                      !      from the location specified by _disp
  3003                      !      offset == _extdisp - _disp
  3004                      decvar_extdisp = decvar_disp
  3005                  %finish
  3006              %finish %else %if (form = label) %start
  3007                  !%label
  3008                  decvar_disp = new tag
  3009              %finish %else %if (form = switch) %start
  3010                  size = vub - vlb
  3011                  %if swtp + size > Max Switch %then abort("Switch Table Full")
  3012                  decvar_scope = SWT
  3013                  decvar_disp = swtp - vlb
  3014                  decvar_extra = set dope vector
  3015                  %for s = swtp, 1, swtp + size %cycle
  3016                      swtab(s) = 0;     ! should really deal with undefined switch entries
  3017                  %repeat
  3018                  swtp = swtp + size + 1
  3019              %finish %else %if (form = record format) %start
  3020                  %if (in params # 0) %start
  3021                      frame = decvar_size %if decvar_size > frame
  3022                  %else
  3023                      block type = -1;  spec = -1
  3024                  %finish
  3025              %finish %else %start
  3026                  ! Here we've got an ordinary local variable, parameter or record entry
  3027                  decvar_level = level
  3028                  %if (in params = 0) %start
  3029                      ! local variable
  3030                      frame = (frame - size) & (\round)
  3031                      decvar_disp = frame
  3032                  %finish %else %if (block type > 0) %start
  3033                      ! procedure parameters
  3034                      frame = (frame + size + align) & (\align);	! parameters are always word aligned
  3035                      decvar_disp = frame;						! offset will be adjusted at '}'
  3036                  %finish %else %start
  3037                      ! records
  3038                      frame = (frame + round) & (\round)
  3039                      decvar_disp = frame
  3040                      frame = frame + size
  3041                      decvar_level = 0;          ! no base register
  3042                  %finish
  3043              %finish
  3044          %end; !    Define Var
  3045  
  3046          !---------------------------------------------------------------------
  3047          ! Stack manipulation routines
  3048          !---------------------------------------------------------------------
  3049          !                                                      >> POP STACK <<
  3050          ! Pop the top of the stack
  3051          %routine  Pop Stack
  3052              %if stp = 0 %then abort("Pop")
  3053              monitor(top, "Pop") %if diagnose&1 # 0
  3054              stp = stp - 1
  3055              %if stp # 0 %then top == stack(stp) %else top == null
  3056          %end
  3057  
  3058          !                                                             >> POP REL <<
  3059          ! Pop the top of the stack, and release its' register
  3060          %routine  pop rel
  3061              release(top_base)
  3062              pop stack
  3063          %end
  3064  
  3065          %constbyteintegerarray fmap(0:15) =
  3066+                  0, v in s,    a in s, pgm label, recordformat,         0,        switch,       0,
  3067+         {     void, simple,      name,     label, recordformat,         ?,        switch, routine, }
  3068+             v in r, v in s,    v in r,    v in s,       a in s,    v in s,        a in s,       0
  3069          { function,    map, predicate,     array,    arrayname, namearray, namearrayname,       ?  }
  3070  
  3071          !                                                           >> STACK VAR <<
  3072          ! Push a descriptor on the stack corresponding to Var "var no"
  3073          ! We map the variable form to a stack form, and assign a register
  3074          ! for the base if it is non local.  Finally, we absorb the scope
  3075          ! into the base register.
  3076          %routine  Stack Var(%integer  var no)
  3077              %record(varfm)%name  w
  3078     
  3079              abort("Stack Var Idx") %unless 0 <= var no %and var no <= max vars
  3080              w == var(varno)
  3081              stp = stp + 1
  3082              %if stp > Max Stack %then abort("Push V Stack Overflow")
  3083              top == stack(stp)
  3084              top = 0
  3085  
  3086              ! Translate "level" into "base register" - if it is non local
  3087              ! we flag it by adding 16 to the desired level, which later will
  3088              ! force us to pick up a pointer register
  3089              %if w_level # 0 %start
  3090                  %if w_level = level %then top_base = BP %else top_base = w_level + 16
  3091              %else
  3092                  top_base = 0
  3093              %finish
  3094  
  3095              ! AFORM contains the real original declared form, while
  3096              ! FORM contains the on-the-stack subset of possible forms
  3097              top_idname = w_idname;   ! JDM remember variable name
  3098              top_aform = w_form
  3099              top_form = fmap(w_form)
  3100              top_dim = w_dim
  3101              top_type = w_type
  3102              top_disp = w_disp
  3103  			top_extdisp = w_disp
  3104              top_scope = w_scope
  3105              top_format = w_format
  3106              top_size = w_size
  3107              top_extra = w_extra
  3108              top_pbase = w_pbase
  3109              top_varno = varno
  3110  
  3111              monitor(top, "Var stack") %if diagnose&1 # 0
  3112          %end
  3113  
  3114          !                                              >> PUSH COPY <<
  3115          ! Push a duplicate of a stack record onto the stack
  3116          %routine  push copy(%record(stackfm)%name  v)
  3117              stp = stp + 1
  3118              %if stp > Max Stack %then abort("Stack Copy")
  3119              top == stack(stp)
  3120              top = v
  3121  
  3122              monitor(top, "Stack Copy") %if diagnose&1 # 0
  3123          %end
  3124  
  3125          !                                              >> PUSH CONST <<
  3126          ! Push a constant on the stack
  3127          %routine  push const(%integer  n)
  3128              stp = stp + 1
  3129              %if stp > Max Stack %then abort("Stack Const")
  3130              top == stack(stp)
  3131              top = 0
  3132              top_disp = n
  3133  			top_extdisp = 0
  3134              top_type = integer
  3135              top_form = constant
  3136              monitor(top, "push const") %if diagnose&1 # 0
  3137          %end
  3138  
  3139          !---------------------------------------------------------------------
  3140          !STRING PROCESSING
  3141          !---------------------------------------------------------------------
  3142          !                                              >> INPUT STRING VALUE<<
  3143          ! Read a string literal from the iCode stream
  3144          %routine  Input String Value( %string(255) s)
  3145              %integer  i
  3146  
  3147  			current string(0)= length(s)
  3148  			%for i = 1,1,length(s) %cycle
  3149  				current string(i) = charno(s,i)
  3150  			%repeat
  3151  
  3152              ! if this is about to be used as a literal, put it straight into
  3153              ! the CONST segment and stack it, otherwise leave it in curr string to see
  3154              ! what comes next and stack a dummy zero
  3155              %if Pending # 'A' %and Pending # '$' %start
  3156                  otype = con;        ! anonymous %const
  3157                  push const( getcots(current string) );
  3158  				top_type = string
  3159                  top_base = 0;
  3160  				top_scope = COT;
  3161  				top_form = VinS;
  3162  				top_format = current string(0)+1
  3163              %else
  3164                  push const(0);         ! explicit string initialisation coming next
  3165              %finish
  3166          %end
  3167  
  3168  		%routine Get Alias Value( %string(255) s )
  3169  
  3170  			alias = s
  3171  
  3172  		%end
  3173  
  3174  		%routine Input Real Value( %longreal r)
  3175  			%if r = 0 %then %start
  3176  				push const(0)
  3177  			%else
  3178  				%if Pending # 'A' %then %start
  3179  					otype = con;          !  anonymous %const
  3180  					push const(0)
  3181  					top_type = lreal;
  3182  					top_scope = COT;
  3183  					top_disp = getcotdouble(r);    !  N.B. ** %fn + side-effect **
  3184  					top_extdisp = 0
  3185  					top_form = v in s
  3186  				%finish
  3187  			%finish
  3188  			rvalue = r
  3189  		%end
  3190  
  3191          !-------------------------------------------------------
  3192          !LABEL PROCESSING
  3193          !
  3194          ! Labels fixups are handled by pass 3 - we just plant
  3195          ! numerical labels for code locations, and then jump to or call
  3196          ! those labels.  Pass 3 turns them into real locations.
  3197          ! Unfortunately Pass 3 needs unique label numbers whereas
  3198          ! Pass 1 produces lame local label numbers that can
  3199          ! be reused once they've been defined.  We therefore
  3200          ! maintain an indirect database to map Pass 1 label numbers
  3201          ! into unique tags
  3202  
  3203          !                                                          >> NEW TAG <<
  3204          ! Get the next consecutive Pass 3 label ID
  3205          %integerfn  new tag
  3206              %owninteger free tag = 999
  3207  
  3208              free tag = free tag + 1
  3209              %result = free tag
  3210          %end
  3211  
  3212          !                                                        >> NEW LABEL <<
  3213          ! Get the next available label database index
  3214          %integerfn  New Label
  3215              labs = labs+1;  abort("Labels") %if labs > Max Labs
  3216              %result = labs
  3217          %end
  3218  
  3219          !                                                        >> FIND LABEL<<
  3220          ! return the index in our label table of the Pass 1 label
  3221          %integerfn  Find Label(%integer  label)
  3222              %integer  lp
  3223  
  3224              lp = labs
  3225              %while lp # first label %cycle
  3226                  %result = lp %if labels(lp)_id = label
  3227                  lp = lp-1
  3228              %repeat
  3229              %result = 0
  3230          %end
  3231  
  3232          !                                                     >> DEFINE LABEL <<
  3233          ! This label is "here"
  3234          %routine  Define Label(%integer  label)
  3235              %integer lp
  3236              %record(labelfm)%name  l
  3237  
  3238              lp = Find Label(label)
  3239              %if lp = 0 %start;				! Not yet been used
  3240                  lp = New Label
  3241                  l == labels(lp)
  3242                  l_id = label
  3243                  l_tag = new tag
  3244              %else
  3245                  l == labels(lp)
  3246                  %if l_tag & 16_8000 # 0 %and label > 0 %then l_tag = new tag
  3247              %finish
  3248  
  3249              dump label(l_tag)
  3250              l_tag = l_tag ! 16_8000
  3251              uncond jump = 0;            ! You can get here
  3252          %end;       ! define label
  3253  
  3254          !                                                          >> JUMP TO <<
  3255          ! A wrapper for conditional jumps to labels that we're going
  3256          ! to map into tags
  3257          %routine  Jump To(%integer  label, op, flag)
  3258              %record(labelfm)%name  l
  3259              %integer  lp
  3260  
  3261              lp = Find Label(label)
  3262              %if lp = 0 %start
  3263                  lp = New Label
  3264                  l == labels(lp)
  3265                  l_id = label
  3266                  l_tag = new tag
  3267              %else
  3268                  l == labels(lp)
  3269                  %if flag # 0 %and l_tag & 16_8000 # 0 %then l_tag = new tag
  3270              %finish
  3271  
  3272              ! As a side effect, we also set the global J Tag, which is used
  3273              ! in planting Event block information (a bit hacky, but a PSR feature)
  3274              JTag = l_tag & 16_7FFF
  3275  
  3276              dump jump(op, JTag)
  3277  
  3278              %if op = JMP %then uncond jump = nextcad
  3279          %end;				! jump to
  3280  
  3281  		%routine Jump Forward( %integer val, test )
  3282  			%integer opr
  3283  
  3284  			! FF,TT tests need a value to compare
  3285  			! TT == TRUE (#0)
  3286  			! FF == FALSE (=0)
  3287  			%if (Test = FF) %or (Test = TT) %then dumpri(CMP, AX, 0)
  3288  			! Get the required operator for the test
  3289  			! We may need to amend the choice of operator
  3290  			! depending on the invert/compare unsign "flags"
  3291  			opr = TestToOp( test )
  3292  
  3293  			%if val = 0 %then %start
  3294  				%if last skip # next cad %then %start
  3295  					skip proc = new tag
  3296  					dumpjump(opr, skip proc)
  3297  				%finish
  3298  			%else
  3299  				! Check if we need to reverse the test
  3300  				! So, re-choose the operator
  3301  				%if invert # 0 %then Test = Reverse( Test )
  3302  				invert = 0;
  3303  
  3304  				! convert the operators to unsigned versions if needed
  3305  				%if compare unsign # 0 %then opr = TestToUnsignedOp( Test ) %else opr = TestToOp( Test )
  3306  				compare unsign = 0
  3307  
  3308  				jump to(val, opr, 1)
  3309  			%finish
  3310  		%end;				! Jump Forward
  3311  
  3312  		%routine Jump Backward( %integer val )
  3313  			jump to(val, JMP, 0);
  3314  		%end
  3315  
  3316          !-------------------------------------------------------
  3317          ! Stack variable transformations
  3318          !-------------------------------------------------------
  3319          !                                           >> REDUCE <<
  3320          ! Convert a variable which is addressed in a Rec into a simple variable
  3321          ! by loading the indirect value into a register and changing the form
  3322          %routine  reduce(%record(stackfm)%name  v)
  3323              %integer  type, form, disp, scope, extdisp
  3324     
  3325              form = v_form - 3;         ! X in REC => X in S
  3326              type = v_type
  3327              disp = v_disp
  3328  			extdisp = v_extdisp
  3329              ! Here's a trick - we've got two displacements, DISP and EXTRA, but only
  3330              ! one SCOPE hint.  Which does it belong to?  If the REC form came from
  3331              ! a HAZARD then the scope belongs to the DISP, but for all other cases
  3332              ! the scope belongs to the EXTRA.  If we got here through HAZARD then
  3333              ! the BASE will be BP - for all other cases it will be either a different
  3334              ! register, or zero.
  3335              %if v_base = BP %start
  3336                  scope = v_scope
  3337                  v_scope = 0
  3338              %else
  3339                  scope = 0
  3340              %finish
  3341              v_disp = v_extra;
  3342  			v_type = integer;
  3343  			v_form = v in s
  3344  
  3345              loadreg(v, anyp)
  3346  
  3347              v_type = type;
  3348  			v_form = form
  3349              v_disp = disp;
  3350  			v_extdisp = extdisp;
  3351  			v_scope = scope
  3352          %end
  3353  
  3354          !                                              >> AMAP <<
  3355          ! convert V into a descriptor for the address of V
  3356          %routine  amap(%record(stackfm)%name  v)
  3357              %integer f
  3358              %constintegerarray  addr map(0:15) =
  3359+             {    0,        1,  2,  3,       4,   5,               6,                   7, }
  3360+                 -1,       -2, -3, -4, AV in S,  -5,          V in S,           AV in REC,
  3361+ 
  3362+             {    8,        9, 10, 11,      12,  13,              14,                  15  }
  3363+                 -6, V in REC, -7, -8,      -9, -10, {PGM LABEL} -11, {record format} -12
  3364  
  3365              ! ABD - should be code here to deal with ADDR(pgm label)
  3366  
  3367              f = addr map(v_form)
  3368              %if f < 0 %start
  3369                  monitor(v, "AMAP target")
  3370                  abort("AMAP")
  3371              %finish
  3372  
  3373              ! Try to simplify some forms...
  3374              %if v_disp = 0 %and v_scope = 0 %start
  3375                  %if (f = AV in S) %start
  3376                      %if v_base = 0 %then f = constant %else f = V in R
  3377                  %finish %else %if (f = V in REC) %or (f = AV in REC) %start
  3378                      ! eliminate redundant LOAD
  3379                      %if (f = V in REC) %then f = A in S %else f = V in S
  3380                      v_disp = v_extra
  3381                  %finish
  3382              %finish
  3383              v_type = integer
  3384              v_form = f
  3385          %end
  3386  
  3387          !                                              >> VMAP <<
  3388          ! The inverse of AMAP:  i.e. vmap(amap(x)) => x
  3389          %routine  vmap(%record(stackfm)%name  v)
  3390              %integer  f, t
  3391              %constintegerarray  var map(0:8) =
  3392+             {      0,      1,  2,  3,      4,      5,  6,        7,        8 }
  3393+               V in S, V in S, -1, -2, A in S, V in S, -3, A in REC, V in REC
  3394  
  3395              %if (v_form = A in S) %or (v_form = A in REC) %start
  3396                  t = v_type
  3397                  amap(v)
  3398                  loadreg(v,anyp)
  3399                  v_type = t
  3400                  v_form = V in S
  3401              %finish
  3402              f = var map(v_form)
  3403              v_form = f
  3404              abort("VMap") %if f < 0
  3405          %end;            !  v map
  3406  
  3407          !                                              >> ADDRESS <<
  3408          ! convert V into a form in which it is directly addressable
  3409          ! that means either V in R, V in S or Constant
  3410          %routine  address(%record(stackfm)%name  v)
  3411              %integer  type, form
  3412     
  3413              monitor(v, "ADDRESS") %if diagnose&2 # 0
  3414  
  3415              form = v_form
  3416              type = v_type
  3417              %if form >= V in REC %start
  3418                  reduce(v)
  3419                  form = v_form
  3420              %finish
  3421  
  3422              ! Now pick up a base register if we needed one...
  3423              %if v_base > 16 %start
  3424                  v_base = get display(v_base - 16)
  3425                  claim(v_base)
  3426              %finish
  3427  
  3428              %return %if form = V in R %or form = constant
  3429  
  3430              %if form = AV in S %start
  3431                  %if v_base = 0 %start
  3432                      v_form = constant
  3433                  %else
  3434                      %if v_disp = 0 %and v_scope = 0 %start
  3435                          v_form = V in R
  3436                      %else
  3437                          loadreg(v, any)
  3438                      %finish
  3439                  %finish
  3440                  %return
  3441              %finish
  3442  
  3443              %return %if form = V in S
  3444     
  3445              %if form = A in S %start
  3446                  v_form = V in S
  3447                  v_type = integer
  3448                  loadreg(v,anyp)
  3449                  v_type = type
  3450                  v_form = V in S
  3451                  v_disp = 0
  3452              %finish
  3453          %end;            ! address
  3454  
  3455          !                                              >> LOAD REG <<
  3456          ! Load variable V into register R
  3457          ! Along the way any register the variable owned is released, and
  3458          ! the new register is claimed.
  3459  		%routine LoadReg(%record(stackfm)%name v, %integer r)
  3460  			%switch f(0:9)
  3461  			%integer ptr, op
  3462  
  3463  			monitor(v, "LOAD") %if diagnose&2 # 0
  3464  
  3465  			%if r = anyf %start
  3466  				! Equivalents for real numbers...
  3467  				! because there's very little clever we can do, we first simplify somewhat...
  3468  				Address(v)
  3469  				! Now it's either Constant, V in R or V in S - we now turn them
  3470  				! all into V in S - the only thing we can load
  3471  				! Start with one we have no instructions for, and promote it to
  3472  				! something we know how to handle...
  3473  				%if v_type = byte %then loadreg(v, any)
  3474  				%if v_form = V in R %start
  3475  					%return %if v_base >= FR0
  3476  					! This must be an integer in a CPU register - we need to store it
  3477  					! before we can use it
  3478  					v_disp = getwork(word size)
  3479  					dumpmr(MOV, BP, v_disp, v_extdisp, v_base)
  3480  					release(v_base)
  3481  					v_base = BP
  3482  					v_scope = 0
  3483  					v_form = V in S
  3484  					! Now it looks like an integer V in S
  3485  				%finish
  3486  				%if v_form = constant %start;		! This is an integer constant
  3487  					%if v_disp = 0 %start;			! We have a special instruction for zero
  3488  						r = FR0 + FPU Stack
  3489  						dumpflopspec(FLDZ)
  3490  						v_base = r
  3491  						claim(r)
  3492  						v_disp = 0;
  3493  						v_form = v in r
  3494  						v_type = real
  3495  						%return
  3496  					%finish
  3497  					! Otherwise, we need it in store
  3498  					v_disp = getcotw(v_disp)
  3499  					v_form = V in S
  3500  					v_base = 0
  3501  					v_scope = COT
  3502  				%finish
  3503  
  3504  				! Now everything that's left is a V in S
  3505  				%if v_type = integer %start
  3506  					op = FILD
  3507  				%else
  3508  					%if v_type = real %start
  3509  						op = FLDD
  3510  					%else
  3511  						op = FLDQ
  3512  					%finish
  3513  				%finish
  3514  
  3515  				! register is going to be the top of stack
  3516  				r = FR0 + FPU Stack
  3517  		
  3518  				dumpfloprm(op, v_base!v_scope, v_disp, v_extdisp )
  3519  				release(v_base)
  3520  				v_base = r
  3521  				claim(r)
  3522  				v_disp = 0;
  3523  				v_form = v in r
  3524  				v_type = real
  3525  				%return
  3526  			%finish
  3527  
  3528  			! If the request is one of the variations on "any" then we need
  3529  			! to first allocate a target register.  First, we make a local
  3530  			! adjustment because we can't load bytes into "any" register,
  3531  			! only into the GP registers...
  3532  			%if v_type = byte %start
  3533  				%if r = any %then r = anyg
  3534  				! What's more, there is only one register that is both a pointer
  3535  				! and a legal byte destination
  3536  				%if r = anyp %then r = BX
  3537  			%finish
  3538  
  3539  			! We also map the virtual display into a real register if we
  3540  			! need to.  Also, it is possible that an in-store form may
  3541  			! be derived from a non-pointer register, so we fix that too.
  3542  			%if v_base > 16 %then %start
  3543  				v_base = get display(v_base - 16)
  3544  				claim(v_base)
  3545  			%finish
  3546  
  3547  			! Now go ahead and allocate a register
  3548  			%if r = any %then %start
  3549  				! If we've got a base,
  3550                  ! it's not in use by anyone else,
  3551                  ! and isn't a display register,
  3552                  ! then use it
  3553  				%if v_base # 0 %and activity(v_base) = 1 %and displayhint(v_base) = 0 %start
  3554  					r = v_base
  3555  				%else
  3556  					r = gp reg
  3557  				%finish
  3558  			%else
  3559  				%if r = anyg %then %start
  3560  					%if 0 < v_base %and v_base <= BX %and activity(v_base) = 1 %start
  3561  						r = v_base
  3562  					%else
  3563  						r = gp reg
  3564  					%finish
  3565  				%else
  3566  					%if r = anyp %then %start
  3567  						%if activity(v_base) = 1 %and (v_base = BX %or v_base = SI %or v_base = DI) %then %start
  3568  							r = v_base
  3569  						%else
  3570  							r = pt reg
  3571  						%finish
  3572  					%else
  3573  						%if v_base = r %start
  3574  							%if activity(r) > 1 %start;  ! protect other uses
  3575  								release(r);  v_base = 0; ! Hide my ownership for the moment
  3576  								hazard(r);               ! Zap everybody else
  3577  								claim(r);    v_base = r; ! Get it back
  3578  							%finish
  3579  						%else
  3580  							hazard(r)
  3581  						%finish
  3582  					%finish
  3583  				%finish
  3584  			%finish
  3585  			-> f(v_form)
  3586  
  3587  f(v in rec):
  3588  			reduce(v); ->f(v_form)
  3589  
  3590  f(av in rec):
  3591  			reduce(v); ->f(v_form)
  3592  
  3593  f(a in rec):
  3594  			reduce(v); ->f(v_form)
  3595  
  3596  f(av in r):	Abort("Unexpected Stack Form")
  3597  
  3598  f(a in r):	Abort("Unexpected Stack Form")
  3599  
  3600  f(constant):
  3601  			%if v_disp = 0 %and v_scope = 0 %start
  3602  				dumprr(XOR, r, r)
  3603  			%else
  3604  				dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  3605  			%finish
  3606  			v_base = r
  3607  			v_disp = 0
  3608  			v_scope = 0
  3609  			v_form = v in r
  3610  			claim(r)
  3611  			%return
  3612  
  3613  f(v in r):
  3614              %return %if v_base = r
  3615  			dumprr(MOV, r, v_base)
  3616  			release(v_base)
  3617  			v_base = r
  3618  			v_disp = 0
  3619  			v_scope = 0
  3620  			v_form = v in r
  3621  			claim(r)
  3622  			%return
  3623  
  3624  f(a in s):
  3625              ! is the register a pointer?
  3626  			%if r = BX %or r = SI %or r = DI %start
  3627  				ptr = r
  3628  			%else
  3629  				ptr = pt reg
  3630  			%finish
  3631  			dumprm(MOV, ptr, v_base!v_scope, v_disp, v_extdisp )
  3632  			release(v_base); claim(ptr)
  3633  			v_base = ptr
  3634  			v_disp = 0
  3635  			v_scope = 0
  3636  			%if v_type = integer %start
  3637  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  3638  			%else
  3639  				%if v_type = byte %start
  3640  					! watch out for register re-use here...
  3641  					%if r # v_base %then dumprr(XOR, r, r);      ! clear it, but only if it isn't needed
  3642  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  3643  					%if r = v_base %then dumpri(AND, r, 255);    ! otherwise a more expensive clear later
  3644  					v_type = integer
  3645  				%else; ! reals
  3646  					abort("Load Real")
  3647  				%finish
  3648  			%finish
  3649  			release(v_base)
  3650  			v_base = r
  3651  			v_disp = 0
  3652  			v_scope = 0
  3653  			v_form = v in r
  3654  			claim(r)
  3655  			%return
  3656  
  3657  f(v in s):
  3658              %if v_type = integer %start
  3659  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  3660  			%else
  3661  				%if v_type = byte %start
  3662  					! watch out for register re-use here...
  3663  					%if r # v_base %then dumprr(XOR, r, r);      ! clear it, but only if it isn't needed
  3664  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  3665  					%if r = v_base %then dumpri(AND, r, 255);    ! otherwise a more expensive clear later
  3666  					v_type = integer
  3667  				%else; ! reals
  3668  					abort("Load Real")
  3669  				%finish
  3670  			%finish
  3671  			release(v_base)
  3672  			v_base = r
  3673  			v_disp = 0
  3674  			v_scope = 0
  3675  			v_form = v in r
  3676  			claim(r)
  3677  			%return
  3678  
  3679  f(av in s):
  3680  			%if v_base # 0 %start
  3681  				dumprm(LEA, r, v_base!v_scope, v_disp, v_extdisp )
  3682  				release(v_base)
  3683  				v_type = integer
  3684  			%else
  3685  				! else
  3686  				%if v_disp = 0 %and v_scope = 0 %start
  3687  					dumprr(XOR, r, r)
  3688  				%else
  3689  					dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  3690  				%finish
  3691  			%finish
  3692  			v_base = r
  3693  			v_disp = 0
  3694  			v_scope = 0
  3695  			v_form = v in r
  3696  			claim(r)
  3697  			%return
  3698  		%end;	! LOAD REG
  3699  
  3700          ! JDM JDM Adapted from Store routine in Assign
  3701          ! Store the register item reg in location given by LHS stackfm.
  3702          ! This only deals with the integer registers.
  3703          ! Store Reg does NOT cater for floating point registers.
  3704          ! The destination can be one of:
  3705          ! 1) Integer
  3706          ! 2) Byte
  3707          ! 3) Name/Pointer
  3708          %routine Store Reg(%record(stackfm)%name lhs, %integer reg)
  3709  
  3710              %if lhs_base = SP %start;			! it's a push
  3711                  %if lhs_type = integer %or lhs_type = byte %start
  3712                      dumpur(PUSH, reg)
  3713                  %finish
  3714              %finish %else %if lhs_type = integer %start
  3715                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  3716              %finish %else %if lhs_type = byte %start
  3717                  dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg+16)
  3718              %finish %else %if lhs_type = record %start
  3719                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  3720              %finish
  3721          %end;    ! STORE REG
  3722  
  3723          !                                              >> OPERATION <<
  3724          ! perform the operation OP on the top two elements of the stack.
  3725          !   (single element for unary operators)
  3726          %routine  Operation(%integer op)
  3727              %record(stackfm)%name  lhs, rhs
  3728              %integer assign pending, work, value, s
  3729              %switch oper(1:17), roper(1:17), fold(1:17)
  3730              %constintegerarray opmap(1:17) = 
  3731+             ADD, SUB, IMUL, IDIV,  0,  AND, OR, XOR, SHL, SHR, IDIV,   0,    0,   0,  NOT, NEG,   0
  3732  
  3733              %constintegerarray flopmap(1:17) = 
  3734+             FADD, FSUB, FMUL, FDIV, 0, 0, 0, 0, 0, 0, 0,   0,   0,    FDIV, 0, FCHS, FABS
  3735  
  3736              %constintegerarray indec(-1:1) = DEC, 0, INC; ! decrement, and increment opcodes
  3737  
  3738              %routine swap
  3739                  %record(stackfm) temp
  3740                  temp = lhs
  3741                  lhs = rhs
  3742                  rhs = temp
  3743              %end
  3744  
  3745              assign pending = 0
  3746              rhs == top
  3747              %if op < Unaries %then %start
  3748                  lhs == stack(stp-1)
  3749                  %if lhs_type = real %or lhs_type = lreal %or op >= REXPx %then ->reals
  3750              %finish
  3751  
  3752              %if rhs_type = real %or rhs_type = lreal %then ->reals
  3753  
  3754              %if rhs_form = constant %and (op >= Unaries %or lhs_form = constant) %then ->fold(op)
  3755  
  3756              ! now look for optimisations for x = x <op> whatever
  3757              %if Pending = 'S' %or Pending = 'j' %start;           ! the next task is an assignment
  3758                  %if op >= Unaries %start
  3759                      %if same(top, stack(stp-1)) # 0 %then assign pending = 1
  3760                  %else
  3761                      %if same(lhs, stack(stp-2)) # 0 %then assign pending = 1
  3762                  %finish
  3763              %finish
  3764  
  3765              ->oper(op)
  3766  oper(NOTx):
  3767  oper(NEGx):
  3768              ! we optimise for e.g. fred = -fred as one instruction
  3769              %if assign pending # 0 %then %start
  3770                  read symbol(Pending)
  3771                  address(rhs)
  3772                  %if rhs_type = byte %start
  3773                      dumpum8(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  3774                  %else
  3775                      dumpum(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  3776                  %finish
  3777                  pop rel
  3778                  pop rel
  3779                  %return
  3780              %finish
  3781              loadreg(rhs, any)
  3782              dumpur(opmap(op), rhs_base)
  3783              %return
  3784  
  3785              ! 8086 has no "abs" instructions, so we do a test and jump
  3786  oper(ABSx):
  3787              loadreg(rhs, any)
  3788  			dumpri(CMP, rhs_base, 0)
  3789              work = new tag
  3790              dumpjump(JGE, work)
  3791              dumpur(NEG, rhs_base)
  3792              dumplabel(work)
  3793              %return
  3794  
  3795  oper(ADDX):
  3796              %if lhs_form = constant %then swap
  3797              ! and fall through to minus
  3798  oper(SUBx):
  3799              ! First look for fred = fred + <whatever>
  3800              ! We can only safely do this for bytes if we're jamming or ignoring overflow
  3801              %if (assign pending # 0) %and %c
  3802+                 ((lhs_type = integer) %or ((control & check capacity) = 0) %or (Pending = 'j')) %then %start
  3803                  readsymbol(Pending)  ; ! we will do the assignment ourselves
  3804                  address(lhs)      ; ! make LHS accessible
  3805                  %if rhs_form = constant %then %start
  3806                      value = rhs_disp
  3807                      %if value # 0 %start
  3808                          %if op = SUBx %then value = -value
  3809                          ! look for increment or decrement instructions
  3810                          %if value < 2 %and value > -2 %then %start
  3811                              %if lhs_type = byte %start
  3812                                  dumpum8(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  3813                              %else
  3814                                  dumpum(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  3815                              %finish
  3816                          %else
  3817                              %if lhs_type = byte %start
  3818                                  dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  3819                              %else
  3820                                  dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  3821                              %finish
  3822                          %finish
  3823                      %finish
  3824                  %else;         ! RHS not a constant
  3825                      loadreg(rhs, any)
  3826                      %if lhs_type = byte %start
  3827                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  3828                      %else
  3829                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  3830                      %finish
  3831                  %finish
  3832                  pop rel
  3833                  pop rel
  3834                  pop rel
  3835                  %return
  3836              %finish
  3837  
  3838              ! So, there is no assign pending        
  3839              %if rhs_form = constant %then %start
  3840                  value = rhs_disp
  3841                  %if op = SUBx %then value = -value
  3842                  ! If it is already an address, do the math on the address offset
  3843                  %if lhs_form = avins %or lhs_form = avinrec %start
  3844                      lhs_disp = lhs_disp + value
  3845                  %else
  3846                      loadreg(lhs, any)
  3847                      ! We don't particulary try for it, but if we ended up with a pointer
  3848                      ! register, we might as well convert this to use the address form...
  3849                      %if lhs_base = BX %start;		! BX is the only GP reg that's also a pointer
  3850                          lhs_form = avins
  3851                          lhs_disp = value
  3852                      %else;								! otherwise, don't bother deferring the operation
  3853                          ! look for increment or decrement instructions
  3854                          %if value < 2 %and value > -2 %then %start
  3855                              %if value # 0 %then dumpur(indec(value), lhs_base)
  3856                          %else
  3857  							dumpri(opmap(op), lhs_base, rhs_disp)
  3858                          %finish
  3859                      %finish
  3860                  %finish
  3861              %else;                  ! not a constant
  3862                  %if op = ADDx %and rhs_form = v in r %then swap; ! commutative, so flip it
  3863                  loadreg(lhs, any)
  3864                  %if rhs_type = byte %start
  3865                      loadreg(rhs, any)
  3866                  %else
  3867                      address(rhs)
  3868                  %finish
  3869                  dumprv(opmap(op), lhs_base, rhs)
  3870              %finish
  3871              pop rel;    ! the RHS
  3872              %return
  3873  oper(ANDx):
  3874  oper(ORx):
  3875  oper(XORx):
  3876              !  Logical ops are a subset of ADD - similar behaviour, but no inc/dec/addr short forms
  3877              %if lhs_form = constant %then swap
  3878              ! First look for fred = fred <op> <whatever>
  3879              %if assign pending # 0 %then %start
  3880                  readsymbol(Pending);   ! we will do the assignment ourselves
  3881                  address(lhs);				! make LHS accessible
  3882                  %if rhs_form = constant %then %start
  3883                      value = rhs_disp
  3884                      %if lhs_type = byte %start
  3885                          warn(8) %if rhs_disp & (\255) # 0
  3886                          dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  3887                      %else
  3888                          dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  3889                      %finish
  3890                  %else;         ! RHS not a constant
  3891                      loadreg(rhs, any)
  3892                      %if lhs_type = byte %start
  3893                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  3894                      %else
  3895                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  3896                      %finish
  3897                  %finish
  3898                  pop rel; ! RHS
  3899                  pop rel; ! LHS
  3900                  pop rel; ! Assignment destination
  3901                  %return
  3902              %finish
  3903  
  3904              ! So, there is no assign pending        
  3905              %if rhs_form = constant %then %start
  3906                  value = rhs_disp
  3907                  loadreg(lhs, any)
  3908  				dumpri(opmap(op), lhs_base, value)
  3909              %else;                  ! not a constant
  3910                  %if rhs_form = v in r %then swap; ! all these are commutative, so flip it to make it easier
  3911                  loadreg(lhs, any)
  3912                  %if rhs_type = byte %and op = ANDx %start; ! AND needs all the bits to make sense
  3913                      loadreg(rhs, any);                        ! NB Load changes type to Integer
  3914                  %else
  3915                      address(rhs)
  3916                  %finish
  3917                  %if rhs_type = byte %start; ! must be V in S - everything else would be Integer
  3918                      dumprm8(opmap(op), lhs_base+16, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  3919                  %else
  3920                      dumprv(opmap(op), lhs_base, rhs)
  3921                  %finish
  3922              %finish
  3923  			pop rel;    ! the RHS
  3924              %return
  3925  
  3926  oper(MULx):
  3927              %if lhs_form = constant %or rhs_base = AX %then swap
  3928              %if rhs_form = constant %then %start
  3929                  value = rhs_disp
  3930                  %if value = 0 %then %start; ! mul by zero is zero
  3931                      release(lhs_base)
  3932                      lhs = rhs
  3933                      pop stack
  3934                      %return
  3935                  %finish
  3936                  %if value = 1 %then %start; ! mul by 1 is the identity
  3937                      pop stack
  3938                      %return
  3939                  %finish
  3940                  s = mulshift(value);        ! find a shift factor
  3941                  %if s > 0 %then %start
  3942                      rhs_disp = s
  3943                      op = LSHx
  3944                      -> shift it
  3945                  %finish
  3946                  ! 8086 multiply instruction doesn't have an immediate operand form
  3947                  ! so we use an entry in the constant table...
  3948                  rhs_base = 0; rhs_scope = COT; rhs_disp = getcotw(value)
  3949                  rhs_form = V in S
  3950                  ! and fall through to the not-a-constant path
  3951              %finish
  3952  do mul:
  3953              loadreg(lhs, AX)
  3954              address(rhs)
  3955              hazard(DX)
  3956              %if rhs_form = V in R %start
  3957                  dumpur(IMUL, rhs_base)
  3958              %else
  3959                  dumpum(IMUL, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  3960              %finish
  3961              pop rel
  3962              %return
  3963  oper(DIVx):
  3964  oper(REMx):
  3965              loadreg(lhs, AX)
  3966              address(rhs)
  3967              hazard(DX)
  3968              dumpsimple(CWD)
  3969              ! Plain 8086 Divide instruction also has no immediate operand form, so
  3970              ! we move constants to the COT
  3971              %if rhs_form = constant %start
  3972                  %if rhs_disp = 0 %then warn(1)
  3973                  rhs_base = 0; rhs_scope = COT; rhs_disp = getcotw(rhs_disp)
  3974                  rhs_form = V in S
  3975              %finish
  3976              %if rhs_form = V in R %start
  3977                  dumpur(IDIV, rhs_base)
  3978              %else
  3979                  dumpum(IDIV, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  3980              %finish
  3981              pop rel
  3982              %if op = DIVx %then %start
  3983                  lhs_base = AX
  3984              %else
  3985                  lhs_base = DX
  3986                  release(AX)
  3987                  claim(DX)
  3988              %finish
  3989              %return
  3990  oper(LSHx):
  3991  oper(RSHx):
  3992  shift it:
  3993              %if (assign pending # 0) %and %c
  3994+                 ((op = RSHx) %or (lhs_type = integer) %or (control & check capacity = 0) %or (Pending = 'j')) %then %start
  3995                  readsymbol(Pending);   ! we will do the assignment ourselves
  3996                  address(lhs);				! make LHS accessible
  3997                  %if rhs_form = constant %start
  3998                      warn(6) %unless 0 <= rhs_disp <= 31
  3999                      %if rhs_disp # 0 %start;   ! shift by zero is a no-op
  4000                          %if lhs_type = byte %start
  4001                              dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4002                          %else
  4003                              dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4004                          %finish
  4005                      %finish
  4006                  %else;         ! RHS not a constant
  4007                      ! Since the shift instruction only uses the bottom 5 bits of the
  4008                      ! value in CX, the value is "byte safe".  Rather than do a full
  4009                      ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  4010                      ! to save redundant coding
  4011                      %if rhs_type = byte %start
  4012                          hazard(CX)
  4013                          address(rhs)
  4014                          dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  4015                      %else
  4016                          loadreg(rhs,CX)
  4017                      %finish
  4018                      %if lhs_type = byte %start
  4019                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CL)
  4020                      %else
  4021                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CX)
  4022                      %finish
  4023                  %finish
  4024                  pop rel; ! RHS
  4025                  pop rel; ! LHS
  4026                  pop rel; ! Assignment destination
  4027                  %return
  4028              %finish
  4029  
  4030              ! deal with constant shifts first...
  4031              %if rhs_form = constant %then %start
  4032                  value = rhs_disp
  4033                  warn(6) %unless 0 <= value <= 31
  4034                  %if value # 0 %start
  4035                      loadreg(lhs, any)
  4036  					dumpri(opmap(op), lhs_base, value)
  4037                  %finish
  4038              %else;                              ! RHS variable
  4039                  ! Since the shift instruction only uses the bottom 4 bits of the
  4040                  ! value in CX, the value is "byte safe".  Rather than do a full
  4041                  ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  4042                  ! to save redundant coding
  4043                  %if rhs_type = byte %start
  4044                      hazard(CX)
  4045                      address(rhs)
  4046                      dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  4047                      release(rhs_base)
  4048                      rhs_base = CX
  4049                      claim(CX)
  4050                  %else
  4051                      loadreg(rhs,CX)
  4052                  %finish
  4053                  loadreg(lhs, any)
  4054                  dumprr(opmap(op), lhs_base, CX);
  4055              %finish
  4056              pop rel
  4057              %return
  4058  oper(EXPx):
  4059              %if rhs_form = constant %then %start
  4060                  %if rhs_disp = 0 %start
  4061                      pop rel
  4062                      pop rel
  4063                      push const(1)
  4064                      %return
  4065                  %finish
  4066                  %if rhs_disp = 1 %then %start
  4067                      pop rel
  4068                      %return
  4069                  %finish
  4070                  %if rhs_disp = 2 %then %start
  4071                      rhs = lhs
  4072                      claim(rhs_base)
  4073                      ->do mul
  4074                  %finish
  4075              %finish
  4076              loadreg(rhs, any)
  4077              dumpur(PUSH, rhs_base)
  4078              pop rel
  4079              loadreg(lhs, any)
  4080              dumpur(PUSH, lhs_base)
  4081              release(lhs_base)
  4082              perm(iexp, 2)
  4083              lhs_base = AX; claim(AX)
  4084              lhs_form = V in R
  4085              %return
  4086  oper(REXPx):
  4087  oper(RDIVx):
  4088              abort("Oper unexpected op")
  4089  
  4090              !-----------------------------------------------
  4091              ! Fold constant expressions at compile time
  4092  fold(NEGx):
  4093              value = -rhs_disp; -> set unary
  4094  fold(NOTx):
  4095              value = \rhs_disp; -> set unary
  4096  fold(ABSx):
  4097              value = rhs_disp; %if value < 0 %then value = -value; -> set value
  4098  fold(ADDx):
  4099              value = lhs_disp + rhs_disp; -> set value
  4100  fold(SUBx):
  4101              value = lhs_disp - rhs_disp; -> set value
  4102  fold(ORx):
  4103              value = lhs_disp ! rhs_disp; -> set value
  4104  fold(ANDx):
  4105              value = lhs_disp & rhs_disp; -> set value
  4106  fold(XORx):
  4107              value = lhs_disp !! rhs_disp; -> set value
  4108  fold(LSHx):
  4109              value = lhs_disp << rhs_disp; -> set value
  4110  fold(MULx):
  4111              value = lhs_disp * rhs_disp; -> set value
  4112  fold(RSHx):
  4113              value = lhs_disp >> rhs_disp; -> set value
  4114  fold(EXPx):
  4115              %if rhs_disp < 0 %then abort("Fold -ve Exp")
  4116  			value = 1
  4117              %for op=1, 1, rhs_disp %cycle
  4118                  value = value * lhs_disp
  4119              %repeat
  4120              -> set value
  4121  fold(REMx):
  4122  fold(DIVx):
  4123              value = rhs_disp;
  4124              warn(1) %and value = 1 %if value = 0
  4125              value = lhs_disp // value
  4126              %if op = DIVx %then -> set value
  4127              value = lhs_disp - (rhs_disp * value)
  4128              -> set value
  4129  fold(REXPx):
  4130              abort("Fold REXPx - Not implemented")
  4131  fold(RDIVx):
  4132              abort("Fold RDIVx - Not implemented")
  4133  
  4134  set value:
  4135              pop stack
  4136  set unary:
  4137              top_disp = value
  4138              %return
  4139  fold(CONCx):
  4140              abort("Fold CONCx - Not implemented")
  4141  
  4142              !--------------------------------------------------------------------
  4143              ! String operations - the only one is concatenate...
  4144  oper(CONCx):
  4145              %if assign pending # 0 %start;	! It's S = S.T
  4146                  amap(lhs)
  4147                  loadreg(lhs, any)
  4148                  dumpur(PUSH, lhs_base)
  4149                  amap(rhs)
  4150                  loadreg(rhs, any)
  4151                  dumpur(PUSH, rhs_base)
  4152                  pop rel
  4153                  pop rel
  4154                  dumppushi(0, lhs_size, 0)
  4155                  %if Pending = 'S' %then perm(sconc, 3) %else perm(sjconc, 3)
  4156                  ! and finally, skip the pending assignment, and drop the LHS
  4157                  readsymbol(Pending)
  4158                  pop rel
  4159                  %return
  4160              %finish
  4161  
  4162              ! here we've got T.U - if T is already in a WORK location
  4163              ! we've got a simple append.  If it is a user variable, we've
  4164              ! got to both copy it to a temp area and do the append
  4165              %if Is Work(lhs) = 0 %start;		! Not a work area
  4166                  work = getwork(256)
  4167                  push const(work)
  4168                  top_form = av in s
  4169                  top_base = BP
  4170                  loadreg(top, any)
  4171                  dumpur(PUSH, top_base)
  4172                  pop rel
  4173                  amap(lhs)
  4174                  loadreg(lhs, any)
  4175                  dumpur(PUSH, lhs_base)
  4176                  release(lhs_base)
  4177                  dumppushi(0, 255, 0)
  4178                  perm(smove, 3)
  4179                  ! Now we need to redefine the LHS as our temporary area
  4180                  lhs = 0;			! gratuitous clear-it-all-out
  4181                  lhs_type = string
  4182                  lhs_form = V in S
  4183                  lhs_base = BP
  4184                  lhs_disp = work
  4185                  lhs_size = 255
  4186              %finish
  4187  
  4188              ! Here we are doing an in-situ concatenation
  4189              ! We want to leave the result as a normal variable, so we
  4190              ! suck up a copy for the AMAP fiddling
  4191              push copy(lhs)
  4192              amap(top)
  4193              loadreg(top, any)
  4194              dumpur(PUSH, top_base)
  4195              poprel
  4196              amap(rhs)
  4197              loadreg(rhs, any)
  4198              dumpur(PUSH, rhs_base)
  4199              pop rel
  4200              dumppushi(0, lhs_size, 0)
  4201              perm(sconc, 3)
  4202              %return
  4203  Reals:
  4204              %if op < Unaries %then loadreg(lhs, anyf)
  4205              %if op # REXPx %then loadreg(rhs, anyf)
  4206              ->roper(op)
  4207  
  4208  roper(NEGx):
  4209  roper(ABSx):
  4210              dumpfloprr(flopmap(op), rhs_base, rhs_base)
  4211              %return
  4212  
  4213  roper(ADDx):
  4214  roper(MULx):
  4215              ! Commutative, so we don't care
  4216              %if lhs_base > rhs_base %then swap
  4217              dumpfloprr(flopmap(op), lhs_base, rhs_base)
  4218              pop rel
  4219              %return
  4220  
  4221  roper(SUBx):
  4222  roper(DIVx):
  4223  roper(RDIVx):
  4224              ! We can't swap these, so we use the reverse form of
  4225              ! the opcode (which in our internal form is always one
  4226              ! more than the basic opcode index)
  4227              op = flopmap(op)
  4228              %if lhs_base > rhs_base %start
  4229                  swap
  4230                  op = op + 1
  4231              %finish
  4232              dumpfloprr(op, lhs_base, rhs_base)
  4233              pop rel
  4234              %return
  4235  
  4236  roper(REXPx):
  4237              ! This is implemented as a PERM routine
  4238              loadreg(rhs, any)
  4239              dumpur(PUSH, rhs_base)
  4240              pop rel
  4241              ! The usual slightly clunky floating point "push"
  4242              work = ptreg
  4243  			dumpri(SUB, SP, 8)
  4244              dumprr(MOV, work, SP)
  4245              dumpfloprm(FSTQ, work, 0, 0)
  4246              release(lhs_base)
  4247              perm(fexp, 1 + (8//wordsize))
  4248              ! Since rexp is actually a standard C routine, the result will
  4249              ! be on the FPU stack
  4250              lhs_base = FR0; claim(FR0)
  4251              fpu stack = 1
  4252              lhs_form = V in R
  4253              lhs_type = lreal
  4254              %return
  4255  
  4256  roper(NOTx):
  4257  			abort("NOTx: Unsupported Real Operation")
  4258  roper(ANDx):
  4259  			abort("ANDx: Unsupported Real Operation")
  4260  roper(ORx):
  4261  			abort("ORx: Unsupported Real Operation")
  4262  roper(XORx):
  4263  			abort("XORx: Unsupported Real Operation")
  4264  roper(REMx):
  4265  			abort("REMx: Unsupported Real Operation")
  4266  roper(LSHx):
  4267  			abort("LSHx: Unsupported Real Operation")
  4268  roper(RSHx):
  4269  			abort("RSHx: Unsupported Real Operation")
  4270  roper(EXPx):
  4271  			abort("EXPx: Unsupported Real Operation")
  4272  
  4273          %end;        !     Operation
  4274  
  4275          !                                                           >> ASSIGN <<
  4276          ! ASSOP =   -1:  parameter assignment
  4277          !            0:  == assignment
  4278          !            1:  =  assignment
  4279          !            2:  <- assignment
  4280          %routine  assign(%integer  assop)
  4281              %record(stackfm)%name  lh,rh
  4282              %record(stackfm)  temp
  4283              %integer  n, p, form, r
  4284  
  4285              ! Store the item in RHS to LHS.  Encapsulates the dificulties
  4286              ! of variable length items and pushing things on the stack to
  4287              ! keep the rest of "Assign" looking tidy
  4288              %routine Store(%record(stackfm)%name lhs, rhs)
  4289                  %integer pt, s, op
  4290  
  4291                  %if lhs_base = SP %start;			! it's a push
  4292                      %if lhs_type = integer %or lhs_type = byte %start
  4293                          %if rhs_type = byte %start
  4294                              loadreg(rhs, any)
  4295                          %else
  4296                              address(rhs)
  4297                          %finish
  4298                          dumpvpush(rhs)
  4299                      %else;		! must be a real
  4300                          %if lhs_type = real %start
  4301                              s = 4
  4302                              op = FSTD
  4303                          %else
  4304                              s = 8
  4305                              op = FSTQ
  4306                          %finish
  4307                          loadreg(rhs, anyf)
  4308                          pt = ptreg
  4309  						dumpri(SUB, SP, s)
  4310                          dumprr(MOV, pt, SP)
  4311                          dumpfloprm(op, pt, 0, 0)
  4312                      %finish
  4313                      %return
  4314                  %finish
  4315                  %if lhs_type = integer %start
  4316                      %if rhs_form = constant %and rhs_scope = 0 %start
  4317                          dumpmi(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4318                      %else
  4319                          loadreg(rhs, any)
  4320                          dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  4321                      %finish
  4322                  %else
  4323                      %if lhs_type = byte %start
  4324                          %if rhs_form = constant %and rhs_scope = 0 %start
  4325                              dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  4326                          %else
  4327                              %if rhs_type = byte %start;   ! try to avoid pointless promoting to an int
  4328                                  ! We will reproduce a "Load" but without the word extension
  4329                                  address(rhs)
  4330                                  pt = gp reg
  4331                                  dumprm8(MOV, pt+16, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  4332                                  release(rhs_base)
  4333                                  rhs_base = pt; rhs_form = V in R; rhs_type = Integer
  4334                                  claim(pt)
  4335                              %else
  4336                                  loadreg(rhs, any)
  4337                                  ! ABD - should add a capacity check here
  4338                              %finish
  4339                              dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  4340                          %finish
  4341                      %else
  4342                          loadreg(rhs, anyf)
  4343                          %if lhs_type = real %start
  4344                              op = FSTD
  4345                          %else; ! long real
  4346                              op = FSTQ
  4347                          %finish
  4348                          dumpfloprm(op, lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  4349                      %finish
  4350                  %finish
  4351              %end
  4352  
  4353              abort("Assign Stack") %if stp < 2
  4354  
  4355              rh == top
  4356              lh == stack(stp-1)
  4357  
  4358              form = lh_form;        ! to avoid the ravages of amap, load etc
  4359     
  4360              %if diagnose&4 # 0 %start
  4361                  monitor(lh, "ASS LH")
  4362                  monitor(rh, "ASS RH")
  4363              %finish
  4364     
  4365              %if same(lh, rh) # 0 %then %start
  4366                  pop rel
  4367                  pop rel
  4368                  %return
  4369              %finish
  4370  
  4371              %if assop < 0 %start;           ! Parameter
  4372                  %if lh_base >= 128 %start;     ! Special - prim routine
  4373                      temp = lh;  lh = rh;  rh = temp
  4374                      %return
  4375                  %finish
  4376  
  4377                  ! Extract the next formal parameter and make it our target
  4378                  lh_pbase = lh_pbase - 1
  4379                  Stack Var(lh_pbase)
  4380                  ! Now make our destination look reasonable
  4381                  lh == top
  4382                  lh_base = SP;							! target is the stack
  4383                  assop = 0 %if lh_form # v in s;	! %name parameter is '=='
  4384  
  4385                  ! We need special treatment for procedure parameters
  4386                  %if 7 <= lh_aform <= 10 %start;	! this is a procedure
  4387                      assop = 1;							! we will treat it as a value assignment
  4388                      rh_type = integer;				! of an integer
  4389                      lh_type = integer; lh_form = V in S
  4390                      %if rh_base # 0 %start;			! RH is already a parameter
  4391                          rh_form = V in S
  4392                      %else
  4393                          %if rh_scope = EXT %start;	! it is an external procedure
  4394                              rh_form = A V in S;		! pick up the addres
  4395                          %else;							! it is a local procedure
  4396                              ! HACK: local procedures are Tags until Pass3 fixes them up.  The
  4397                              ! only way we have of converting tags to addresses is with the switch
  4398                              ! table - so we'll plant a fake switch entry for the label of the
  4399                              ! local routine, and then load that value!
  4400                              %if swtp >= Max Switch %then abort("Proc - Switch Table Full")
  4401                              swtab(swtp) = rh_disp; rh_disp = swtp * word size; swtp = swtp+1
  4402                              rh_scope = SWT
  4403                              rh_form = V in S
  4404                          %finish
  4405                      %finish
  4406                  %finish
  4407              %finish
  4408  
  4409              %if array <= rh_aform %and rh_aform <= namearrayname %start;        ! Arrayname
  4410                  ! An array name is two words - a pointer to the data and a
  4411                  ! pointer to the dope vector.  If the RHS is already one of these
  4412                  ! then we just want to copy the two words.  If it is a static
  4413                  ! array, we need to map the data to make a pointer, and its' dope
  4414                  ! vector will be in the constant table, so we fetch that.
  4415                  amap(lh)
  4416                  address(lh)
  4417                  amap(rh);            ! This works because arrays are stacked as V in S, arraynames are A in S
  4418                  address(rh)
  4419                  ! We do the dope vector first - that makes it easier when we're parameter passing
  4420                  %if rh_aform = array %or rh_aform = name array %start;   ! simple static - DV in COT
  4421                      ! We will rustle up a dummy record for the DV address
  4422                      temp = 0
  4423                      temp_form = A V in S
  4424                      temp_type = integer
  4425                      temp_disp = rh_pbase
  4426                      temp_scope = COT
  4427                  %else;                                                   ! already an array name
  4428                      temp = rh; claim(temp_base)
  4429                      temp_disp = temp_disp + word size
  4430                  %finish
  4431                  lh_disp = lh_disp+word size
  4432                  store(lh, temp)
  4433                  release(temp_base)
  4434                  lh_disp = lh_disp-word size
  4435                  store(lh, rh)
  4436                  pop rel
  4437                  pop rel
  4438                  %return
  4439              %finish
  4440  
  4441              %if lh_type = general %start;     ! general %name parameter
  4442                  abort("Assign GenName") %unless assop = 0; ! Only '==' is allowed
  4443                  ! A general name pointer is two words - the pointer itself
  4444                  ! and a second word to convey type information.  If the RHS
  4445                  ! is already one of thse guys it's easy - just copy the two
  4446                  ! words.  Otherwise, we need to rustle up the second word at
  4447                  ! compile time.
  4448                  amap(lh)
  4449                  address(lh)
  4450                  %if rh_type = general %start
  4451                      temp = rh;	! make a copy for the second word
  4452                      claim(temp_base); temp_disp = temp_disp + word size
  4453                      amap(temp)
  4454                  %else
  4455                      temp = 0
  4456                      temp_type = integer
  4457                      temp_disp = (rh_size << 4) + genmap(rh_type)
  4458                  %finish
  4459                  ! We do the words backwards, so that parameter push works
  4460                  lh_disp = lh_disp + word size
  4461                  store(lh, temp)
  4462                  release(temp_base)
  4463                  lh_disp = lh_disp-word size
  4464                  amap(rh)
  4465                  store(lh, rh)
  4466                  pop rel
  4467                  pop rel
  4468                  %return
  4469              %finish
  4470  
  4471              %if assop = 0 %start;        ! ==
  4472                  amap(lh);      ! destination
  4473                  amap(rh);      ! ABD %string(*)%name  NOT handled special here - should be?
  4474              %finish
  4475  
  4476              %if Lh_Type = record %start
  4477                  %if lh_base = SP %start;		! pass record by value - destination is the stack
  4478                      n = lh_size
  4479                      hazard(DI)
  4480  					dumpri(SUB, SP, lh_size)
  4481                      dumprr(MOV, DI, SP)
  4482                      claim(DI)
  4483                      lh_base = DI
  4484                  %else
  4485                      n = Min Record Size(Lh, Rh)
  4486                      amap(lh)
  4487                      loadreg(lh, DI)
  4488                  %finish
  4489                  hazard(CX)
  4490  				dumpri(MOV, CX, n)
  4491                  %if rh_Form = Constant %start
  4492                      hazard(AX)
  4493                      dumprr(XOR, AX,AX);		! get a zero
  4494                      dumprepstosb
  4495                  %else
  4496                      amap(rh)
  4497                      loadreg(rh, SI)
  4498                      dumprepmovsb
  4499                  %finish
  4500                  pop rel
  4501                  pop rel
  4502                  %return
  4503              %finish
  4504  
  4505              %if lh_type = string %start
  4506                  %if assop > 0 %and rh_format = 1 %start;    ! null string as zero byte ?
  4507                      lh_type = byte
  4508                      pop rel;       ! zap current RHS
  4509                      push const(0);     ! get a zero
  4510                      assign(assop); ! and assign it
  4511                      %return
  4512                  %finish
  4513  
  4514                  ! our copy routines expect DEST then SOURCE then LENGTH on the stack
  4515                  %if lh_base = SP %start;		! pass string by value - destination is the stack
  4516                      ! space is string size, plus one for length, plus make it even
  4517                      p = lh_size + 1; p = (p+align) & (\align)
  4518  					dumpri(SUB, SP, p)
  4519                      ! we want to Push SP here - sadly different versions of x86
  4520                      ! architecture have different interpretations of "PUSH SP", so...
  4521                      r = gp reg
  4522                      dumprr(MOV, r, SP)
  4523                      dumpur(PUSH, r)
  4524                  %else
  4525                      amap(lh)
  4526                      loadreg(lh, any)
  4527                      dumpur(PUSH, lh_base)
  4528                  %finish
  4529                  ! It is likely that the RH variable is a temporary work area
  4530                  ! Before we trash the information, we try to release it
  4531                  Return Work(rh_disp)
  4532                  amap(rh)
  4533                  loadreg(rh, any)
  4534                  dumpur(PUSH, rh_base)
  4535                  pop rel
  4536                  pop rel
  4537                  dumppushi(0, lh_size, 0)
  4538                  %if assop = 2 %then perm(sjam, 3) %else perm(smove, 3)
  4539                  %return
  4540              %finish
  4541  
  4542              address(lh)
  4543              store(lh, rh)
  4544              pop rel
  4545              pop rel
  4546          %end;            !  assign
  4547  
  4548          !                                                      >> ARRAY REF <<
  4549          ! Array references always use the PERM
  4550          ! unless they are 1 dimensional,
  4551          ! AND the %control bit has been turned off
  4552          %routine  array ref(%integer mode)
  4553              %record(stackfm)%name av
  4554              %integer type, form, size, format
  4555  
  4556              %if mode#0 %then %start
  4557                  ! Put non-terminal index onto stack for PERM
  4558                  %if top_type = byte %start
  4559                      loadreg(top, any)
  4560                  %else
  4561                      address(top)
  4562                  %finish
  4563                  dumpvpush(top)
  4564                  pop rel
  4565                  %return
  4566              %finish
  4567     
  4568              av == stack(stp-1)
  4569              size = av_size
  4570              size = size + 1 %if av_type = string
  4571              form = av_aform
  4572              %if form=namearray %or form=namearrayname %then size = word size
  4573  
  4574              %if control & check array = 0 %and av_dim = 1 %start
  4575                  ! This will be unchecked, the top of the stack is the only index (1D),
  4576                  ! so we can do a cheap multiplication here
  4577                  %if size#1 %start;      ! multiply offset by var size
  4578                      push const(size)
  4579                      Operation(MULx)
  4580                  %finish
  4581              %else
  4582                  ! This is the final (and perhaps only) subscript for a checked array,
  4583                  ! so we are going to use the Perm - therefore pass this as a parameter
  4584                  %if top_type = byte %start
  4585                      loadreg(top, any)
  4586                  %else
  4587                      address(top)
  4588                  %finish
  4589                  dumpvpush(top)
  4590                  pop rel
  4591              %finish
  4592  
  4593              ! How we do the rest of the access depends on whether this is a simple
  4594              ! static array, or an array name...
  4595  
  4596              %if form = arrayname %or form = namearrayname %start;   ! array is a "name"
  4597                  ! We will AMAP the name, so we remember the info and then put it all back later
  4598                  type = av_type
  4599                  format = av_format
  4600                  size = av_size
  4601                  %if form = arrayname %then form = v in s %else form = a in s
  4602                  amap(av)
  4603  
  4604                  %if control & check array # 0 %or av_dim > 1 %start;     ! do the rest of the check
  4605                      ! This is a bit clunky, because we may load registers in order
  4606                      ! to access AV, only to Hazard them for the PERM
  4607                      address(av)
  4608                      push copy(av); claim(top_base)
  4609                      top_disp = top_disp + word size;   ! Dope Vector address follows A(0)
  4610                      dumpvpush(top)
  4611                      pop rel
  4612                      perm(aref, av_dim + 1); ! DV word, plus a word for every subscript
  4613                      push const(0)
  4614                      top_form = V in R; top_base = AX; claim(AX)
  4615                  %finish
  4616  
  4617                  loadreg(top, anyp);        ! make sure index is in a pointer register
  4618                  Operation(ADDx)
  4619                  top_type = type
  4620                  top_form = form
  4621                  top_format = format
  4622                  top_size = size
  4623                  top_disp = 0
  4624              %else;     ! simple arrays are always 1D, but can still be checked
  4625                  %if control & check array # 0 %start
  4626                      ! Pass a pointer to the Dope Vector
  4627                      dumppushi(COT, av_pbase, 0);     ! simple arrays have compile-time DV's in the COT
  4628                      perm(aref, 2)
  4629                      push const(0)
  4630                      top_form = V in R; top_base = AX; claim(AX)
  4631                  %finish
  4632  
  4633                  address(av)
  4634                  %if av_form # v in s %then abort("Aref Form")
  4635                  %if top_form = constant %start;  ! simple constant a(k)
  4636                      av_disp = av_disp + top_disp; ! just add it to the offset
  4637                  %else
  4638                      loadreg(top, anyp);              ! pick up index in a pointer
  4639                      %if av_base # 0 %start;       ! add the base we've already got
  4640                          dumprr(ADD, top_base, av_base)
  4641                          release(av_base)
  4642                      %finish
  4643                      av_base = top_base
  4644                  %finish
  4645                  %if form = array %then av_form = v in s %else av_form = a in s
  4646                  pop stack
  4647              %finish
  4648  
  4649              top_aform = 0; ! not an array any more
  4650  
  4651          %end;       !  array ref
  4652  
  4653          !                                              >> TEST ZERO <<
  4654          ! test a real/integer/byte variable against zero
  4655          %routine  test zero(%record(stackfm)%name  v)
  4656  
  4657              %if v_type = integer %or v_type = byte %start
  4658                  loadreg(v,any)
  4659  				dumpri(CMP, v_base, 0)
  4660              %else
  4661                  abort("Test Zero")
  4662              %finish
  4663          %end;      ! test zero
  4664  
  4665          %routine Compare Records(%record(stackfm)%name L, R, %integer N)
  4666              ! JDM eventually compare the byte values of each record
  4667              ! in the interim, barf
  4668              abort("Compare Records")
  4669          %end
?N unused
?R unused
?L unused
  4670  
  4671          !                                              >> COMPARE REALS <<
  4672          %routine  compare reals(%record(stackfm)%name  l,r)
  4673              loadreg(l, anyf)
  4674              loadreg(r, anyf)
  4675              hazard(AX)
  4676              ! who's ended up on top?
  4677              %if l_base > r_base %start;   ! l_base is the top of the FPU stack
  4678                  dumpfloprr(FCMP, r_base, l_base)
  4679              %else
  4680                  dumpfloprr(FCMP, l_base, r_base)
  4681                  invert = invert !! 1
  4682              %finish
  4683              dumpflopspec(FSTSW); ! puts status into AX
  4684              dumpsimple(SAHF);    ! and move it to flags
  4685              compare unsign = 1;  ! because FPU reports as if operands were unsigned
  4686          %end;        ! compare reals
  4687  
  4688          !                                              >> COMPARE STRINGS <<
  4689          %routine  compare strings(%record(stackfm)%name  l,r)
  4690              %record(stackfm)%name  temp
  4691              %if l_base = COT %and l_disp = null string %start
  4692                  temp == r;  r == l; l == temp
  4693                  invert = invert !! 1
  4694              %finish
  4695              %if r_base = COT %and r_disp = null string %start
  4696                  l_type = byte
  4697                  test zero(l)
  4698              %else
  4699                  amap(l)
  4700                  loadreg(l, any)
  4701                  dumpur(PUSH, l_base)
  4702                  amap(r)
  4703                  loadreg(r, any)
  4704                  dumpur(PUSH, r_base)
  4705                  perm(scomp, 2)
  4706  				dumpri(CMP, AX, 0)
  4707              %finish
  4708          %end;       ! compare strings
  4709  
  4710          !                                              >> COMPARE <<
  4711          %routine  compare(%record(stackfm)%name  l,r)
  4712              %if l_type = 0 %or l_type = string %start
  4713                  compare strings(l,r);  %return
  4714              %finish
  4715              %if floating(l)#0 %or floating(r)#0 %start
  4716                  compare reals(l,r);  %return
  4717              %finish
  4718              %if zero(r) # 0 %start
  4719                  test zero(l);  %return
  4720              %finish
  4721              %if zero(l) # 0 %start
  4722                  test zero(r);  invert = invert !! 1
  4723                  %return
  4724              %finish
  4725              %if l_Type = Record %start
  4726                  Compare Records(L, R, Min Record Size(L, R))
  4727                  %return
?access
  4728              %finish
  4729              loadreg(l,any)
  4730              %if r_type = byte %start
  4731                  loadreg(r, anyg)
  4732              %else
  4733                  address(r)
  4734              %finish
  4735              dumprv(CMP, l_base, r)
  4736          %end;        ! compare
  4737  
  4738          !                                              >> RESOLVE <<
  4739          %routine  resolve(%integer  flag)
  4740              !S -> A.(B).C
  4741              %if flag&1 = 0 %then push const(0) %else amap(top); ! C missing?
  4742              loadreg(top, any)
  4743              dumpur(PUSH, top_base)
  4744              pop rel
  4745              amap(top);  ! B
  4746              loadreg(top, any)
  4747              dumpur(PUSH, top_base)
  4748              pop rel
  4749              %if flag&2 = 0 %then push const(0) %else amap(top); ! A missing?
  4750              loadreg(top, any)
  4751              dumpur(PUSH, top_base)
  4752              pop rel
  4753              amap(top);  ! S
  4754              loadreg(top, any)
  4755              dumpur(PUSH, top_base)
  4756              pop rel
  4757              perm(sresln, 4)
  4758              %if flag&4 # 0 %then dumpri(CMP, AX, 0)
  4759          %end;           ! resolve
  4760  
  4761          %integerfn enter
  4762              %integer cad;
  4763  
  4764              uncond jump = -1; ! can get here
  4765  
  4766              ! This is a convenient place to include external definitions if needed
  4767              %if potype >= external %start
  4768                  fill external(CODE, next cad, external id)
  4769              %finish
  4770  
  4771              cad = nextcad;
  4772              dumpstaticalloc(cad, level, block name); ! plant dummy ENTER instruction and pass marker to pass 3
  4773              %result = cad;
  4774          %end
  4775  
  4776          !                                              >> DUMP RETURN <<
  4777          %routine  dump return
  4778              %return %if uncond jump = next cad;          !  can't get here ?
  4779  
  4780              ! Pure 8086 would need these two
  4781              !	dumprr(MOV, SP, BP)
  4782              !	dumpur(POP, BP)
  4783              ! but now we use this instead...
  4784              dumpsimple(LEAVE)
  4785  
  4786              dumpsimple(RET);
  4787  
  4788              uncond jump = next cad
  4789          %end;          ! return
  4790  
  4791          ! Routine to do "to string" as an in-line, either by making
  4792          ! a constant string in the CONST area, or putting one onto
  4793          ! the current workspace
  4794          %routine  compile to string(%record(stackfm)%name  v)
  4795              %integer tmp
  4796  
  4797              %if const(v)#0 %start
  4798                  current string(0) = 1;  current string(1) = v_disp&255
  4799                  v_base = 0; v_scope = COT; v_disp = getcots(current string)
  4800              %else
  4801                  tmp = getwork(word size)
  4802                  loadreg(v,anyg);        ! Must be a byte-addressable register
  4803                  dumpmi(MOV, BP, tmp, 0, 1)
  4804                  dumpmr8(MOV, BP, tmp+1, 0, v_base+16)
  4805                  release(v_base)
  4806                  v_base = BP;  v_scope = 0; v_disp = tmp
  4807              %finish
  4808              v_type = string;  v_form = VinS;  v_size = 1
  4809          %end
  4810  
  4811          !                                              >> COMPILE CALL <<
  4812          ! Call the routine on the top of the stack.  Note - the parameters
  4813          ! are all hidden underneath the routine, so we need to push them
  4814          ! here
  4815          %routine  Compile Call(%record(stackfm)%name  v)
  4816              %switch  b(1:15)
  4817              !  1 = rem
  4818              !  2 = float
  4819              !  3 = to string
  4820              !  4 = addr
  4821              !  5 = integer
  4822              !  6 = byte integer
  4823              !  7 = string
  4824              !  8 = record
  4825              !  9 = real
  4826              ! 10 = long real
  4827              ! 11 = length
  4828              ! 12 = charno
  4829              ! 13 = type of ( type of general name parameter )
  4830              ! 14 = size of ( physical length in bytes )
  4831              ! 15 = int (from real)
  4832  
  4833              %constbyteintegerarray  new type(5:12) =
  4834+                         1,       5,    3,       4,    2,    6,     5,    5
  4835              !         integer, byte, string, record, real, lreal, byte, byte
  4836              %integer  t,l,p
  4837  
  4838              %if v_base >= 128 %start;         !  built-in primitive
  4839                  l = 0;  t = v_disp;  sym = 0;      ! 'sym=0' used as flag elsewhere
  4840                  pop rel
  4841                  -> b(t)
  4842  b(1):			Operation(REMx);		-> esac;	! REM
  4843  b(2):			loadreg(top, anyf);		-> esac;	! FLOAT
  4844  b(3):			compile to string(top);	-> esac;	! TO STRING
  4845  b(4):			amap(top);				-> esac;	! ADDR
  4846  b(5):;                                              ! INTEGER
  4847  b(6):;                                              ! BYTE
  4848  b(7):;                                              ! STRING
  4849  b(8):;                                              ! RECORD
  4850  b(9):;                                              ! REAL
  4851  b(10):;                                             ! LONG REAL
  4852                  vmap(top);  top_type = new type(t)
  4853                  top_size = v size(top_Type)
  4854  				-> esac
  4855  b(11):;                                             ! LENGTH
  4856                  push const(0);                      ! length is charno zero
  4857                  amap(stack(stp-1))
  4858                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  4859                  vmap(top);  top_type = new type(t)
  4860                  top_size = v size(top_Type)
  4861  				-> esac
  4862  b(12):;                                             ! CHARNO
  4863                  amap(stack(stp-1))
  4864                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  4865                  vmap(top);  top_type = new type(t)
  4866                  top_size = v size(top_Type)
  4867  				-> esac
  4868  b(13):;                                             ! type of(..)
  4869  b(14):;                                             ! size of(..)
  4870                  %if top_type # general %start;      ! type explicitly specified
  4871                      %if t = 13 %start;      ! type of
  4872                          p = gen map(top_type)
  4873                      %else
  4874                          p = top_size;  p = p+1 %if top_type = string
  4875                      %finish
  4876                      release(top_base)
  4877                      top_type = integer;  top_form = constant
  4878                      top_base = 0;  top_disp = p
  4879                  %else
  4880                      top_disp = top_disp + word size;      ! reference property-word
  4881                      top_form = V in S;  top_type = integer
  4882                      %if t = 13 %start;         ! type of
  4883                          push const(15);  Operation(ANDx)
  4884                      %else;                     ! size of
  4885                          push const(4);  Operation(RSHx)
  4886                      %finish
  4887                  %finish
  4888  				-> esac
  4889  b(15):;                                             ! INT(real)
  4890                  loadreg(top, anyf)
  4891                  release(top_base)
  4892                  p = getwork(word size)
  4893                  dumpfloprm(FSTI, BP, p, 0 )
  4894                  top_type = integer
  4895                  top_form = V in S
  4896                  top_base = BP
  4897                  top_disp = p
  4898  				-> esac
  4899  esac:
  4900  			%else
  4901                  !   -- normal routine calls --
  4902                  ! String functions have a hidden last parameter to point
  4903                  ! to the result area
  4904                  %if v_type = string %and v_aform = 8 %start
  4905                      t = getwork(v_size+1)
  4906                      p = gp reg
  4907                      dumprm(LEA, p, BP, t, 0)
  4908                      dumpur(PUSH, p)
  4909                  %finish
  4910                  hazard all
  4911                  %if v_scope = EXT %start;        ! external
  4912                      dumpextcall(v_disp)
  4913                  %else
  4914                      %if v_base # 0 %start;                        ! procedure-as-parameter
  4915                          dumpum(CALL, v_base, v_disp, v_extdisp ); ! plants call indirect through variable
  4916                      %else;                                        ! local routine
  4917                          dumpjump(CALL, v_disp);                   ! plants fixup for the tag
  4918                      %finish
  4919                  %finish
  4920                  ! adjust the stack
  4921                  %if v_extra # 0 %then dumpri(ADD, SP, v_extra)
  4922                  %if v_type = 0 %start;           ! not function or map
  4923                      pop rel
  4924                  %else;                           ! Here we've got a result
  4925                      v_scope = 0;                 ! Result is local, even if the function wasn't
  4926                      %if v_type = string %and v_aform = 8 %start
  4927                          v_base = BP;             ! String result will have been copied back here
  4928                          v_disp = t
  4929                          v_form = V in S
  4930                      %else
  4931                          %if (v_type = real %or v_type = lreal) %and v_aform = 8 %start
  4932                              ! Floating result will be on the FPU stack
  4933                              v_form = V in R
  4934                              v_base = FR0; claim(FR0)
  4935                              fpu stack = 1
  4936                          %else
  4937                              v_base = AX;               ! Result is always in AX
  4938                              v_disp = 0;                ! Clear this for MAP results
  4939                              claim(AX)
  4940                          %finish
  4941                      %finish
  4942                  %finish
  4943  			%finish
  4944          %end;            !  Compile Call
  4945  
  4946          !                                              >> COMPILE FOR <<
  4947          %routine  compile for( %integer lab )
  4948              %record(stackfm)%name  cv, iv, inc, fv
  4949              %integer  n
  4950  
  4951              ! Lock a value into a temporary to make sure it is invariant
  4952              %routine  stab(%record(stackfm)%name  v,  %integer  type)
  4953                  %integer  t,r
  4954                  %return %if const(v)#0
  4955                  loadreg(v,any);  r = v_base
  4956                  t = getwork(word size)
  4957                  dumpmr(MOV, BP,t, 0, r)
  4958                  v_base = BP; v_disp = t; v_scope = 0
  4959                  v_type = type;  v_form = V in S
  4960                  release(r)
  4961              %end
  4962  
  4963              iv == top
  4964              fv == stack(stp-1)
  4965              inc == stack(stp-2)
  4966              cv == stack(stp-3)
  4967  
  4968              stab(fv,integer)
  4969              stab(inc,integer)
  4970  
  4971              ! Check control variable is a plain value - otherwise save a pointer to it
  4972              ! in case it changes
  4973              %if cv_form # v in s %or (0 < cv_base <= DI %and cv_base # BP) %start
  4974                  n = cv_type
  4975                  amap(cv)
  4976                  stab(cv, n)
  4977                  cv_form = a in s
  4978              %finish
  4979     
  4980              push copy(cv)
  4981              push copy(iv)
  4982              push copy(inc);
  4983              Operation(SUBx)
  4984              assign(1);        ! cv = iv - inc
  4985  
  4986              define label(lab)
  4987              pop stack;! zap unwanted copy of IV
  4988  
  4989              ! Stack is now  top->[FV[INC[CV 
  4990              push copy(cv);		! in case compare alters it
  4991              compare(top, fv)
  4992              jump to(lab+1, JE, 1)
  4993              invert = 0; ! because the compare might have flipped this (N/A for JE)
  4994              ! Stack is now top->[CV'[FV[INC[CV where CV' is a register copy of CV
  4995              release(fv_base); fv = top;	! trash FV and make a copy of CV' in that slot
  4996              pop stack;							! discard the top copy
  4997              ! stack is now top->[CV'[INC[CV
  4998              Operation(ADDx)
  4999              assign(1)
  5000          %end;            ! for
  5001  
  5002  		%routine End of Block
  5003  			%if amode >= 0 %start; ! No return code for %endoffile
  5004  				dump return
  5005  				dumpstaticfill(staticalloc, frame+(level*word size), events, evep, evfrom);   ! don't include the display
  5006  			%finish
  5007  		%end
  5008  
  5009  		%routine Compile Begin
  5010  			decvar == begin
  5011              decvar_disp = new tag
  5012  			otype = 0
  5013              spec = 0
  5014              potype = 0
  5015  			%if level # 0 %start;  ! not outermost %begin
  5016  				push const(decvar_disp)
  5017  				top_type = 0;      ! it's not a function!
  5018  				compile call(top)
  5019  				skip proc = new tag
  5020  				dump jump(JMP, skip proc)
  5021  				dump label(decvar_disp);  ! this is where to call
  5022  			%finish
  5023  			assemble(0,labs,names)
  5024  			%if level # 0 %start
  5025  				dump label(skip proc)
  5026  				last skip = next cad
  5027  				Uncond Jump = 0
  5028  			%finish
  5029  		%end
  5030  
  5031          ! Utility routine used when dumping initialisers for OWNs
  5032          ! Note non-portable use of real values
  5033          %routine  adump
  5034              %integer i
  5035              %real		rv32
  5036              %switch ot(0:6)
  5037  
  5038              ->ot(own type)
  5039  ot(general):
  5040              abort("General Own?")
  5041  ot(integer):
  5042              gput(ownval); -> done
  5043  ot(real):
  5044              rv32 = rvalue;  ! because our default variable is a 64 bit long real
  5045              %for i = 0,1,3 %cycle
  5046  				gbyte(byteinteger(addr(rv32)+i))
  5047  			%repeat
  5048  			-> done
  5049  ot(string):
  5050              %if current string(0)+1 > data size %start;	! check for overflow
  5051  				! String constant too long - warn and truncate
  5052  				warn(5);  current string(0) = data size-1
  5053  			%finish
  5054  
  5055  			%for i = 0,1,data size-1 %cycle
  5056  				gbyte(current string(i))
  5057  			%repeat
  5058  			-> done
  5059  ot(record):
  5060              %for i = 1,1,data size %cycle
  5061  				gbyte(0)
  5062  			%repeat
  5063  			-> done
  5064  ot(byte):
  5065              gbyte(ownval); -> done
  5066  ot(lreal):
  5067              %for i = 0,1,7 %cycle
  5068  				gbyte(byteinteger(addr(rvalue)+i))
  5069  			%repeat
  5070  			-> done
  5071  done:
  5072          %end
  5073  
  5074          %integerfn user label(%integer lab)
  5075              %record(varfm)%name v
  5076              %if lab > names %start
  5077                  names = lab
  5078                  v == var(lab)
  5079                  v = 0
  5080                  v_form = pgm label
  5081                  v_disp = new tag
  5082                  %result = v_disp
  5083              %finish
  5084              %result = var(lab)_disp
  5085          %end
  5086  
  5087  		%routine Compare Double
  5088  			LHS == stack(stp-1)
  5089  			RHS == top
  5090  			loadreg(rhs, any)
  5091  			! We happen to know that Compare loads the left parameter in a register.
  5092  			! We've already got RHS in a register, so we flip the LHS and RHS to the
  5093  			! comparison and set Invert accordingly
  5094  			compare(rhs, lhs)
  5095  			invert = 1
  5096  			! release LH and then overwrite it with RH
  5097  			release(lhs_base)
  5098  			lhs = rhs
  5099  			pop stack
  5100  		%end
  5101  
  5102  		%routine Compare Values
  5103  			LHS == stack(stp-1)
  5104  			RHS == top
  5105  			compare(lhs,rhs)
  5106  			pop rel
  5107  			pop rel
  5108  		%end
  5109  
  5110  		%routine Compare Addresses
  5111  			amap(top);
  5112  			amap(stack(stp-1));                  ! Now do same as compare values
  5113  			Compare Values
  5114  		%end
  5115  
  5116  		%routine Define Compiler Label( %integer label)
  5117  			%if label = 0 %start
  5118  				dump label(skipproc)
  5119  				last skip = next cad
  5120  				Uncond Jump = 0
  5121  			%else
  5122  				define label( label );
  5123  			%finish
  5124  		%end
  5125  
  5126  		%routine Init( %integer N )
  5127  			! N = Number of values to assign
  5128  			%integer j
  5129  			%if stp # 0 %start;     ! Value supplied?
  5130  				own val = top_disp
  5131  				%if own type = real %or own type = lreal %start
  5132  					rvalue = own val %if top_type = integer;  ! copy integer supplied into floater
  5133  				%finish
  5134  				pop stack
  5135  			%else;            ! initialise to default pattern
  5136  				ownval = 0
  5137  				current string(0) = 0;     ! in case it's a string
  5138  			%finish
  5139  
  5140  			%if own form = array %or own form = name array %start
  5141  				adump %for j = 1,1,N
  5142  			%else
  5143  				%if otype = 0 %start ;   ! %const .... %name
  5144  !					Abort("Constant Name");
  5145  					! JDM attempt to allow assignment of %const ... %name
  5146  					decvar_scope = COT
  5147  					decvar_level = 0
  5148  					decvar_disp = own val
  5149  				%else
  5150  					! non-array normal variables
  5151  					decvar_level = 0
  5152  					%if otype = con %start
  5153  						! constant - must be string or real type, because
  5154  						! const integers are substituted by value in Pass 1
  5155  						! Constant strings and reals are treated as literals
  5156  						decvar_scope = COT
  5157  						%if own type = string %start
  5158  							decvar_disp = getcots(current string)
  5159  						%else
  5160  							%if own type = real %or own type = lreal %start
  5161  								! constant reals are put in the COT.  Depending on how
  5162  								! the value was formed, ReadReal may have already planted this.
  5163  								! Not to worry, because "real constant" will find it again.
  5164  								decvar_disp = getcotdouble(rvalue)
  5165  							%else
  5166  								abort("Init?")
  5167  							%finish
  5168  						%finish
  5169  					%else
  5170  						! must be %own or %external - use adump to put it in DATA segment
  5171  						decvar_scope = DATA
  5172  						decvar_disp = datatp
  5173  						adump
  5174  					%finish
  5175  				%finish
  5176  			%finish
  5177  		%end
  5178  
  5179  		%routine User Jump ( %integer label )
  5180  			dumpjump(JMP, user label( label ))
  5181  		%end
  5182  
  5183  		%routine Define User Label( %integer label )
  5184  			dump label(user label( label ))
  5185  		%end
  5186  
  5187  		%routine Return( %integer mode)
  5188  			%integer i
  5189  
  5190  			%if mode = False %start
  5191  				dumpri(MOV, AX, 0)
  5192  			%finish
  5193  
  5194  			%if mode = True %start
  5195  				dumpri(MOV, AX, -1)
  5196  			%finish
  5197  
  5198  			%if mode = Map %start
  5199  				amap(top)
  5200  				loadreg(top, AX)
  5201  				pop rel
  5202  			%finish
  5203  
  5204  			%if mode = Fn %start
  5205  				%if procvar_type = integer %start
  5206  					loadreg(top, AX)
  5207  					pop rel
  5208  				%else
  5209  					%if procvar_type = real %or procvar_type = lreal %start
  5210  						! Floating point results are put into store, and AX contains
  5211  						! the address
  5212  						! JDM - No, not for 32-bit code for IA-32 architecture ABI
  5213  						! JDM - floating point results go onto the floating point stack in ST(0)
  5214  						! JDM - that is the returned floating point stack should only be 1 deep
  5215  						! JDM: loadreg(top,anyf) should push the result onto the floating point stack
  5216  						loadreg(top, anyf);
  5217  						pop rel
  5218  					%else ; ! string or record - pass back through the hidden parameter
  5219  						push copy(top);               ! Make a copy of the thing on top
  5220  						lhs == stack(stp-1);       ! point to the (now spare) next item
  5221  						lhs_type = procvar_type;   ! and make it look like a destination
  5222  						lhs_size = procvar_size
  5223  						lhs_format = procvar_format
  5224  						lhs_base = BP
  5225  						lhs_disp = word size * 2;  ! At the offset of the last parameter
  5226  						lhs_form = a in s
  5227  						assign(1)
  5228  					%finish
  5229  				%finish
  5230  			%finish
  5231  
  5232  			%if mode = Routine %start
  5233  				! no need to do anything special
  5234  			%finish
  5235  
  5236  			dump return
  5237  		%end
?I unused
  5238  
  5239  		%routine Dimension( %integer dim, n )
  5240  			%integer i,j
  5241  
  5242  			! Validate the ICODE Parameters
  5243  			abort("Array Dim") %unless 0 < dim < 6
  5244  
  5245  			%if in params # 0 %start;         ! Array in record
  5246  				parms = parms+n
  5247  				vub = top_disp; pop stack
  5248  				vlb = top_disp; pop stack
  5249  				abort("Array Bounds") %if vlb > vub
  5250  				dv = set dope vector
  5251  			%else
  5252  				names = names-n
  5253  				! Now we need to plant code to manufacture a dope vector
  5254  				frame = (frame - ((dim * (2 * word size))+(2 * word size)))&(\align);  ! space for :Dim:<bound pairs>:DataSize:
  5255  				dv = frame
  5256  				! First store the dimension
  5257  				dumpmi(MOV, BP, dv, 0, dim)
  5258  				! And the data size is also constant
  5259  				dumpmi(MOV, BP, dv + (dim * (2 * word size)) + word size, 0, data size)
  5260  				! Now the bounds
  5261  				j = 0;                    ! points to before the first stack value
  5262  				%for i=1,1,dim*2 %cycle
  5263  					j = j + 1; lhs == stack(j)
  5264  					%if lhs_form = constant %start
  5265  						dumpmi(MOV, BP, dv + (i*word size), 0, lhs_disp)
  5266  					%else
  5267  						loadreg(lhs, any)
  5268  						dumpmr(MOV, BP, dv + (i*word size), 0, lhs_base)
  5269  					%finish
  5270  				%repeat
  5271  				! Now we need to allocate the space for the array
  5272  				%if dim > 1 %or control & check array # 0 %start
  5273  					! Do it with the PERM
  5274  					%while stp # 0 %cycle
  5275  						pop rel; ! get rid of all the bounds - they are in the DV already
  5276  					%repeat
  5277  					dumprm(LEA, AX, BP, dv, 0)
  5278  					dumpur(PUSH, AX)
  5279  					perm(adef, 1)
  5280  					! We now need to make our result match the inline version
  5281  					! by putting AX and DX into stacklike variables
  5282  					push const(0); lhs == top
  5283  					push const(0); rhs == top
  5284  					lhs_base = AX; lhs_form = V in R; claim(AX)
  5285  					rhs_base = DX; rhs_form = V in R; claim(DX)
  5286  					pop stack
  5287  					pop stack
  5288  				%else
  5289  					push const(1)
  5290  					Operation(ADDx)
  5291  					push const(data size)
  5292  					Operation(MULx)
  5293  					push copy(stack(stp-1));   ! suck up the lower bound
  5294  					push const(data size)
  5295  					Operation(MULx)
  5296  					! top is now the lower bound, next is the upper, and a bogus copy of lb is next
  5297  					loadreg(top, any);   ! Make sure this is in a register
  5298  					lhs == top;          ! Point to it
  5299  					pop stack;           ! and drop (without release) this copy
  5300  					loadreg(top, any);   ! This is now UB - load it in a register as well
  5301  					rhs == top;          ! Point to it
  5302  					pop stack;           ! and keep RHS (Upper)
  5303  					pop stack;           ! dump the bogus lb
  5304  				%finish
  5305  				! Note - there are 4 GP registers, and we're going to need them ALL here
  5306  				t = gp reg;             ! get a working register for the dope vector address
  5307  				dumprm(LEA, t, BP, dv, 0); ! load it
  5308  				dv = t; claim(dv);      ! use this to hold the register number
  5309  				t = gp reg;             ! the last one! (which we don't claim, 'cos we can't lose it)
  5310  				dumprr(MOV, t, SP);	   ! working copy of SP so that real SP is always "OK"
  5311  			%finish
  5312  
  5313  			%for i = 1,1,n %cycle
  5314  				decvar_dim = dim
  5315  				%if in params = 0 %start;      !  array not in record
  5316  					names = names+1;  decvar == var(names)
  5317  					decvar_level = level
  5318  					frame = frame - (word size * 2);  ! 2-word header
  5319  					decvar_disp = frame
  5320  					%if decvar_form = array %or decvar_form = namearray %then decvar_form = decvar_form + 1;         ! force arrayname
  5321  					dumprr(SUB, t, rhs_base);
  5322  					dumpmr(MOV, BP, frame, 0, t);             ! store a(0) address
  5323  					dumpmr(MOV, BP, frame + word size, 0, dv);! store dope vector pointer
  5324  					dumprr(ADD, t, lhs_base);
  5325  				%else;          ! array-in-record
  5326  					parms = parms-1;  decvar == var(parms)
  5327  					decvar_disp = frame - vlb
  5328  					frame = frame + vub; ! noting that Set Dope Vector has changed VUB to the array size
  5329  					decvar_pbase = dv
  5330  				%finish
  5331  			%repeat
  5332  
  5333  			%if in params = 0 %start
  5334  				! We need to keep the stack pointer word aligned - 8086's run faster that way,
  5335  				! and more importantly, Pentiums throw an exception if you don't!
  5336  				%if data size & align # 0 %then dumpri(AND, t, \align)
  5337  				dumprr(MOV,SP,t)
  5338  				release(lhs_base)
  5339  				release(rhs_base)
  5340  				release(dv)
  5341  			%finish
  5342  		%end
  5343  
  5344  		%routine Update Line( %integer line)
  5345  			current line = line
  5346  			abort("Stack?") %if stp # 0
  5347  			abort("Claimed") %if claimed # 0
  5348  			! Pass1 sends the line number multiple times if there's more than
  5349  			! one statement per line - for debugging we only want "real" line numbers
  5350  			%if echo line < current line %start
  5351  				dump line number(current line)
  5352  				%while echo line < current line %cycle
  5353  					echo source line
  5354  				%repeat
  5355  			%finish
  5356  		%end
  5357  
  5358  		%routine Switch Jump( %integer switch id )
  5359  			v == var( switch id )
  5360  			push const(word size);  Operation(MULx);        ! subscript X WordSize
  5361  			loadreg(top, anyp)
  5362  			dumpum(JMP, SWT!top_base, v_disp * word size, 0);	! swtab is word-size
  5363  			pop rel
  5364  			uncond jump = next cad
  5365  		%end
  5366  
  5367  		%routine Set Record Format( %integer format id )
  5368  			top_format = format id
  5369  			top_type   = record
  5370  		%end
  5371  
  5372  		%routine Switch Label( %integer switch label )
  5373  			v == var( switch label )
  5374  			uncond jump = 0
  5375  			j = top_disp; pop stack
  5376  			t = new tag
  5377  			dumplabel(t);
  5378  			swtab(v_disp+j) = t;
  5379  		%end
  5380  
  5381  		%routine Constant Bounds
  5382  			vub = top_disp; pop stack
  5383  			vlb = top_disp; pop stack
  5384  		%end
  5385  
  5386  		%routine Internal Handler ( %integer id )
  5387  			push const(0) %while stp < 2
  5388  			push const( id )
  5389  			loadreg(top, any); dumpur(PUSH, top_base); pop rel
  5390  			loadreg(top, any); dumpur(PUSH, top_base); pop rel
  5391  			loadreg(top, any); dumpur(PUSH, top_base); pop rel
  5392  			perm(signal, 3)
  5393  			uncond jump = next cad %if id # -1;     ! %monitor will return
  5394  		%end
  5395  
  5396  		%routine Signal Event( %integer event id )
  5397  			Internal Handler ( event id )
  5398  		%end
  5399  
  5400  		%routine Monitor
  5401  			Internal Handler ( -1 )
  5402  		%end
  5403  
  5404  		%routine SelectField( %integer field index )
  5405  			! Contrary to earlier iCode versions, this one seems to use 'n' for
  5406  			! both normal record member access and alternate formats?
  5407  			lhs == top;										! Points to the base record
  5408  			Stack Var(var(top_format)_pbase - field index);	! Push descriptor for the i-th member
  5409  
  5410  			%if top_aform # recordformat %start;   !  not record format - must be a member
  5411  				%if lhs_form = v in s %or lhs_form = VinRec %start
  5412  					top_disp = top_disp + lhs_disp
  5413  					lhs_form = lhs_form - v in s + top_form
  5414  				%else
  5415  					%if lhs_form = a in rec %start
  5416  						lhs_form = VinRec;  lhs_type = integer
  5417  						loadreg(lhs,any)
  5418  						lhs_form = top_form
  5419  					%else
  5420  						%if lhs_form <= VinR %start
  5421  							lhs_form = top_form;    ! ????
  5422  						%else;		! A in S
  5423  							lhs_extra = lhs_disp
  5424  							lhs_form = top_form + 3
  5425  						%finish
  5426  					%finish
  5427  				%finish
  5428  				lhs_disp = top_disp
  5429  				lhs_type = top_type
  5430  				lhs_aform = top_aform
  5431  				lhs_dim = top_dim
  5432  			%finish
  5433  			lhs_size = top_size;  lhs_format = top_format
  5434  			pop stack
  5435  		%end
  5436  
  5437  		%routine EventTrap( %integer anevent, evfrom )
  5438  			! events: Events to trap (then comma)
  5439  			! evfrom: Label to skip to
  5440  			%integer temp
  5441  
  5442  			events = anevent
  5443  			temp = getwork(wordsize);	    ! get a temp location for SP
  5444  			dumpmr(MOV, BP, temp, 0, SP);	! because our signaller doesn't restore it
  5445  			jump to(evfrom, JMP, 1);	    ! go there now
  5446  			! We need to make EVFROM into a label ID that pass 3 will recognise
  5447  			! to build the trap table, so Jump To sets a variable we pick up here...
  5448  			evfrom = J Tag
  5449  			evep = new tag;				    ! tag for the event body entry point
  5450  			dump label(evep);			    ! which is here
  5451  			dumprm(MOV, SP, BP, temp, 0);	! First thing we do is restore SP
  5452  		%end
  5453  
  5454  		%routine DoubleOp( %integer opr )
  5455  			%integer j,t
  5456  
  5457  			lhs == stack(stp-1)
  5458  			t = lhs_type;
  5459  			j = lhs_size
  5460  			j = j+1 %if t = string
  5461  			amap(lhs)
  5462  			abort("++/-- size") %if j = 0
  5463  			push const(j)
  5464  			Operation(MULx)
  5465  			Operation(opr)
  5466  			vmap(top);  top_type = t
  5467  		%end
  5468  
  5469  		%routine Set CD(%integer Value, %integername CD)
  5470              ! JDM set value for the appropriate compiler pass
  5471              ! In this case we are in pass2
  5472  			CD = Value&x'3FFF' %if Value&x'C000' = (PassId&3)<<14
  5473  		%end
  5474  
  5475  		%predicate Finish Params
  5476  			%integer j
  5477  
  5478  			%true %if amode < 0;            ! end of %record %format defn.
  5479  			%true %if procvar_level = 128;  ! prim routine reference
  5480  
  5481  			! Here it's a real subroutine - copy any parameters to the PARM area
  5482  			%if names > first name %start
  5483                  procvar_pbase = parms;  ! Point one beyond the first parameter
  5484  				frame = (frame + align) & (\align);	! Even up the stack size
  5485  				%if procvar_type = string %and procvar_form = 8 %start
  5486  					frame = frame + word size;  ! string functions have a hidden result parameter
  5487  				%finish
  5488  				procvar_extra = frame;             ! Remember the stack offset
  5489  				procvar_dim = names - first name;  ! and the number of parameters
  5490  				frame = frame + (2 * word size);   ! leave space for return linkage (IP + BP)
  5491  				%for j = first name+1, 1, names %cycle
  5492  					ap == var(j)
  5493  					parms = parms-1;  fp == var(parms)
  5494  					fp = ap
  5495  					! formal parameter base and displacement is implicit (on the stack)
  5496  					fp_level = 0
  5497  					! we also need to adjust the offsets of the actual parameters, because
  5498  					! they were allocated going "forwards", but will be pushed on the stack
  5499  					! "backwards" - that is, the first item passed will end up with the
  5500  					! highest address.  DefineVar has done part of the work for us by tagging
  5501  					! the displacements in the right style, but it can't tell the whole frame
  5502  					! offset, so we calculate the final offsets here...
  5503  					ap_disp = frame - ap_disp
  5504  				%repeat
  5505  				abort("Params") %if parms < names
  5506  			%finish
  5507  			%true %if amode = 2;  ! this was just a spec
  5508  			dumplabel(procvar_disp)
  5509  			static alloc = enter
  5510  			frame = -(level * word size);  ! one word for each display entry
  5511  			%false
  5512  		%end
  5513  
  5514  		%predicate AlternateFormat( %integer N )
  5515  			! Check the ICODE for faults
  5516              ! and abort for any faulty intermediate code
  5517  			abort("Alt Record '".tostring(sym)."'.") %unless (N = 'A') %or (N = 'B') %or (N = 'C')
  5518  
  5519  			%true %if N = 'B';             ! alt end
  5520  
  5521  			%if N = 'A' %start;            ! alt start
  5522  				decvar == procvar
  5523  				assemble(-2,labs,names)
  5524  			%finish
  5525  
  5526  			%if N = 'C' %start
  5527  				! Compile the next alternate - update limit and set frame back to where we started
  5528  				max frame = frame %if frame > max frame
  5529  				frame = old frame
  5530  			%finish
  5531  			%false
  5532  		%end
  5533  
  5534  ! ******************************************
  5535  ! JDM JDM attempt to include the plant icode and machine code icode
  5536          %routine  PLANT
  5537              ! Plant in-line code values (from "*=constant")
  5538              %integer  j
  5539  
  5540              ! We only expect one item on the stack
  5541              abort("Machine Literal") %if (stp <> 1)
  5542  
  5543              %for j = 1, 1, stp %cycle
  5544  ! JDM JDM not sure what next 3 lines do, so commented out
  5545  !                lhs == stacked(j)
  5546  !                word (lhs_disp)
  5547  !                drop (lhs)
  5548  
  5549  
  5550              %repeat
  5551              ! JDM empty the icode stack
  5552              stp = 0
  5553          %end
  5554  
  5555          %string(255) %function get type name( %integer f)
  5556              %string(8) name
  5557              name = "????"
  5558              name = "general" %if (f = 0)
  5559              name = "integer" %if (f = 1)
  5560              name = "real" %if (f = 2)
  5561              name = "string" %if (f = 3)
  5562              name = "record" %if (f = 4)
  5563              name = "byte" %if (f = 5)
  5564              name = "lreal" %if (f = 6)
  5565              %result = name
  5566          %end
  5567  
  5568          %string(255) %function get form name( %integer f )
  5569              %string(24) name
  5570              name = "????"
  5571              %switch n(0:15)
  5572              %label esac
  5573              
  5574              -> n(f & 15)
  5575              n( 0):  name = "void";           -> esac
  5576              n( 1):  name = "simple";         -> esac
  5577              n( 2):  name = "name";           -> esac
  5578              n( 3):  name = "label";          -> esac
  5579              n( 4):  name = "recordformat";   -> esac
  5580              n( 5):  name = "?????";          -> esac
  5581              n( 6):  name = "switch";         -> esac
  5582              n( 7):  name = "routine";        -> esac
  5583              n( 8):  name = "function";       -> esac
  5584              n( 9):  name = "map";            -> esac
  5585              n(10):  name = "predicate";      -> esac
  5586              n(11):  name = "array";          -> esac
  5587              n(12):  name = "arrayname";      -> esac
  5588              n(13):  name = "namearray";      -> esac
  5589              n(14):  name = "namearrayname";  -> esac
  5590              n(15):  name = "?????????????";  -> esac
  5591  
  5592              esac:
  5593              %result = name;
  5594          %end
  5595  
  5596          ! classify the type of the machine code instruction parameter
  5597          %constant %integer     unknown = 0, variable = 1, register = 2, number = 3, mask = 4,    name = 5,  pointer = 6
  5598          ! param type is one of unknown,     variable,     register,     number,     mask,        name,      pointer
  5599          ! param value is       ???,         tag,          reg id,       number,     32-bit mask, integer,   reg id,
  5600          ! param data  is       ???,         tag name,     reg name,     N/A,        N/A,         name,      reg name
  5601          ! param offset is      N/A,         N/A,          N/A,          N/A,        N/A,         N/A,       offset
  5602          !
  5603  
  5604          %routine dump tag var( %integer tag, %string(3) prefix )
  5605  
  5606              print string(" ".prefix."     tag=".itos(tag,0)); newline
  5607              print string(" ".prefix."    name=".var(tag)_idname); newline
  5608              print string(" ".prefix."    type=".itos(var(tag)_type,0)." ".get type name(var(tag)_type)); newline
  5609              print string(" ".prefix."    form=".itos(var(tag)_form,0)." ".get form name(var(tag)_form)); newline
  5610              print string(" ".prefix."   level=".itos(var(tag)_level,0)); newline
  5611              print string(" ".prefix."   scope=".itos(var(tag)_scope,0)); printstring(" ".relocname(var(tag)_scope>>4) );newline
  5612              print string(" ".prefix."    disp=".itos(var(tag)_disp,0)); newline
  5613              print string(" ".prefix." extdisp=".itos(var(tag)_extdisp,0)); newline
  5614              print string(" ".prefix."    size=".itos(var(tag)_size,0)); newline
  5615              print string(" ".prefix."   extra=".itos(var(tag)_extra,0)); newline
  5616              print string(" ".prefix."  format=".itos(var(tag)_format,0)); newline
  5617              print string(" ".prefix."     dim=".itos(var(tag)_dim,0)); newline
  5618              print string(" ".prefix."   pbase=".itos(var(tag)_pbase,0)); newlines(2)
  5619  
  5620          %end
  5621  
  5622          %routine dump parameter( %integer param index, %integer param type, %string(255) param name, %integer param value, param offset )
  5623              %string(255) t
  5624              %integer tag,n
  5625  
  5626              printstring( "Parameter(".itos(param index,0).")='".param name."'"); newline
  5627  
  5628              %if (param type = pointer) %start
  5629  
  5630                  ! dump the pointer data
  5631                  %if (param offset = 0) %start
  5632                      print string(" PTR   id=".itos(param value,0)); newline
  5633                      print string(" PTR name=[".param name."]"); newline
  5634                      print string(" PTR offset=0"); newlines(2)
  5635                  %finish %else %start
  5636                      print string(" PTR   id=".itos(param value,0)); newline
  5637                      print string(" PTR name=[".param name.itos(param offset,0)."]"); newline
  5638                      print string(" PTR offset=".itos(param offset,0)); newlines(2)
  5639                  %finish
  5640  
  5641              %finish %else %if (param type = variable) %start
  5642  
  5643                  ! dump the variable data
  5644                  dump tag var( param value, "VAR" )
  5645  
  5646              %finish %else %if (param type = register) %start
  5647  
  5648                  ! dump the register data
  5649                  print string(" REG   id=".itos(param value,0)); newline
  5650                  print string(" REG name=".param name); newlines(2)
  5651  
  5652              %finish %else %if (param type = number) %start
  5653  
  5654                  ! dump the number data
  5655                  print string(" NUMBER value=".itos(param value,0)); newlines(2)
  5656  
  5657              %finish %else %if (param type = mask) %start
  5658  
  5659                  ! dump the mask data
  5660                  print string(" MASK value=2_".int2ascii(param value,2,0)); newlines(2)
  5661  
  5662              %finish %else %if (param type = name) %start
  5663  
  5664                  ! dump the name data
  5665                  print string(" NAME  name=".param name); newline
  5666                  print string(" NAME value=2_".int2ascii(param value,2,0)); newlines(2)
  5667  
  5668              %finish
  5669  
  5670          %end
?N unused
?TAG unused
?T unused
  5671  
  5672          !                                              >> MACHINE CODE <<
  5673          %routine Machine Code( %string(255) code )
  5674              ! This is meant to insert a machine code fragment into the code stream
  5675              ! For now do nothing with the machine code text
  5676              ! JDM JDM JDM
  5677  
  5678              ! ok, lets go
  5679              ! 1) need to parse the machine code text
  5680              %string(255) s,t,rname
  5681              %string(5) instruction
  5682              %string(255) parameters
  5683              %integer params count
  5684  
  5685              ! ass-u-me that a machine code instruction has at most 8 parameters
  5686              %constant %integer param limit = 8;
  5687  
  5688              ! Remember number of CPU registers (1..register limit)
  5689              %constant %integer register limit = 8
  5690  
  5691              ! A machine code string has the form *op_ item*
  5692              ! where op is an instruction name (a sequence of alphanumeric chars terminated by '_')
  5693              ! An item has one of the forms:
  5694              ! 1) varname  == ' ' BB    (where 0 <= B <= 255  and BB represent a definition tag)
  5695              ! 2) constant == 'N' BBBB  (where 0 <= B <= 255  and BBBB represents a 32-bit signed integer)
  5696              ! 3) text     == B+        (where 128 <= B <= 255 and then convert b = B - 128, so text is an ASCII sequence b+)
  5697              ! and the code string can include the ASCII chars (excluding any varname,constant,text format)
  5698              ! 4) chars    == c*        (where c is one of '<','>','[',']','(',')','#',',')
  5699              !
  5700              ! An instruction can have 0,1,2 parameters separated by a ','
  5701              ! One parameter type is a register mask of form '<' number (',' number)* '>'
  5702              ! This is the ONLY other legal use of a ','
  5703              ! The following defines the legal opcode parameters
  5704              ! 1) register == constant                          (a register index, beware register range)
  5705              ! 2) number   == # constant                    (a 32-bit signed integer)
  5706              ! 3) mask     == '<' register (',' register)* '>'  (a bit set of registers, beware limit on count of registers)
  5707              ! 4) modifier == text number
  5708              ! 5) variable == varname, pointer
  5709              ! 6) pointer == '[' register ']', '[' register '+' offset ']', '{ register '-' offset ']'
  5710              ! 7) offset   == constant                          (a 32-bit signed integer)
  5711              !
  5712              ! N.B. a variable could be the value held in varname or the address of varname.
  5713              ! N.B. register always refers to its value, but pointer becomes an address
  5714              !
  5715              ! Legal Intel 386 instruction formats
  5716              ! The modifier, mask parameters are unused
  5717              ! No-op instruction
  5718              ! *op_
  5719              !
  5720              ! One-op instruction
  5721              ! *op_ register
  5722              ! *op_ number
  5723              ! *op_ variable
  5724              !
  5725              ! Two-op MOV instruction
  5726              ! *op_ register ',' register2  == register := register2
  5727              ! *op_ register ',' number     == register := number
  5728              ! *op_ register ',' variable   == register := variable
  5729              ! *op_ variable ',' register   == variable := register
  5730              ! *op_ variable ',' number     == variable := number
  5731              !
  5732              ! Two-op instruction (non-MOV instruction)
  5733              ! *op_ register ',' register2  == register := register op register2
  5734              ! *op_ register ',' number     == register := register op number
  5735              ! *op_ register ',' variable   == register := register op variable
  5736              ! *op_ variable ',' register   == variable := variable op register
  5737              ! *op_ variable ',' number     == variable := variable op number
  5738  
  5739              %recordformat paramFm(%string(255) data, %integer scomma,pcomma,start,end, %string(255) param name, %integer param type,param value, param offset)
  5740              %record(paramFm)%array params(1:param limit)
  5741  
  5742              ! JDM being lazy I created a dual purpose list to map
  5743              ! op (NOP:JMP) to a corresponding opX
  5744              ! op (NOP:JMP) to a text version of opX
  5745              
  5746              ! This list maps opId to internal opX
  5747              %constant %integer %array opGenericId(NOP:JMP) =
  5748+                   -1,   -1,    -1,     -1,     -1,     -1,     -1,   NEGx,
  5749+             {    NOP,  CWD,   RET,   SAHF,  LEAVE,    DEC,    INC,    NEG, }
  5750+                  NOTx,     POP,    PUSH,      -1,      -1,      -1,      -1,    ADDx,
  5751+             {    NOT,  POP,  PUSH,    LEA,    MOV,   XCHG,    ADC,    ADD, }
  5752+                 ANDx,   -1,   ORx,   SUBx,   XORx,   LSHx,   RSHx,   DIVx,
  5753+             {    AND,  CMP,    OR,    SUB,    XOR,    SHL,    SHR,   IDIV, }
  5754+                 MULx,   -1,    -1,     -1,     -1,     -1,     -1,     -1,
  5755+             {   IMUL, CALL,    JE,    JNE,     JG,    JGE,     JL,    JLE, }
  5756+                   -1,   -1,    -1,     -1,     -1
  5757              {     JA,  JAE,    JB,    JBE,    JMP }
  5758  
  5759              ! This list maps opId to internal opX name
  5760              %constant %string(5) %array opGenericName(NOP:JMP) =
  5761+                 "NOP",   "CWD",   "RET",  "SAHF", "LEAVE",   "DEC",   "INC",  "NEGx",
  5762+                 "NOT",   "POP",  "PUSH",   "LEA",   "MOV",  "XCHG",   "ADC",   "ADD",
  5763+                 "AND",   "CMP",    "OR",   "SUB",   "XOR",   "SHL",   "SHR",  "IDIV",
  5764+                "IMUL",  "CALL",    "JE",   "JNE",    "JG",   "JGE",    "JL",   "JLE",
  5765+                  "JA",   "JAE",    "JB",   "JBE",   "JMP"
  5766  
  5767              %string(255) varname
  5768              %byte ch
  5769              %string(5) opNameX
  5770              %integer i,j,k,n,plen,tag,rval,opId,opIdx
  5771              %byte inrbflag,insbflag,inabflag,hashflag,plusFlag,minusFlag
  5772              %switch c(0:127)
  5773              %label esac, default
  5774              %integer start,end
  5775  
  5776              %if ((diagnose&mcode level A) # 0) %start
  5777                  selectoutput(listout)
  5778                  newline
  5779              %finish
  5780  
  5781              code -> instruction.("_").parameters
  5782  
  5783              s = ""
  5784  
  5785              %if (parameters # "") %start
  5786                  ! parameters is a non-empty string so we ass-u-me at least one parameter
  5787                  params count = 1
  5788                  plen = length(parameters);
  5789                  inrbFlag = 0; ! not inside round bracket sequence
  5790                  insbFlag = 0; ! not inside square bracket sequence
  5791                  inabFlag = 0; ! not inside angle bracket sequence
  5792                  hashFlag = 0; ! not expecting a number to follow
  5793  
  5794                  i = 1;
  5795                  %while (i <= plen) %cycle
  5796  
  5797                      ch = charno( parameters, i)
  5798                      -> c(ch) %if (ch < 128); ! this is an ordinary ASCII char
  5799  
  5800                      ! So, ch > 127, thus this "char" starts a tweaked "name"
  5801                      t = "%"
  5802                      %while (charno(parameters, i) > 127) %cycle
  5803                          ! Append the converted char
  5804                          length(t) = length(t) + 1
  5805                          ! tweak appended "char" to be a legal 7-bit ASCII char
  5806                          charno( t, length(t)) = charno(parameters, i) - 128
  5807                          i = i + 1
  5808                      %repeat
  5809  
  5810                      params( params count )_param type  = name
  5811                      params( params count )_param value = 0; ! value acquired by next N section
  5812  
  5813                      params( params count )_param name  = t
  5814                      s = s.t." "
  5815  
  5816                      -> esac
  5817  
  5818               c(' '):
  5819                      ! a variable/pointer reference is prefixed by a space.
  5820                      n = (charno( parameters, i+1 ) << 8) + charno( parameters, i+2 )
  5821  
  5822                      ! now determine the variable name
  5823                      t = var( n )_idname
  5824  
  5825                      ! remember this parameter is a variable/pointer (and its tag)
  5826                      %if (insbflag = 1) %start
  5827                          params( params count )_param type = pointer
  5828                      %finish %else %start
  5829                          params( params count )_param type = variable
  5830                      %finish
  5831                      params( params count )_param value = n
  5832                      params( params count )_param name = t
  5833                      s = s.t
  5834  
  5835                      i = i + 3
  5836                      -> esac
  5837               c('N'):
  5838                      ! A number is prefixed by an ASCII 'N'
  5839                      n = 0
  5840                      n = n + charno( parameters, i+1 ); n = n << 8
  5841                      n = n + charno( parameters, i+2 ); n = n << 8
  5842                      n = n + charno( parameters, i+3 ); n = n << 8
  5843                      n = n + charno( parameters, i+4 )
  5844  
  5845                      %if (params( params count )_param type  = name) %start
  5846                          ! this number is associated with a "name" (i.e. %shl 4)
  5847                          hashFlag = 0
  5848  
  5849                          ! we have the "name" (i.e %shl)
  5850                          ! but now to get the associated numeric value
  5851                          params( params count )_param value = n
  5852  
  5853                          ! convert number to text
  5854                          %if (n > 127) %start
  5855                              t = "16_".int2ascii( n, 16, 0 )
  5856                          %finish %else %start
  5857                              t = itos( n, 0 )
  5858                          %finish
  5859  
  5860                          ! now to add the associated number to the s string
  5861                          s = s.t
  5862  
  5863                      %finish %else %if (hash flag <> 0) %and (params( params count )_param type = unknown) %start
  5864                          ! hashflag indicates this is a genuine integer
  5865                          hashFlag = 0
  5866  
  5867                          ! remember this parameter is a number
  5868                          params( params count )_param type  = number
  5869                          params( params count )_param value = n
  5870                          params( params count )_param name  = ""
  5871  
  5872                          %if (n > 127) %start
  5873                              t = "16_".int2ascii( n, 16, 0 )
  5874                          %finish %else %start
  5875                              t = itos( n, 0 )
  5876                          %finish
  5877                              
  5878                          s = s.t
  5879                          params( params count )_param name  = t
  5880  
  5881                      %finish %else %if (params( params count )_param type  = mask) %start
  5882  
  5883                          ! Ah, we are between <> == mask
  5884                          ! So we need to update the mask
  5885                          %if (0 < n <= register limit) %start
  5886                              ! ok, legal register mask range
  5887                              k = 1<<(n - 1)
  5888                          %finish %else %if (0 < n <= 32) %start
  5889                              ! oops, bad mask specifier for this CPU
  5890                              k = 1<<(n - 1)
  5891                          %finish %else %start
  5892                              ! oops, even worse! Is this a CPU with > 32 registers.
  5893                              ! we can't fit this mask into a 32-bit integer
  5894                              ! so, we won't try
  5895                              k = 0
  5896                          %finish
  5897  
  5898                          ! add the register flag to the mask
  5899                          params( params count )_param value = params( params count )_param value!k
  5900  
  5901                          ! remember N represents the register number but add the reg name
  5902                          ! Ensure we are referencing a valid register
  5903                          ! Adjust register limit for a specific CPU
  5904                          %if (0 < n <= register limit) %start
  5905                              s = s.regname(n)
  5906                          %finish %else %start
  5907                              s = s."R??"
  5908                          %finish
  5909                              
  5910                      %finish %else %start
  5911                          ! ok this came from a constant integer in the IMP program
  5912                          ! ASS-U-ME that this constant represents a register
  5913                          ! So, replace the number with the register name
  5914                          ! Register name is specific to a processor architecture
  5915                          ! IMP code with embedded assembler should reference a
  5916                          ! register by number.
  5917                          ! The IMP pass2 for that processor should store a mapping
  5918                          ! between "register" number and register name.
  5919                          ! eg Intel eax or ebp
  5920  
  5921                          ! remember this parameter is a variable/pointer (and its tag)
  5922                          %if (insbflag = 1) %start
  5923                              params( params count )_param type = pointer
  5924                          %finish %else %start
  5925                          params( params count )_param type  = register
  5926                          %finish
  5927  
  5928                          %if (plusFlag = 1) %start
  5929                              ! remember this "parameter" is a positives pointer offset
  5930                              params( params count )_param offset = n
  5931                              t = itos( n, 0)
  5932                          %finish %else %if (minusFlag = 1) %start
  5933                              ! remember this "parameter" is a negative pointer offset
  5934                              params( params count )_param offset = -n
  5935                              !however, negative sign (and or #) already output
  5936                              t = itos( n, 0)
  5937                          %finish %else %start
  5938                              ! remember this parameter is a register
  5939                          	params( params count )_param value = n
  5940  
  5941  	                        ! Ensure we are referencing a valid register
  5942      	                    ! Adjust register limit for a specific CPU
  5943          	                %if (0 < n <= register limit) %start
  5944              	                t = regname(n)
  5945                  	        %finish %else %start
  5946                      	        t = "R??"
  5947                          	%finish
  5948  
  5949                              params( params count )_param name  = t
  5950                          %finish
  5951  
  5952                          s = s.t
  5953                      %finish
  5954                      i = i + 5
  5955                      -> esac
  5956  
  5957               c('#'):
  5958                      ! let this char through
  5959                      ! BUT remember # is assumed to prefix a positive number
  5960                      hashFlag = 1
  5961                      -> default
  5962  
  5963               c(','):
  5964                      ! let this char through
  5965                      ! comma separates instruction parameters
  5966                      ! (or values between brackets)
  5967  
  5968                      { ok, check to see if this is a parameter separator }
  5969                      %if ((inabFlag + inrbFlag + insbFlag) = 0) %start
  5970                         { ok, we are not inside one of the "bracket" types }
  5971  
  5972                         ! REMEMBER, the parameter type and value should have been
  5973                         ! determined previously
  5974                         ! note comma location in the s string
  5975                         params(params count)_scomma = length(s) + 1
  5976                         ! note comma location in the parameters string
  5977                         params(params count)_pcomma = i
  5978                         ! beware fence post error
  5979                         ! we are counting fence posts (,)
  5980                         ! and their locations
  5981                         ! So "last" fence post at end of parameters string
  5982  
  5983                         ! we have an additional parameter
  5984                         params count = params count + 1
  5985                         ! BUT set the param type appropriately
  5986                         params( params count )_param type = unknown
  5987                         params( params count )_param offset = 0
  5988  
  5989                      %finish
  5990                      -> default
  5991  
  5992               c('+'):
  5993                      ! pass this char( only allowed between [] brackets
  5994                      plusFlag = 1
  5995                      minusFlag = 0; -> default
  5996                      
  5997               c('-'):
  5998                      ! pass this char( only allowed between [] brackets
  5999                      plusFlag = 0
  6000                      minusFlag = 1; -> default
  6001                      
  6002               c('('):
  6003                      ! pass this char (opening round brackets)
  6004                      inrbFlag = 1; -> default
  6005  
  6006               c(')'):
  6007                      ! pass this char (closing round brackets)
  6008                      inrbFlag = 0; -> default
  6009  
  6010               c('['):
  6011                      ! we are referencing an indirect variable
  6012                      params( params count )_param type = pointer
  6013                      ! initialise the name,value and offset
  6014                      params( params count )_param name  = ""
  6015                      params( params count )_param value = 0
  6016                      params( params count )_param offset = 0
  6017  
  6018                      ! pass this char (opening square brackets)
  6019                      insbFlag = 1; -> default
  6020  
  6021               c(']'):
  6022                      ! pass this char (closing square brackets)
  6023                      plusFlag = 0
  6024                      minusFlag = 0
  6025                      insbFlag = 0; -> default
  6026  
  6027               c('<'):
  6028                      ! We are starting a mask parameter
  6029                      params( params count )_param type  = mask
  6030                      ! initialise the value and name
  6031                      params( params count )_param name  = ""
  6032                      params( params count )_param value = 0
  6033                      params( params count )_param offset = 0
  6034                      ! pass this char (opening angle brackets)
  6035                      inabFlag = 1; -> default
  6036  
  6037               c('>'):
  6038                      ! pass this char (closing angle brackets)
  6039                      inabFlag = 0; -> default
  6040  
  6041              default:
  6042                 c(*):
  6043                      ! pass these chars
  6044                      ! chars > 127 are already dealt with
  6045                      ! So, this deals with remaining chars
  6046                      s = s.tostring( charno( parameters, i) )
  6047                      i = i + 1
  6048                      -> esac
  6049                 esac:
  6050  
  6051                  %repeat
  6052  
  6053              %finish %else %start
  6054                  ! Oh, this instruction has no parameters
  6055                  params count = 0
  6056              %finish
  6057  
  6058              %if (params count # 0) %start
  6059                  ! now to identify each instruction parameter inside the s string
  6060                  %for i = 1,1,params count %cycle
  6061  
  6062                      %if (i = 1) %then params(i)_start = 1 %else params(i)_start = params(i-1)_scomma + 1
  6063                      %if (i = params count) %then params(i)_end = length(s) %else params(i)_end = params(i)_scomma - 1
  6064                      params(i)_data = ""
  6065                      %for j = params(i)_start,1,params(i)_end %cycle
  6066                          params(i)_data = params(i)_data.toString( charno(s,j) )
  6067                      %repeat
  6068  
  6069                  %repeat
  6070              %finish
  6071  
  6072              ! determine the opId for this instruction
  6073              ! set a default "ILLEGAL" value for the opId
  6074              ! Although Intel 386 has opCodes 0..255
  6075              ! the count of opCode names is much less than 255
  6076              ! so, we are safe to set opId and opIdx = 255
  6077              opId = -1
  6078              opIdx = -1
  6079              %for i = NOP,1,JMP %cycle
  6080                  %if (instruction = opGenericName(i)) %start
  6081                      opId = i
  6082                      opIdx = opGenericId(opId)
  6083                      %if (opIdx # -1) %start
  6084                          opNameX = instruction
  6085                      %finish %else %start
  6086                          opNameX = itos(opId,0)
  6087                      %finish
  6088                  %finish
  6089              %repeat
  6090  
  6091              ! We are NOT allowing any floating point instructions
  6092  !            %for i = FILD,1,FLDPI %cycle
  6093  !               %if instruction = flopname(i) %then opId = i
  6094  !            %repeat
  6095  !            %if (opId < FILD) %then instruction = opName(opId) %else instruction = flopName(opId)
  6096             
  6097              ! use short form of %if statement (as an example)
  6098              abort("MCODE has illegal/unknown instruction name") %if (opId = -1)
  6099  
  6100              %if ((diagnose&mcode level A) # 0) %start
  6101                  selectoutput(listout)
  6102                  printstring( "**** START MCODE ****" ); newline
  6103  
  6104                  %if ((diagnose&mcode level D) # 0) %start
  6105                      printstring( "  Raw Instruction text: '".instruction."'_".parameters ); newline
  6106                  %finish
  6107  
  6108                  printstring( "Translated Instruction: '".instruction."' ".s ); newline
  6109                  printstring( "           Instruction: '".instruction."' has ".itos( params count, 0)." parameter")
  6110                  %if (params count # 1) %then printsymbol( 's' )
  6111                  newline
  6112  
  6113                  printstring( "      Instruction OpId: ".itos(opId,0)); newline
  6114                  printstring( "     Instruction OpIdx: ".itos(opIdx,0)); newline
  6115  
  6116                  ! now to identify each instruction parameter inside the s string
  6117                  printstring( "*** start parameters ****" ); newline
  6118  
  6119                  ! Dump any parameters specified
  6120                  %for i = 1,1,params count %cycle
  6121  
  6122                      dump parameter( i, params(i)_param type, params(i)_param name, params(i)_param value, params(i)_param offset )
  6123   
  6124                  %repeat
  6125  
  6126                  printstring( "*** end parameters ****" ); newline
  6127  
  6128                  %comment Add an extra newline to split the above debug code from
  6129                  %comment the following code generation code 
  6130  
  6131                  newline
  6132                  printstring( "**** START CODE GEN **********" )
  6133                  newline
  6134  
  6135              %finish
  6136  
  6137              ! 2) need to interpret parsed code
  6138              %if (params count = 0) %start
  6139                  selectoutput(listout)
  6140                  printstring( "**** Instructions with no parameters not yet implemented" ); newline
  6141              %finish %else %if (params count = 1) %start
  6142  
  6143                  %if (opId # -1) %start
  6144  
  6145                      %if (params(1)_param type = variable) %start
  6146  
  6147                          %if ((diagnose&mcode level A) # 0) %start
  6148                              printstring( instruction." ".params(1)_param name)
  6149                              newline
  6150                          %finish
  6151  
  6152                          Stack Var( params(1)_param value )
  6153                          Operation(opIdx);
  6154  
  6155                      %finish %else %if (params(1)_param type = pointer) %start
  6156  
  6157                          selectoutput(listout)
  6158                          printstring( "Opcode ".instruction." with one parameter can only operate on an address/register ".params(1)_param name ); newline
  6159                          abort( "Opcode ".instruction." with one parameter can only operate on an address/register ".params(1)_param name )
  6160  
  6161                      %finish %else %if (params(1)_param type = register) %start
  6162  
  6163                          %if ((diagnose&mcode level A) # 0) %start
  6164                              printstring( instruction." ".params(1)_param name)
  6165                              newline
  6166                          %finish
  6167  
  6168                          dumpur(opId, params(1)_param value)
  6169  
  6170                      %finish %else %start
  6171                          abort( "Opcode ".instruction." is attempting to operate on unexpected location ".params(1)_param name )
  6172                      %finish
  6173                  %finish %else %start
  6174                      abort( "Attempting to apply unknown opcode ".instruction )
  6175                  %finish
  6176  
  6177              %finish %else %if (params count = 2) %start
  6178  
  6179                  ! 3) output the implied code fragment
  6180                  %if (opId = MOV) %start
  6181                      %if (params(1)_param type = variable) %start
  6182  
  6183                          %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  6184  
  6185                              selectoutput(listout)
  6186                              printstring(" ILLEGAL PARAMETER COMBINATION"); newline
  6187                              printstring(" ILLEGAL ADDRESSING MODE for Intel assembler"); newline
  6188                              printstring(" No INTEL instruction can have indirect pointers for both source and destination"); newline
  6189  
  6190                          %finish %else %if (params(2)_param type = register) %start
  6191  
  6192                              %if ((diagnose&mcode level A) # 0) %start
  6193                                  printstring("We have a ASSIGN var1,reg2 scenario"); newline
  6194                                  printstring( params(1)_param name." := ".params(2)_param name); newline
  6195                              %finish
  6196  
  6197                              Stack Var( params(1)_param value )
  6198  
  6199                              %if (top_type = general) %or (top_type = integer) %or (top_type = byte) %or (top_type = record) %start
  6200                                  storeReg( top, params(2)_param value )
  6201                              %finish %else %start
  6202                                  abort( "Attempting to store reg ".params(2)_param name." in a non-integer variable" )
  6203                              %finish
  6204  
  6205                              pop rel
  6206  
  6207                          %finish %else %if (params(2)_param type = number) %start
  6208  
  6209                              %if ((diagnose&mcode level A) # 0) %start
  6210                                  printstring("We have an ASSIGN var1,#const2 scenario"); newline
  6211                                  printstring( params(1)_param name." := #".itos(params(2)_param value,0)); newline
  6212                              %finish
  6213  
  6214                              Stack Var( params(1)_param value )
  6215                              Push Const( params(2)_param value )
  6216                              Assign(1);
  6217  
  6218                          %finish %else %start
  6219                              abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  6220                          %finish
  6221  
  6222                      %finish %else %if (params(1)_param type = pointer) %start
  6223  
  6224                          %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  6225  
  6226  	                        selectoutput(listout)
  6227                              printstring(" ILLEGAL PARAMETER COMBINATION"); newline
  6228                              printstring(" ILLEGAL ADDRESSING MODE for Intel assembler"); newline
  6229                              printstring(" No INTEL instruction can have indirect pointers for both source and destination"); newline
  6230  
  6231                          %finish %else %if (params(2)_param type = register) %start
  6232  
  6233                              %if ((diagnose&mcode level A) # 0) %start
  6234                                  printstring("We have a STORE [reg ((+,-) offset)?],reg2 scenario"); newline
  6235                                  printstring( params(1)_param name." := &".params(2)_param name); newline
  6236                              %finish
  6237  
  6238                              dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  6239  
  6240                          %finish %else %if (params(2)_param type = number) %start
  6241  
  6242                              %if ((diagnose&mcode level A) # 0) %start
  6243                                  printstring("We have a STORE [reg ((+,-) offset)?],const2 scenario"); newline
  6244                                  printstring( params(1)_param name." := &".params(2)_param name); newline
  6245                              %finish
  6246  
  6247                              selectoutput(listout)
  6248                              printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  6249                              dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  6250                              printstring(" NOT YET IMPLEMENTED"); newline
  6251  
  6252                          %finish %else %start
  6253                              abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  6254                          %finish
  6255  
  6256                      %finish %else %if (params(1)_param type = register) %start
  6257  
  6258                          %if (params(2)_param type = variable) %start
  6259  
  6260                              %if ((diagnose&mcode level A) # 0) %start
  6261                                  printstring("We have a LOAD reg1,var2 scenario"); newline
  6262                                  printstring( params(1)_param name." := ".params(2)_param name); newline
  6263                              %finish
  6264  
  6265                              Stack Var( params(2)_param value )
  6266                              LoadReg( top, params(1)_param value )
  6267                              pop rel
  6268  
  6269                          %finish %else %if (params(2)_param type = pointer) %start
  6270  
  6271                              %if ((diagnose&mcode level A) # 0) %start
  6272                                  printstring("We have a LOAD reg1,[reg2 ((+,-) offset)?] scenario"); newline
  6273                                  %if (params(2)_param offset = 0) %start
  6274                                      printstring( params(1)_param name." := [".params(2)_param name."]"); newline
  6275                                  %finish %else %start
  6276                                      printstring( params(1)_param name." := [".params(2)_param name.itos(params(2)_param offset,0)."]"); newline
  6277                                  %finish
  6278                              %finish
  6279  
  6280                              dumprm(opId, params(1)_param value, params(2)_param value, params(2)_param offset, 0)
  6281  
  6282                          %finish %else %if (params(2)_param type = register) %start
  6283  
  6284                              %if ((diagnose&mcode level A) # 0) %start
  6285                                  printstring("We have a MOVE reg1,reg2 scenario"); newline
  6286                                  printstring( params(1)_param name." := ".params(2)_param name); newline
  6287                              %finish
  6288  
  6289                              dumprr(opId, params(1)_param value, params(2)_param value )
  6290  
  6291                          %finish %else %if (params(2)_param type = number) %start
  6292  
  6293                              %if ((diagnose&mcode level A) # 0) %start
  6294                                  printstring("We have a LOAD reg1,#const2 scenario"); newline
  6295                                  printstring( params(1)_param name." := #".itos(params(2)_param value,0)); newline
  6296                              %finish
  6297  
  6298                              Push Const( params(2)_param value )
  6299                              LoadReg( top, params(1)_param value )
  6300                              pop rel
  6301  
  6302                          %finish %else %start
  6303                              abort( "Attempting to store unexpected type in register ".params(1)_param name )
  6304                          %finish
  6305                      %finish %else %start
  6306                          abort( "Attempting to ".instruction." into non-variable/register location" )
  6307                      %finish
  6308                  %finish %else %if (opIdx # -1) %start
  6309  
  6310                      %if (params(1)_param type = variable) %start
  6311  
  6312                          %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  6313  
  6314                              selectoutput(listout)
  6315                              printstring(" ILLEGAL PARAMETER COMBINATION"); newline
  6316                              printstring(" ILLEGAL ADDRESSING MODE for Intel assembler"); newline
  6317                              printstring(" No INTEL instruction can have indirect pointers for both source and destination"); newline
  6318  
  6319                          %finish %else %if (params(2)_param type = register) %start
  6320  
  6321                              %if ((diagnose&mcode level A) # 0) %start
  6322                                  printstring("We have a ".instruction." var1,reg2 scenario"); newline
  6323                                  printstring( params(1)_param name." := " )
  6324                                  printstring( params(1)_param name." ".opNameX." ".params(2)_param name)
  6325                              %finish
  6326  
  6327                              Stack Var( params(1)_param value )
  6328                              dumpmr(opId, top_base!top_scope, top_disp, top_extdisp, top_base)
  6329                              pop rel;
  6330  
  6331                          %finish %else %if (params(2)_param type = number) %start
  6332  
  6333                              %if ((diagnose&mcode level A) # 0) %start
  6334                                  printstring("We have a ".instruction." var1,#const2 scenario"); newline
  6335                                  printstring( params(1)_param name." := " )
  6336                                  printstring( params(1)_param name." ".opNameX." #".itos(params(2)_param value,0))
  6337                                  newline
  6338                              %finish
  6339  
  6340                              Stack Var( params(1)_param value )
  6341                              Stack Var( params(1)_param value )
  6342                              Push Const( params(2)_param value )
  6343                              Operation(opIdx);
  6344                              Assign(1);
  6345  
  6346                          %finish %else %start
  6347                              abort( "Opcode ".instruction." is attempting to store unexpected type in variable ".params(1)_param name )
  6348                          %finish
  6349  
  6350                      %finish %else %if (params(1)_param type = pointer) %start
  6351  
  6352                          %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  6353  
  6354             		            selectoutput(listout)
  6355                              printstring(" ILLEGAL PARAMETER COMBINATION"); newline
  6356                              printstring(" ILLEGAL ADDRESSING MODE for Intel assembler"); newline
  6357                              printstring(" No INTEL instruction can have indirect pointers for both source and destination"); newline
  6358  
  6359                          %finish %else %if (params(2)_param type = register) %start
  6360  
  6361                              %if ((diagnose&mcode level A) # 0) %start
  6362                                  printstring("We have a ".instruction." [reg1 ((+,-) offset)?],reg2 scenario"); newline
  6363                                  %if (params(1)_param offset = 0) %start
  6364                                      printstring( "[".params(1)_param name."] := " )
  6365                                      printstring( "[".params(1)_param name."] ".opNameX." ".params(2)_param name)
  6366                                  %finish %else %start
  6367                                      printstring( "[".params(1)_param name.itos(params(1)_param offset,0)."] := " )
  6368                                      printstring( "[".params(1)_param name.itos(params(1)_param offset,0)."] ".opNameX." ".params(2)_param name)
  6369                                  %finish
  6370                 			        newline
  6371                              %finish
  6372  
  6373                              dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  6374  
  6375                          %finish %else %if (params(2)_param type = number) %start
  6376  
  6377                              %if ((diagnose&mcode level A) # 0) %start
  6378                                  printstring("We have a ".instruction." [reg1 ((+,-) offset)?],const2 scenario"); newline
  6379                                  %if (params(1)_param offset = 0) %start
  6380                                      printstring( "[".params(1)_param name."] := " )
  6381                                      printstring( "[".params(1)_param name."] ".opNameX." ".params(2)_param name)
  6382                                  %finish %else %start
  6383                                      printstring( "[".params(1)_param name.itos(params(1)_param offset,0)."] := " )
  6384                                      printstring( "[".params(1)_param name.itos(params(1)_param offset,0)."] ".opNameX." ".params(2)_param name)
  6385                                  %finish
  6386                                  newline
  6387                              %finish
  6388  
  6389                              selectoutput(listout)
  6390                              printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  6391                              dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  6392                              printstring(" NOT YET IMPLEMENTED"); newline
  6393  
  6394                          %finish %else %start
  6395                              abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  6396                          %finish
  6397  
  6398                      %finish %else %if (params(1)_param type = register) %start
  6399  
  6400                          %if (params(2)_param type = variable) %start
  6401  
  6402                              %if ((diagnose&mcode level A) # 0) %start
  6403                                  printstring("We have a ".instruction." reg1,var2 scenario"); newline
  6404                                  printstring( params(1)_param name." := " )
  6405                                  printstring( params(1)_param name." ".opNameX." ".params(2)_param name)
  6406                                  newline
  6407                              %finish
  6408  
  6409                              Stack Var( params(2)_param value )
  6410                              dumprv( opId, params(1)_param value, top)
  6411                              pop rel;
  6412   
  6413                          %finish %else %if (params(2)_param type = pointer) %start
  6414  
  6415                              %if ((diagnose&mcode level A) # 0) %start
  6416                                  printstring("We have a ".instruction." reg1,[reg2 (('+','-')offset)?] scenario"); newline
  6417                                  printstring( params(1)_param name." := " )
  6418                                  printstring( params(1)_param name." ".opNameX." ".params(2)_param name)
  6419                                  newline
  6420                              %finish
  6421  
  6422                              selectoutput(listout)
  6423                              printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  6424                              dumprm(opId, params(1)_param value, params(2)_param value, params(1)_param offset, 0 )
  6425                              printstring(" NOT YET IMPLEMENTED"); newline
  6426  
  6427                          %finish %else %if (params(2)_param type = register) %start
  6428  
  6429                              %if ((diagnose&mcode level A) # 0) %start
  6430                                  printstring("We have a ".instruction." reg1,reg2 scenario"); newline
  6431                                  printstring( params(1)_param name." := " )
  6432                                  printstring( params(1)_param name." ".opNameX." ".params(2)_param name)
  6433                                  newline
  6434                              %finish
  6435  
  6436                              dumprr(opId, params(1)_param value, params(2)_param value )
  6437  
  6438                          %finish %else %if (params(2)_param type = number) %start
  6439  
  6440                              %if ((diagnose&mcode level A) # 0) %start
  6441                                  printstring("We have a ".instruction." reg1,const2 scenario"); newline
  6442                                  printstring( params(1)_param name." := " )
  6443                                  printstring( params(1)_param name." ".opNameX." #".itos(params(2)_param value,0))
  6444                                  newline
  6445                              %finish
  6446  
  6447                              dumpri(opId, params(1)_param value, params(2)_param value )
  6448  
  6449                          %finish %else %start
  6450                              abort( "Opcode ".instruction." is attempting to store unexpected type in register ".params(1)_param name )
  6451                          %finish
  6452                      %finish %else %start
  6453                          abort( "Opcode ".instruction." is attempting to store in unexpected location ".params(1)_param name )
  6454                      %finish
  6455                  %finish %else %start
  6456                      abort( "Attempting to apply unknown opcode ".instruction )
  6457                  %finish
  6458  
  6459              %finish %else %start
  6460                  abort("Opcode ".instruction." has unexpected number ".itos(params count,0)."of parameters.")
  6461              %finish
  6462  
  6463              %if ((diagnose&mcode level A) # 0) %start
  6464                  selectoutput(listout)
  6465                  newline
  6466                  printstring( "**** END   CODE GEN ********" ); newline
  6467                  printstring( "**** END   MCODE ****" ); newlines(2)
  6468              %finish
  6469  
  6470          %end
?END unused
?START unused
?RVAL unused
?TAG unused
?VARNAME unused
?RNAME unused
  6471  ! ******************************************
  6472  
  6473          !--------------------------------------------------------------
  6474          ! Code for ASSEMBLE starts here...
  6475          First Name = Names
  6476          First Label = Labs
  6477          Proc Var == Decvar
  6478          last skip = -1
  6479          old frame = frame
  6480          frame = 0
  6481          events = 0; evep = 0; evfrom = 0
  6482  
  6483          %if amode >= 0 %start;                         ! NOT A RECORDFORMAT
  6484              level = level+1;  abort("Level") %if level > max level %and spec = 0
  6485              worklist(level) = 0
  6486  
  6487              %if amode = 0 %start;              ! %begin block
  6488                  %if level = 1 %start;          ! Initial %begin ?
  6489                      block name = program ip;   ! For stack traceback readability
  6490                      external id = program ep;  ! linkage to program entry
  6491                      otype = external;  potype = otype
  6492                  %else
  6493                      block name = "%begin block"
  6494                  %finish
  6495                  static alloc = enter
  6496                  frame = -(level * word size);          ! 1 word for every display entry
  6497              %finish
  6498          %else
  6499              %if amode = -1 %start;                     ! normal record format
  6500                  ProcVar_pbase = parms;                 ! where our members start
  6501              %else
  6502                  %if amode = -2 %then frame = oldframe; ! alternates start at the current offset
  6503              %finish
  6504              max frame = frame;                         ! start counting space here
  6505          %finish
  6506  
  6507  		!  --- main compilation loop ---
  6508  		%cycle
  6509  			sym = Pending
  6510              read symbol(Pending)
  6511  			%if sym < 33 %or sym > 127 %then %start
  6512  				selectoutput(0)
  6513  				printsymbol('(')
  6514                  write(sym, 1)
  6515                  printsymbol(',')
  6516                  write(Pending, 1)
  6517                  printsymbol(')')
  6518  				abort("Bad I Code")
  6519  			%finish
  6520  			-> c(sym)
  6521  
  6522  c('!'):		Operation(ORx); 					%continue
  6523  c('"'):		CompareDouble;						%continue
  6524  c('#'):		Jump Forward( ReadTag, NE );		%continue
  6525  c('$'):		Define Var( ReadTag, Get Ascii( ',' ), ReadTagComma, ReadTagComma, ReadTag );	%continue
  6526  c('%'):		Operation(XORx);					%continue
  6527  c('&'):		Operation(ANDx);					%continue
  6528  c(''''):	Input String Value( ReadString );	%continue;	! Stack string constant
  6529  c('('):		Jump Forward( ReadTag, LE );		%continue
  6530  c(')'):		Jump Forward( ReadTag, GE );		%continue
  6531  c('*'):		Operation(MULx);					%continue
  6532  c('+'):		Operation(ADDx);					%continue
  6533  c('-'):		Operation(SUBx);					%continue
  6534  c('.'):		Operation(CONCx);					%continue
  6535  c('/'):		Operation(DIVx);					%continue
  6536  c(':'):		Define Compiler Label( ReadTag );	%continue;	! Define compiler label
  6537  c(';'):		End of Block;						%exit
  6538  c('<'):		Jump Forward( ReadTag, LT );		%continue
  6539  c('='):		Jump Forward( ReadTag, EQ );		%continue
  6540  c('>'):		Jump Forward( ReadTag, GT );		%continue
  6541  c('?'):		Compare Values;						%continue;	! Compare values
  6542  c('@'):		Stack Var( ReadTag );				%continue;	! Stack variable descriptor
  6543  c('A'):     Init( ReadTag );					%continue;	! Initialise OWN variable
  6544  c('B'):     Jump Backward( ReadTag );			%continue;	! Backward Jump
  6545  c('C'):     Compare Addresses;					%continue;	! Compare addresses
  6546  c('D'):		Input Real Value( ReadReal );		%continue;	! Stack real constant
  6547  c('E'):		Compile Call(top);					%continue
  6548  c('F'):     Jump Forward( ReadTag, Always );	%continue;	! Forward Jump
  6549  c('G'):		Get Alias Value( ReadString );		%continue;	! Alias for item about to be declared
  6550  c('H'):		Compile Begin;						%continue;	! Start of BEGIN block
  6551  c('I'):		Abort("Pascal?");					!%continue;	! {ESCAPE for Pascal etc.}
  6552  c('J'):		User Jump( ReadTag );				%continue;	! Jump to user label
  6553  c('K'):		Return( False );					%continue;	! %false
  6554  c('L'):		Define User Label( ReadTag );		%continue;	! Define user label
  6555  c('M'):		Return( Map );						%continue;	! MAP result
  6556  c('N'):		Push Const( ReadInteger );			%continue;	! Stack integer constant
  6557  c('O'):		Update Line( ReadTag );				%continue;	! Set line number
  6558  c('P'):		Plant;				                %continue;	! Machine code literal
  6559  c('Q'):		Operation(RDIVx);					%continue
  6560  c('R'):		Return( Routine );					%continue;	! RETURN
  6561  c('S'):		assign(1);							%continue;	! Normal value assignment
  6562  c('T'):		Return( True );						%continue;	! %true
  6563  c('U'):		Operation(NEGx);					%continue
  6564  c('V'):		Return ( Fn );						%continue;	! FN result
  6565  c('W'):		Switch Jump( ReadTag );				%continue;	! Jump to switch
  6566  c('X'):		Operation(EXPx);					%continue
  6567  !'Y' - UNUSED
  6568  c('Z'):		assign(0);							%continue;	! Assign address '=='
  6569  c('['):		Operation(LSHx);					%continue
  6570  c('\'):		Operation(NOTx);					%continue
  6571  c(']'):		Operation(RSHx);					%continue
  6572  c('^'):		Set Record Format( ReadTag);		%continue;	!   {Set Format}
  6573  c('_'):		Switch Label( ReadTag);				%continue;	! Define switch label
  6574  c('a'):		array ref(0);						%continue
  6575  c('b'):		Constant Bounds;					%continue;	! Define constant bounded Dope Vector
  6576  !'c' NOT IMPLEMENTED
  6577  c('d'):		Dimension( ReadTagComma, ReadTag );	%continue;	! dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  6578  c('e'):		Signal Event( ReadTag);				%continue;	! %signal event
  6579  c('f'):     Compile For( ReadTag );				%continue
  6580  c('g'):		Dimension( ReadTagComma, ReadTag );	%continue;	! (different to PSR) dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  6581  c('h'):
  6582  			! compiler op(n)
  6583  !			compiler op(ReadTag)
  6584  			%continue
  6585  c('i'):		array ref(1);						%continue
  6586  c('j'):		assign(2);							%continue;	! JAM transfer
  6587  c('k'):		Jump Forward( ReadTag, FF );		%continue;	! Branch on FALSE (= 0)
  6588  c('l'):		Language Flags = ReadTag;			%continue;	! We currently only support standard IMP - who knows the future
  6589  c('m'):		Monitor;							%continue;	! %monitor
  6590  c('n'):		SelectField( ReadTag );				%continue;	! Select member from record format
  6591  c('o'):		EventTrap( ReadTagComma, ReadTag );	%continue;	! %on %event block
  6592  c('p'):		assign(-1);							%continue;	! Pass a parameter
  6593  c('q'):		DoubleOp( SUBx);					%continue;	!--
  6594  c('r'):		resolve( ReadTag );					%continue
  6595  c('s'):		perm(stop, 0);						%continue;	! %stop
  6596  c('t'):		Jump Forward( ReadTag, JNE );		%continue;	! Branch on TRUE (# 0)
  6597  c('u'):		DoubleOp( ADDx );					%continue;	!++
  6598  c('v'):		Operation(ABSx);					%continue
  6599  c('w'):		MachineCode(Get Ascii( ';' ));	    %continue;	! JDM: allowed call to Machine code
  6600  c('x'):		Operation(REXPx);					%continue
  6601  c('y'):		Set CD( ReadTag, diagnose);			%continue;	! %diagnose n (what about pass3? how do we send to pass3)
  6602  c('z'):		Set CD( ReadTag, control );			%continue;	! %control n
  6603  c('{'):		in params = -1;
  6604  			! this is either a record format, a procedure, or a proc spec;
  6605  			!   - block type was set by decvar to tell us which
  6606  			assemble(block type,labs,names)
  6607  			%continue;! Start of formal parameters
  6608  c('}'):		in params = 0; %exit %if Finish Params; %continue;	! End of formal parameters
  6609  c('~'):		%exit %if AlternateFormat( ReadByte );	%continue;	! alternate record format
  6610  
  6611  C(*):		abort("Bad I Code");				!%continue;	! To catch the sinners!! (that is - an unimplemented iCode)
  6612  		%repeat
  6613   
  6614          %if amode >= 0 %start;         ! end of declarative block
  6615              %while worklist(level) # 0 %cycle
  6616                  worklist(level) = ret gp tag(worklist(level))
  6617              %repeat
  6618              level = level-1
  6619          %else;                        ! end of record format defn
  6620              %if amode = -2 %start;    ! end of alternative only
  6621                  frame = max frame %if max frame > frame;  ! use the longest alternative
  6622                  old frame = frame
  6623              %else
  6624                  frame = (frame+align)&(\align);  ! **** temporary ****
  6625                  procvar_size = frame
  6626              %finish
  6627          %finish
  6628          frame = old frame
  6629  
  6630      %end;  !  assemble
  6631  
  6632  
  6633      !              -------- it all starts here ---------
  6634      ! JDM - Before we do any file I/O we need to get the source file name
  6635      ! (as used to feed the 'source' stream)
  6636      %string(255) the source file name 
  6637      select input( source )
  6638      the source file name = input name
  6639  
  6640      ! JDM - ok, now we can really start
  6641      select input( icode )
  6642      select output( objout ) 
  6643  
  6644      var(0) = 0;              !  for %RECORD(*) . . . . .
  6645      parms = max vars
  6646  
  6647      ! Initialise the GP Tag ASL
  6648      %for i=1,1,Max GP %cycle
  6649          GP Tags(i)_link = i - 1
  6650      %repeat
  6651      gp asl = Max GP
  6652  
  6653      ! Tell the linker our source file name
  6654      dumpsourcename( the source file name );   ! JDM - hopefully not so bogus now!
  6655  
  6656      ! predefine the perms for the linker.  We ignore
  6657      ! the number (j) because we know they are in sequence
  6658      %for i=1,1,lastperm %cycle
  6659          j = externalref(permname(i))
  6660      %repeat
  6661  
  6662      read symbol(Pending);  !  Prime SYM/NEXT pair
  6663      Spec = 0
  6664      decvar == begin
  6665      assemble(-3,0,0)
  6666  
  6667      ! We flush constants
  6668      flush cot
  6669      flush data
  6670      flush switch
  6671  
  6672  %endofprogram
?DUMPRR8 unused
?IFCALL unused
?FPRESULTLOC unused
?NEGATED unused
?DISPLAY unused
?BSS unused
?FDIVR unused
?FSUBR unused
?XCHG unused
?PERMRT unused
?OWN unused
?DH unused
?CH unused
?AH unused
?BL unused
?DL unused
?CHECKUNASS unused
?MCODELEVELB unused
?MCODELEVELC unused

  4996 Statements compiled
