         Edinburgh IMP77 Compiler - Version 8.4

   1  !   Intel 80386 IMP77 compiler second pass
   2  !
   3  ! Copyright 2021 JD McMullin for various enhancements
   4  ! Copyright 2002 NB Information Limited.
   5  !        from an original version probably -
   6  ! Copyright The University of Edinburgh
   7  !        and various contributions 
   8  ! Copyright many other individuals,
   9  !        but most particularly
   10  ! Copyright 1977-1980 Peter Robertson
   11  
   12  ! Version 2.00 - February 2021
   13  !   * Enabled machine code to be embedded (NO floating point implemented)
   14  !
   15  ! Version 1.03 - October 2003
   16  !	* Properly cleaned up GP TAG list at end of a block
   17  !	* Tidied up some constant tables with names
   18  !     (a hangover from the SKIMP version)
   19  !	* Corrected ISWORK to only be true for full-size string work blocks
   20  
   21  %begin
   22  
   23      !SIZE CONSTANTS
   24      %constinteger  max vars  = 1024
   25      %constinteger  max stack = 16
   26      %constinteger  max labs  = 50
   27      %constinteger  max level = 16
   28      %constinteger  Max GP    = 120
   29  
   30      ! SOME WEE ENVIRONMENTAL THINGS
   31      ! Main program internal name
   32      %conststring(12) program ip = "Main Program"
   33  
   34      ! Main program external name
   35      %conststring(8)  program ep = "__impmain"
   36  
   37      ! prefixed to %system routine idents
   38      %conststring(5)  system prefix = "_imp_"
   39  
   40      ! I/O file handles
   41      ! input streams
   42      %constinteger icode   = 1
   43      %constinteger source  = 2
   44      ! output streams
   45      %constinteger report  = 0
   46      %constinteger objout  = 1
   47      %constinteger listout = 2
   48  
   49      ! DIAGNOSE BITS
   50      ! JDM Identify which IMP pass this is
   51      %constinteger  passId = 2
   52  
   53      ! CONTROL BITS
   54      ! The only active check is check array
   55      %constinteger  check capacity = 1
   56      %constinteger  check unass    = 2
   57      %constinteger  check array    = 4
   58      %constinteger  check bits     = check array
   59  
   60      ! REGISTERS - basic register number = actual value + 1
   61      %constinteger  AX = 1
   62      %constinteger  CX = 2
   63      %constinteger  DX = 3
   64      %constinteger  BX = 4
   65      %constinteger  SP = 5
   66      %constinteger  BP = 6
   67      %constinteger  SI = 7
   68      %constinteger  DI = 8
   69  
   70      ! Floating point coprocessor stack registers
   71      %constinteger  FR0	= 9
   72      !%constinteger  FR1	= 10
   73      !%constinteger  FR2	= 11
   74      !%constinteger  FR3	= 12
   75      !%constinteger  FR4	= 13
   76      !%constinteger  FR5	= 14
   77      !%constinteger  FR6	= 15
   78      %constinteger  FR7	= 16
   79  
   80      ! 8 bit registers - actual value + 17
   81      %constinteger	AL	= 17
   82      %constinteger	CL	= 18
   83      %constinteger	DL	= 19
   84      %constinteger	BL	= 20
   85      %constinteger	AH	= 21
   86      %constinteger	CH	= 22
   87      %constinteger	DH	= 23
   88      %constinteger	BH	= 24
   89  
   90      ! Pseudo Registers
   91      %constinteger  any   = 25 { Truly any register }
   92      %constinteger  anyg  = 26 { A "General Purpose" byte accessible register }
   93                                { (AX, BX, CX, DX) }
   94      %constinteger  anyp  = 27 { A pointing register (BX, SI, DI) }
   95      %constinteger  anyf  = 28 { Generally means the top of the 8087 stack }
   96  
   97      ! DATA FORMS
   98  
   99      ! EXTERNAL FORM
  100      %constinteger  simple         = 1
  101      %constinteger  name           = 2
  102      %constinteger  label          = 3
  103      %constinteger  recordformat   = 4
  104      %constinteger  switch         = 6
  105      %constinteger  array          = 11
  106      %constinteger  arrayname      = 12
  107      %constinteger  namearray      = 13
  108      %constinteger  namearrayname  = 14
  109  
  110      ! INTERNAL
  111      %constinteger  constant    = 0
  112      %constinteger  v in r      = 1
  113      %constinteger  av in r     = 2
  114      %constinteger  a in r      = 3
  115      %constinteger  v in s      = 4
  116      %constinteger  av in s     = 5
  117      %constinteger  a in s      = 6
  118      %constinteger  v in rec    = 7
  119      %constinteger  av in rec   = 8
  120      %constinteger  a in rec    = 9
  121      %constinteger  pgm label   = 10
  122  
  123      ! DATA TYPES
  124      %constinteger  general  = 0
  125      %constinteger  integer  = 1
  126      %constinteger  real     = 2
  127      %constinteger  string   = 3
  128      %constinteger  record   = 4
  129      ! Private internal derived types
  130      %constinteger  byte     = 5
  131      %constinteger  short    = 6
  132      %constinteger  long     = 7
  133      %constinteger  lreal    = 8
  134      ! JDM JDM additional datatypes added for use by typeof/sizeof functions
  135      ! They correspond to some of the external forms
  136      %constinteger  tarray   = 9
  137      %constinteger  tlabel   = 10
  138      %constinteger  xarray          = 11
  139      %constinteger  xarrayname      = 12
  140      %constinteger  xnamearray      = 13
  141      %constinteger  xnamearrayname  = 14
  142  
  143      ! JDM JDM vsize and gen map arrays extended to cope with extra
  144      ! type parameters passed to typeof/sizeof internal macro/functions
  145      !   typeof mapped values
  146      !   (originally taken from "The Imp77 Language - A Reference Manual)
  147      !   more mapped values could be added as needed
  148      !
  149      ! code v  name (returned by typeName)
  150      !    0 = "unknown"
  151      !    1 = "integer"
  152      !    2 = "real"
  153      !    3 = "string"
  154      !    4 = "record"
  155      !    5 = "byteinteger"
  156      !    6 = "shortinteger"
  157      !    7 = "longinteger"
  158      !    8 = "longreal"
  159      !    9 = "array"
  160      !   10 = "label"
  161      !    * = "unknown"
  162  
  163      ! size of each of those internal types in bytes
  164      %constbyteintegerarray  vsize(general:xnamearrayname) =
  165+         0,4,4,0,0,1,2,4,8,0,0,0,0,0,0
  166  
  167      ! Define type codes known externally (to pass 3 and user):
  168      ! The extended list of type codes are NOT specified here
  169      %constbyteintegerarray  gen map(general:xnamearrayname) =
  170+         0,1,2,3,4,5,6,7,8,9,10,9,9,9,9
  171  
  172      ! GENERIC STORE ALIGNMENT - ASSUME 80386
  173      %constinteger  align     = 3
  174      %constinteger  word size = 4 { in bytes }
  175  
  176      !OWN INFO
  177      %constinteger  own      = 1
  178      %constinteger  con      = 2
  179      %constinteger  external = 3
  180      %constinteger  system   = 4
  181      %constinteger  dynamic  = 5
  182      %constinteger  primrt   = 6
  183      %constinteger  permrt   = 7
  184  
  185  {Procedure end codes}
  186  
  187  	%constinteger	Map     = -2,
  188+ 					Fn      = -1, { negative value implies stacked result }
  189+ 					Routine =  0,
  190+ 					True    =  1,
  191+ 					False   =  2
  192  
  193      ! PERM ROUTINE INDEXES
  194      %constinteger  iexp   =  1 { Integer Exponent                    }
  195      %constinteger  fexp   =  2 { floating exponent                   }
  196      %constinteger  smove  =  3 { string copy (length checked)        }
  197      %constinteger  sjam   =  4 { string copy (whatever fits)         }
  198      %constinteger  sconc  =  5 { string concatenate (length checked) }
  199      %constinteger  sjconc =  6 { concatenate whatever fits           }
  200      %constinteger  sresln =  7 { string resolution                   }
  201      %constinteger  scomp  =  8 { string compare                      }
  202      %constinteger  aref   =  9 { array access                        }
  203      %constinteger  adef   = 10 { array definition                    }
  204      %constinteger  signal = 11 { %signal                             }
  205      %constinteger  stop   = 12 { %stop                               }
  206      %constinteger  lastperm = stop
  207  
  208      ! and the corresponding linkage names for the perms
  209      %const %string(12)%array permname(1:lastperm)=
  210+     "_IMPIEXP",
  211+     "_IMPFEXP",
  212+     "_IMPSTRCPY",
  213+     "_IMPSTRJAM",
  214+     "_IMPSTRCAT",
  215+     "_IMPSTRJCAT",
  216+     "_IMPSTRRES",
  217+     "_IMPSTRCMP",
  218+     "_IMPAREF",
  219+     "_IMPADEF",
  220+     "_IMPSIGNAL",
  221+     "_IMPSTOP"
  222  
  223      ! Compiler Internal Operations (not to be confused with OpCodes)
  224      %constinteger  ADDx    = 1
  225      %constinteger  SUBx    = 2
  226      %constinteger  MULx    = 3
  227      %constinteger  DIVx    = 4
  228      %constinteger  CONCx   = 5
  229      %constinteger  ANDx    = 6
  230      %constinteger  ORx     = 7
  231      %constinteger  XORx    = 8
  232      %constinteger  LSHx    = 9
  233      %constinteger  RSHx    = 10
  234      %constinteger  REMx    = 11
  235      %constinteger  EXPx    = 12
  236      %constinteger  REXPx   = 13
  237      %constinteger  RDIVx   = 14
  238      %constinteger  NOTx    = 15
  239      %constinteger  NEGx    = 16
  240      %constinteger  ABSx    = 17
  241      %constinteger  unaries = 15
  242  
  243      ! opcode indexes...
  244  
  245      ! simple (no operand) ones first
  246      %constinteger NOP	= 0
  247      %constinteger CWD   = 1
  248      %constinteger RET   = 2
  249      %constinteger SAHF  = 3
  250      %constinteger LEAVE = 4
  251  
  252      ! simple unary math functions
  253      %constinteger DEC = 5
  254      %constinteger INC = 6
  255      %constinteger NEG = 7
  256      %constinteger NOT = 8
  257  
  258      ! simple unary moves
  259      %constinteger POP  = 9
  260      %constinteger PUSH = 10
  261  
  262      ! two operand moves
  263      %constinteger LEA  = 11
  264      %constinteger MOV  = 12
  265      %constinteger XCHG = 13
  266  
  267      ! simple two operand math functions
  268      %constinteger ADC = 14
  269      %constinteger ADD = 15
  270      %constinteger AND = 16
  271      %constinteger CMP = 17
  272      %constinteger OR  = 18
  273      %constinteger SUB = 19
  274      %constinteger XOR = 20
  275      ! slightly more complicated two operand math
  276      %constinteger SHL  = 21
  277      %constinteger SHR  = 22
  278      %constinteger IDIV = 23
  279      %constinteger IMUL = 24
  280  
  281      ! calls and jumps
  282      %constinteger CALL = 25
  283      %constinteger JE   = 26
  284      %constinteger JNE  = 27
  285      %constinteger JG   = 28
  286      %constinteger JGE  = 29
  287      %constinteger JL   = 30
  288      %constinteger JLE  = 31
  289      %constinteger JA   = 32
  290      %constinteger JAE  = 33
  291      %constinteger JB   = 34
  292      %constinteger JBE  = 35
  293      %constinteger JMP  = 36
  294  
  295      ! Floating point instructions - note that these map directly onto
  296      ! 8087 sequences, unlike the generic MOV, ADD style of the base
  297      ! operations for the 8086
  298      %constinteger	FILD	= 37
  299      %constinteger	FLDD	= 38
  300      %constinteger	FLDQ	= 39
  301      %constinteger	FSTI	= 40
  302      %constinteger	FSTD	= 41
  303      %constinteger	FSTQ	= 42
  304      %constinteger	FADD	= 43
  305      %constinteger	FSUB	= 44
  306      %constinteger	FSUBR	= 45
  307      %constinteger	FMUL	= 46
  308      %constinteger	FDIV	= 47
  309      %constinteger	FDIVR	= 48
  310      %constinteger	FCMP	= 49
  311      %constinteger	FCHS	= 50
  312      %constinteger	FABS	= 51
  313      ! Special floating point things
  314      %constinteger	FSTSW	= 52
  315      %constinteger	FLDZ	= 53
  316      %constinteger	FLDPI	= 54
  317  
  318      ! modifiers to memory base for accessing global memory
  319      %constinteger	DATA	= 16_10
  320      %constinteger	COT		= 16_20
  321      %constinteger	BSS		= 16_30
  322      %constinteger	DISPLAY	= 16_40
  323      %constinteger	EXT		= 16_50
  324      %constinteger	SWT		= 16_60
  325      %constinteger	CODE	= 16_70
  326  
  327      ! opcodes
  328      %const %string(5) %array opname(NOP:JMP) =
  329+ 	"NOP", "CWD", "RET", "SAHF", "LEAVE",
  330+ 	"DEC", "INC", "NEG", "NOT",
  331+ 	"POP", "PUSH",
  332+ 	"LEA", "MOV", "XCHG",
  333+ 	"ADC", "ADD", "AND", "CMP", "OR", "SUB", "XOR",
  334+ 	"SHL", "SHR", "IDIV", "IMUL",
  335+ 	"CALL", "JE", "JNE",
  336+     "JG", "JGE", "JL", "JLE",
  337+     "JA", "JAE", "JB", "JBE", "JMP"
  338  
  339      %const %byte %integer %array opvalue(NOP:JMP) =
  340+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9,
  341+ 	16_FF, 16_FF, 16_F7, 16_F7,
  342+ 	16_8F, 16_FF,
  343+ 	16_8B, 16_89, 16_87,		{ LEA is fudged as if it were m <- r, to allow the flip }
  344+ 	16_11, 16_01, 16_21, 16_39, 16_09, 16_29, 16_31,
  345+ 	16_D1, 16_D1, 16_F7, 16_F7,
  346+ 	16_E8, 16_74, 16_75,
  347+     16_7F, 16_7D, 16_7C, 16_7E,
  348+     16_77, 16_73, 16_72, 16_76, 16_EB
  349  
  350      ! 8 bit equivalent opcodes
  351      ! Some are not actually 8 bit, but are added for completenes }
  352      %const %byte %integer %array op8value(NOP:JMP) =
  353+ 	16_90, 16_99, 16_C3, 16_9E, 16_C9, { included for completeness }
  354+ 	16_FE, 16_FE, 16_F6, 16_F6,
  355+ 	16_8F, 16_FF,                      { included for completeness }
  356+ 	16_8B, 16_88, 16_86,                    { LEA is not applicable for 8 bit }
  357+ 	16_10, 16_00, 16_20, 16_38, 16_08, 16_28, 16_30,
  358+ 	16_D0, 16_D0, 16_F6, 16_F6,
  359+ 	16_E8, 16_74, 16_75,
  360+     16_7F, 16_7D, 16_7C, 16_7E,
  361+     16_77, 16_73, 16_72, 16_76, 16_EB  { included for completeness }
  362  
  363  	{Condition codes}
  364  
  365  	{ The "Never" test should never! be used. The others are all used } 
  366  	%constinteger	Never  = 0,
  367+                     EQ     = 1,
  368+                     LT     = 2,
  369+                     LE     = 3,
  370+                     GT     = 4,
  371+                     GE     = 5,
  372+ 					NE     = 6,
  373+                     Always = 7,
  374+                     TT     = 8,
  375+                     FF     = 9
  376  	%constbytearray Reverse(Never:FF) =	Never  {Never},
  377+ 										EQ     {EQ},
  378+ 										GT     {LT},
  379+ 										GE     {LE},
  380+ 										LT     {GT},
  381+ 										LE     {GE},
  382+ 										NE     {NE},
  383+ 										Always {Always},
  384+ 										TT     {TT},
  385+ 										FF     {FF}
  386  	%constbytearray Negated(Never:FF) =	Always {Never},
  387+ 										NE     {EQ},
  388+ 										GE     {LT},
  389+ 										GT     {LE},
  390+ 										LE     {GT},
  391+ 										LT     {GE},
  392+ 										EQ     {NE},
  393+ 										Never  {Always},
  394+ 										FF     {TT},
  395+ 										TT     {FF}
  396  
  397      {Never - This is added for completeness}
  398      %constbytearray TestToOp(Never:FF) =	JMP {Never},
  399+ 											JE  {EQ},
  400+ 											JL  {LT},
  401+ 											JLE {LE},
  402+ 											JG  {GT},
  403+ 											JGE {GE},
  404+ 											JNE {NE},
  405+ 											JMP {Always},
  406+ 											JNE {TT},
  407+ 											JE  {FF}
  408  
  409      {Never - This is added for completeness}
  410      %constbytearray TestToUnsignedOp(Never:FF) =	JMP {Never},
  411+ 													JE  {EQ},
  412+ 													JB  {LT},
  413+ 													JBE {LE},
  414+ 													JA  {GT},
  415+ 													JAE {GE},
  416+ 													JNE {NE},
  417+ 													JMP {Always},
  418+ 													JNE {TT},
  419+ 													JE  {FF}
  420  
  421      ! JDM JDM debug count of iCode instructions
  422      %integer icodeCount = 0
  423      %integer iCodeInst
  424      %integer ShowICode = 0
  425  
  426      ! Standard IMPish data structures
  427  
  428      ! Variables are declared here
  429      ! JDM JDM added idname to remember the IMP variable names
  430      %recordformat  varfm( %string(255) idname,
  431+                           %byteinteger level,
  432+                           %byteinteger type, form, scope, dim,
  433+                           %integer disp, extdisp, 
  434+                                    format, size, pbase, extra )
  435      %record(varfm)%array  var(0:max vars)
  436      %record(varfm)%name   decvar
  437      %record(varfm)        begin
  438  
  439      ! The compiler is stack based
  440      ! JDM JDM changed record format to reference the IMP variable name
  441      ! via var(var no)_idname
  442      ! This saves some memory by not adding 256 bytes per stack entry
  443      %recordformat  stackfm( %integer var no,
  444+                             %byteinteger aform, base,
  445+                             %byteinteger type, form, scope, dim,
  446+                             %integer disp, extdisp,
  447+                                      format, size, pbase, extra )
  448      %record(stackfm)%array  stack(1:max stack)
  449      %record(stackfm)        null
  450      %record(stackfm)%name   top
  451  
  452      ! Pass 1 uses a lame label redefinition that forces us to map
  453      ! label ID's into unique labels for pass 3, using this database
  454      %recordformat LabelFm(%integer id, tag)
  455      %record(LabelFm)%array Labels(1:Max Labs)
  456  
  457      ! most recent Jump tag translation
  458      ! - needed when planting event blocks
  459      %integer J Tag
  460  
  461      ! Status of registers
  462      %ownintegerarray  activity(0:fr7) = 0, 0, 0, 0, 0, -1, -1, 0, 0,
  463+                                         0, 0, 0, 0, 0, 0, 0, 0
  464      %owninteger  claimed = 0
  465  
  466      ! Pointer registers may be pointing to non-local display
  467      ! - we remember them for future use
  468      %ownintegerarray displayhint(AX:DI) = 0, 0, 0, 0, 0, 0, 0, 0
  469  
  470      ! Math Co-processor uses a stack
  471      ! - we remember where it should be with this pointer
  472      %owninteger fpustack = 0
  473  
  474      ! A general purpose workspace resource
  475      %recordformat gp tag(%integer info, addr, flags, link)
  476      %record(gptag)%array gptags(0:Max GP)
  477      %integer gp asl;
  478  
  479      ! Current compiler flags (set by %control statement)
  480      %owninteger control = check bits
  481  
  482      ! Current diagnostic flags (set by %diagnose statement)
  483      %owninteger diagnose = 0
  484  
  485     ! Special directive flags for languages (other than standard imp)
  486  	%owninteger Language Flags = 0
  487  
  488      ! notional code address (not real - pass3 shuffles stuff)
  489      %owninteger nextcad = 0
  490  
  491      ! current contextual level
  492      %owninteger level = 0
  493  
  494      ! Code symbol, next symbol
  495      %integer    sym, Pending
  496  
  497      ! vector lower/upper bound
  498      %integer    vlb,vub
  499  
  500      ! source line number
  501      %owninteger current line = 0
  502  
  503      ! stack pointer
  504      %owninteger stp = 0
  505  
  506      ! current data item size
  507      %integer    data size
  508  
  509      ! current array entry type
  510      %integer    array entry type
  511  
  512      ! local stack frame extent
  513      %owninteger frame = 0
  514  
  515      ! start of parameter stack
  516      %integer    parms
  517  
  518      ! condition inversion flag
  519      %owninteger invert = 0
  520  
  521      ! condition was non-standard (generally FPU compare)
  522      %owninteger compare unsign = 0
  523  
  524      ! address of code hole
  525      %owninteger uncond jump = 0
  526  
  527      ! -1 = RECORDS, 1 = PROCEDURE, 2 = SPEC
  528      %owninteger block type = 1
  529  
  530      ! if # 0, indicates we are inside a parameter list
  531      %owninteger in params = 0
  532  
  533      ! Information about OWNs currently being declared
  534      %integer    otype,
  535+                 owntype,
  536+                 ownform
  537  
  538      ! More about current declaration
  539      %integer    spec,
  540+                 potype
  541  
  542      ! Place to store Real and LReal function results
  543      %owninteger Fp Result Loc = -1
  544  
  545      ! Size in WORDS of switch segment table
  546      %constinteger max switch = 1000
  547      %integerarray swtab(0:max switch)
  548      ! pointer to next switch segment entry
  549      %owninteger swtp = 0
  550  
  551      %ownstring(255)  external id = "",
  552+ 	                 alias = "",
  553+ 					 block name = ""
  554  
  555      ! current string literal
  556      %byteintegerarray  current string(0:255)
  557  
  558      ! current external string name
  559      %byteintegerarray x sym buff(0:255)
  560      %integer  xlen
  561  
  562      ! WORK List - used to optimise use of temporary storage
  563      ! There is a head of list for each contextual level
  564      %ownintegerarray worklist(1:max level) = 
  565+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  566  
  567      ! floating point value for constants and initialisers
  568      %longreal rvalue
  569  
  570      ! value to use when initialising OWNs
  571      %owninteger ownval = 0
  572  
  573      !-----------------------------------------------------------
  574      ! start of "enumeration to String/name functions
  575      ! The following are debug functions to convert "enumerated" values
  576      ! to an appropriate String/name
  577      !-----------------------------------------------------------
  578  
  579      %string(255) %fn get own String( %integer flags )
  580          %string(255) s
  581          %label esac
  582          %switch sw(0:15)
  583  
  584          -> sw(flags&7)
  585          sw( 0): s = "auto";      -> esac
  586          sw( 1): s = "own";       -> esac
  587          sw( 2): s = "constant";  -> esac
  588          sw( 3): s = "external";  -> esac
  589          sw( 4): s = "system";    -> esac
  590          sw( 5): s = "dynamic";   -> esac
  591          sw( 6): s = "primitive"; -> esac
  592          sw( 7): s = "permanent"; -> esac
  593          esac:
  594  
  595          %result = s
  596      %end
  597  
  598      %string(255) %fn get flags string( %integer flags )
  599          %string(255) s
  600  
  601          s = ""
  602  
  603          %if (Flags&1 # 0) %start
  604              %if (length(s) > 0) %then s = s . ","
  605              s = s . "spec"
  606          %finish
  607          %if (Flags &2 # 0) %start
  608              %if (length(s) > 0) %then s = s . ","
  609              s = s . "indirect"
  610          %finish
  611          %if (Flags&4 # 0) %start
  612              %if (length(s) > 0) %then s = s . ","
  613              s = s . "check"
  614          %finish
  615          %if (Flags &8 # 0) %start
  616              %if (length(s) > 0) %then s = s . ","
  617              s = s . "b6flag"
  618          %finish
  619          %if (Flags&16 # 0) %start
  620              %if (length(s) > 0) %then s = s . ","
  621              s = s . "b7flag"
  622          %finish
  623  
  624          %result = s
  625      %end
  626  
  627      %string(255) %fn get type def( %integer type,size )
  628          %string(255) s,so
  629          %label esac
  630          %switch sw(0:15)
  631  
  632          so = itos(size,0)
  633          s = ""
  634          -> sw(type&15)
  635          sw(0):
  636              s = "void"
  637              -> esac
  638          sw(1):
  639              %if (size = 1) %start
  640                  s = "integer"
  641              %finish %else %if (size = 2) %start
  642                  s = "byte"
  643              %finish %else %if (size = 3) %start
  644                  s = "short"
  645              %finish %else %if (size = 4) %start
  646                  s = "long"
  647              %finish %else %if (size = 5) %start
  648                  s = "quad"
  649              %finish %else %start
  650                  s = "type=1 (integer) has an unknown size=" . so
  651              %finish
  652              -> esac
  653          sw(2):
  654              %if (size = 1) %start
  655                  s = "real"
  656              %finish %else %if (size = 4) %start
  657                  s = "longreal"
  658              %finish %else %start
  659                  s = "type=2 (float) has an unknown size=" . so
  660              %finish
  661              -> esac
  662          sw(3):
  663              %if (size = 0) %start
  664                  s = "string(*)"
  665              %finish %else %start
  666                  s = "string(".so.")"
  667              %finish
  668              -> esac
  669          sw(4):
  670              %if (size = 0) %start
  671                  s = "record(*)"
  672              %finish %else %start
  673                  s = "record(""".var(size)_idname.""")"
  674              %finish
  675              -> esac
  676          sw(5):
  677              s = "boolean"
  678              -> esac
  679          sw(6):
  680              s = "set"
  681              -> esac
  682          sw(7):
  683              s = "enum8(""".var(size)_idname.""")"
  684              -> esac
  685          sw(8):
  686              s = "enum16(""".var(size)_idname.""")"
  687              -> esac
  688          sw(9):
  689              s = "pointer"
  690              -> esac
  691          sw(10):
  692              s = "char"
  693              -> esac
  694          sw(11):
  695              %if (size = 1) %start
  696                  s = "unsigned"
  697              %finish %else %if (size = 2) %start
  698                  s = "ubyte"
  699              %finish %else %if (size = 3) %start
  700                  s = "ushort"
  701              %finish %else %if (size = 4) %start
  702                  s = "ulong"
  703              %finish %else %if (size = 5) %start
  704                  s = "uquad"
  705              %finish %else %start
  706                  s = "unknown size for type 11=" . so
  707              %finish
  708              -> esac
  709          sw(*):
  710              s = "unknown type " . so
  711              -> esac
  712          esac:
  713  
  714          %result = s
  715      %end
  716  
  717      ! Determine an array entry type
  718      ! type, size are values from the "Define Var" iCode parameters
  719      ! type represent the type of each array entry
  720      ! size represents the size of the simple var (not the array size)
  721      %integer %fn get entry type( %integer type, size )
  722          %label esac
  723          %switch sw(0:15)
  724          %integer t
  725  
  726          ! Assuming this is referring to an array
  727          ! We can then decode the array entry type
  728  
  729          ! set default type as "unknown"
  730          t = 0
  731  
  732          ! decode the active entry type
  733          ! As more data-types are added (ie %longlonginteger, %char)
  734          ! provide more "type" values and decode appropriately
  735          -> sw(type&15)
  736          sw(1):
  737              %if (size = 1) %start
  738                  ! "integer"
  739                  t = 1
  740              %finish %else %if (size = 2) %start
  741                  ! "byte"
  742                  t = 5
  743              %finish %else %if (size = 3) %start
  744  !               ! "short"
  745  !               t = 6
  746                  ! "short" are regarded as "integer"
  747                  ! "integer"
  748                  t = 1
  749              %finish %else %if (size = 4) %start
  750  !                ! "long"
  751  !                t = 7
  752                  ! "long" are regarded as "integer"
  753                  ! "integer"
  754                  t = 1
  755              %finish
  756              -> esac
  757          sw(2):
  758              %if (size = 1) %start
  759                  ! "real"
  760                  t = 2
  761              %finish %else %if (size = 4) %start
  762                  ! "longreal"
  763                  t = 8
  764              %finish
  765              -> esac
  766          sw(3):
  767              ! "string"
  768              t = 3
  769              -> esac
  770          sw(4):
  771              ! "record"
  772              t = 4
  773              -> esac
  774          sw(*):
  775              ! "unknown"
  776              t = 0
  777              -> esac
  778          esac:
  779  
  780          %result = t
  781      %end
  782  
  783      %string(255) %fn get typeof String( %integer type )
  784          %string(255) s
  785          %label esac
  786          %switch sw(0:15)
  787  
  788          -> sw(type&15)
  789          sw( 0): s = "void";          -> esac
  790          sw( 1): s = "integer";       -> esac
  791          sw( 2): s = "real";          -> esac
  792          sw( 3): s = "string";        -> esac
  793          sw( 4): s = "record";        -> esac
  794          sw( 5): s = "byteinteger";   -> esac
  795          sw( 6): s = "shortinteger";  -> esac
  796          sw( 7): s = "longinteger";   -> esac
  797          sw( 8): s = "longreal";      -> esac
  798          sw( 9): s = "array";         -> esac
  799          sw(10): s = "label";         -> esac
  800  
  801          sw(12): s = "arrayname";     -> esac
  802  
  803          sw(*):  s = "**type ??**";   -> esac
  804          esac:
  805  
  806          %result = s
  807      %end
  808  
  809      %string(255) %function get type name( %integer type)
  810          %string(255) name
  811          %label esac
  812          %switch n(0:15)
  813              
  814          -> n(type&15)
  815          n( 0):  name = "general";       -> esac
  816          n( 1):  name = "integer";       -> esac
  817          n( 2):  name = "real";          -> esac
  818          n( 3):  name = "string";        -> esac
  819          n( 4):  name = "record";        -> esac
  820          n( 5):  name = "byte";          -> esac
  821          n( 6):  name = "short";         -> esac
  822          n( 7):  name = "long";          -> esac
  823          n( 8):  name = "lreal";         -> esac
  824          n( 9):  name = "array";         -> esac
  825          n(10):  name = "label";         -> esac
  826          n(11):  name = "?array";        -> esac
  827          n(12):  name = "arrayname";     -> esac
  828          n(13):  name = "namearray";     -> esac
  829          n(14):  name = "namearrayname"; -> esac
  830  
  831          n(*):   name = "????";    -> esac
  832          esac:
  833  
  834          %result = name
  835      %end
  836  
  837      %string(255) %function get external form name( %integer form )
  838          %string(255) name
  839          %label esac
  840          %switch n(0:15)
  841              
  842          -> n(form&15)
  843          n( 0):  name = "void";           -> esac
  844          n( 1):  name = "simple";         -> esac
  845          n( 2):  name = "name";           -> esac
  846          n( 3):  name = "label";          -> esac
  847          n( 4):  name = "recordformat";   -> esac
  848  
  849          n( 6):  name = "switch";         -> esac
  850          n( 7):  name = "routine";        -> esac
  851          n( 8):  name = "function";       -> esac
  852          n( 9):  name = "map";            -> esac
  853          n(10):  name = "predicate";      -> esac
  854          n(11):  name = "array";          -> esac
  855          n(12):  name = "arrayname";      -> esac
  856          n(13):  name = "namearray";      -> esac
  857          n(14):  name = "namearrayname";  -> esac
  858  
  859          n(*):   name = "????";           -> esac
  860          esac:
  861  
  862          %result = name;
  863      %end
  864  
  865      %string(255) %function get internal form name( %integer form )
  866          %string(255) name
  867          %label esac
  868          %switch n(0:15)
  869  
  870          -> n(form&15)
  871          n( 0):  name = "Constant";    -> esac
  872          n( 1):  name = "V in R";      -> esac
  873          n( 2):  name = "A V in R";    -> esac
  874          n( 3):  name = "A in R";      -> esac
  875          n( 4):  name = "V in S";      -> esac
  876          n( 5):  name = "A V in S";    -> esac
  877          n( 6):  name = "A in S";      -> esac
  878          n( 7):  name = "V in REC";    -> esac
  879          n( 8):  name = "A V in REC";  -> esac
  880          n( 9):  name = "A in REC";    -> esac
  881          n(10):  name = "PgmLabel";    -> esac
  882  
  883          n(*):   name = "????";        -> esac
  884          esac:
  885  
  886          %result = name;
  887      %end
  888  
  889      ! The individual switch entries MUST match those in the assemble routine
  890      ! If the iCode language is extended/re-ordered then this routine
  891      ! must be updated.
  892      %string(255) %function getICodeName( %integer code )
  893          %string(255) s
  894          %label esac
  895          %switch c(0:255)
  896  
  897          -> c(code&255)
  898          c(10):      s = "ENDOFFILE"; -> esac
  899          c('!'):     s = "OR";        -> esac
  900          c('"'):     s = "COMPARED";  -> esac
  901          c('#'):     s = "JNE";       -> esac
  902          c('$'):     s = "DEF";       -> esac
  903          c('%'):     s = "XOR";       -> esac
  904          c('&'):     s = "AND";       -> esac
  905          c(''''):    s = "PUSHS";     -> esac
  906          c('('):     s = "JLE";       -> esac
  907          c(')'):     s = "JGE";       -> esac
  908          c('*'):     s = "MUL";       -> esac
  909          c('+'):     s = "ADD";       -> esac
  910          c('-'):     s = "SUB";       -> esac
  911          c('.'):     s = "CONCAT";    -> esac
  912          c('/'):     s = "QUOT";      -> esac
  913          c(':'):     s = "LOCATE";    -> esac
  914          c(';'):     s = "END";       -> esac
  915          c('<'):     s = "JL";        -> esac
  916          c('='):     s = "JE";        -> esac
  917          c('>'):     s = "JG";        -> esac
  918          c('?'):     s = "COMPARE";   -> esac
  919          c('@'):     s = "PUSH";      -> esac
  920          c('A'):     s = "INIT";      -> esac
  921          c('B'):     s = "REPEAT";    -> esac
  922          c('C'):     s = "COMPAREA";  -> esac
  923          c('D'):     s = "PUSHR";     -> esac
  924          c('E'):     s = "CALL";      -> esac
  925          c('F'):     s = "GOTO";      -> esac
  926          c('G'):     s = "ALIAS";     -> esac
  927          c('H'):     s = "BEGIN";     -> esac
  928          c('I'):     s = "UNUSED_I";  -> esac
  929          c('J'):     s = "JUMP";      -> esac
  930          c('K'):     s = "FALSE";     -> esac
  931          c('L'):     s = "LABEL";     -> esac
  932          c('M'):     s = "MAP";       -> esac
  933          c('N'):     s = "PUSHI";     -> esac
  934          c('O'):     s = "LINE";      -> esac
  935          c('P'):     s = "PLANT";     -> esac
  936          c('Q'):     s = "DIVIDE";    -> esac
  937          c('R'):     s = "RETURN";    -> esac
  938          c('S'):     s = "ASSVAL";    -> esac
  939          c('T'):     s = "TRUE";      -> esac
  940          c('U'):     s = "NEGATE";    -> esac
  941          c('V'):     s = "RESULT";    -> esac
  942          c('W'):     s = "SJUMP";     -> esac
  943          c('X'):     s = "IEXP";      -> esac
  944          c('Y'):     s = "UNUSED_Y";  -> esac
  945          c('Z'):     s = "ASSREF";    -> esac
  946          c('['):     s = "LSH";       -> esac
  947          c('\'):     s = "NOT";       -> esac
  948          c(']'):     s = "RSH";       -> esac
  949          c('^'):     s = "SETFORMAT"; -> esac
  950          c('_'):     s = "SLABEL";    -> esac
  951          c('a'):     s = "ACCESS";    -> esac
  952          c('b'):     s = "BOUNDS";    -> esac
  953          c('c'):     s = "UNUSED_c";  -> esac
  954          c('d'):     s = "DIM";       -> esac
  955          c('e'):     s = "EVENT";     -> esac
  956          c('f'):     s = "FOR";       -> esac
  957          c('g'):     s = "UNUSED_g";  -> esac
  958          c('h'):     s = "UNUSED_h";  -> esac
  959          c('i'):     s = "INDEX";     -> esac
  960          c('j'):     s = "JAM";       -> esac
  961          c('k'):     s = "JZ";        -> esac
  962          c('l'):     s = "LANG";      -> esac
  963          c('m'):     s = "MONITOR";   -> esac
  964          c('n'):     s = "SELECT";    -> esac
  965          c('o'):     s = "ON";        -> esac
  966          c('p'):     s = "ASSPAR";    -> esac
  967          c('q'):     s = "SUBA";      -> esac
  968          c('r'):     s = "RESOLVE";   -> esac
  969          c('s'):     s = "STOP";      -> esac
  970          c('t'):     s = "JNZ";       -> esac
  971          c('u'):     s = "ADDA";      -> esac
  972          c('v'):     s = "MOD";       -> esac
  973          c('w'):     s = "MCODE";     -> esac
  974          c('x'):     s = "REXP";      -> esac
  975          c('y'):     s = "DIAG";      -> esac
  976          c('z'):     s = "CONTROL";   -> esac
  977          c('{'):     s = "START";     -> esac
  978          c('|'):     s = "ALT_PSR";   -> esac
  979          c('}'):     s = "FINISH";    -> esac
  980          c('~'):     s = "ALT";       -> esac
  981          c(*):       s = "ILLEGAL";   -> esac
  982          esac:
  983  
  984          %result = s
  985      %end
  986  
  987      %routine ListICode
  988          selectoutput(listout)
  989          printstring( "icode(" )
  990          printstring( itos(iCodeCount,5) )
  991          printstring( "): " )
  992          printstring( getiCodeName(iCodeInst) )
  993      %end
  994  
  995      %routine ListICodeNoOp
  996          ListICode
  997          newline
  998      %end
  999  
  1000      !-----------------------------------------------------------
  1001      ! end of "enumeration to String/name functions
  1002      !-----------------------------------------------------------
  1003  
  1004      ! Moved declarations so they can be used by debug routines
  1005      %const %string(3) %array regname(AX:DI) =
  1006+ 	"EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"
  1007  
  1008      %const %string(2) %array reg8name(AL:BH) =
  1009+ 	"AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH"
  1010  
  1011      %const %string(7) %array relocname(0:6) =
  1012+ 	"", "DATA", "COT", "BSS", "DISPLAY", "EXTERN", "SWTAB"
  1013  
  1014      !-----------------------------------------------------------
  1015      ! Start with machine independent utility functions and stack
  1016      ! manipulation and debug
  1017      !-----------------------------------------------------------
  1018  
  1019      %string(255) %function hexint( %integer nn, places )
  1020          %constinteger base = 16
  1021  
  1022          %own %string(16) basechar = "0123456789ABCDEF"
  1023          %string(31) reversed,human
  1024          %integer n,i
  1025  
  1026          length(reversed) = 0
  1027  
  1028          n = nn
  1029          %while (n # 0) %cycle
  1030              length(reversed) = length(reversed) + 1
  1031              charno(reversed,length(reversed)) = charno(basechar,1+(n&15))
  1032              n = n >> 4
  1033          %repeat
  1034  
  1035          ! Pad out the digits with zero's if places more than actual number of 'digits'
  1036          %if (places > length(reversed)) %start
  1037              %while length(reversed) < places %cycle
  1038                  length(reversed) = length(reversed) + 1
  1039                  charno(reversed,length(reversed)) = '0'
  1040              %repeat
  1041          %finish
  1042  
  1043          ! Now reverse the digits for human readability.
  1044          length(human) = 0
  1045          %for i = length(reversed), -1, 1 %cycle
  1046              length(human) = length(human) + 1
  1047              charno(human,length(human)) = charno( reversed, i )
  1048          %repeat
  1049  
  1050          %result = human
  1051      %end
?BASE unused
  1052  
  1053      %routine  writenibble(%integer n)
  1054          n = n&16_f
  1055          %if (0 <= n %and n <= 9) %start
  1056              printsymbol(n + '0')
  1057          %else
  1058              printsymbol(n + ('A' - 10))
  1059          %finish
  1060      %end
  1061  
  1062      ! print a number in hexadecimal, to "places" size
  1063      %routine writehex(%integer n, places)
  1064          %integer p, shift
  1065  
  1066          shift = (places - 1) * 4
  1067          %while (shift > 0) %cycle
  1068              p = n >> shift
  1069              writenibble(p)
  1070              shift = shift - 4
  1071          %repeat
  1072          writenibble(n)
  1073      %end
  1074  
  1075      !                                                  >> SHOW <<
  1076      %routine  show(%record(stackfm)%name  v)
  1077          ! JDM The field widths have been tweaked to align columns
  1078          write(v_varno,4)
  1079          print string(" : Typ="); write(v_type,1)
  1080          print string(" Frm="); write(v_form,1)
  1081          print string(" Bse="); write(v_base,3);
  1082          print string(" Dsp="); write(v_disp,5)
  1083          print string(" ExtDsp="); write(v_extdisp,4)
  1084          print string(" Siz="); write(v_size,3)
  1085          print string(" Xtr="); write(v_extra,3)
  1086          print string(" Fmt="); write(v_format,2)
  1087          print string(" Dim="); write(v_dim,1)
  1088          print string(" Pba="); write(v_pbase,4)
  1089          ! JDM JDM retrieve the variable name
  1090          %if (length(var(v_var no)_idname) # 0)%start
  1091              { JDM show the variable name also }
  1092              print string(" Name='".var(v_var no)_idname."'")
  1093          %finish
  1094          newline
  1095      %end
  1096  
  1097      %routine dump tag var( %integer tag, %string(7) prefix )
  1098          %record(varfm)%name v
  1099  
  1100          v == var(tag)
  1101  
  1102          print string(" VAR entry")
  1103          newline
  1104          print string(" ".prefix."     tag=".itos(tag,0))
  1105          newline
  1106          print string(" ".prefix."    name=".v_idname)
  1107          newline
  1108  
  1109          print string(" ".prefix."    type=".itos(v_type,0))
  1110          printstring(" ".get type name(v_type))
  1111          newline
  1112          print string(" ".prefix."    form=".itos(v_form,0))
  1113          printstring(" ".get external form name(v_form))
  1114          newline
  1115          print string(" ".prefix."   level=".itos(v_level,0))
  1116          newline
  1117          print string(" ".prefix."   scope=".itos(v_scope,0))
  1118          printstring(" ".relocname(v_scope>>4) )
  1119          newline
  1120          print string(" ".prefix."     dim=".itos(v_dim,0))
  1121          newline
  1122  
  1123          print string(" ".prefix."    disp=".itos(v_disp,0))
  1124          spaces(4)
  1125          printstring( hexint(v_disp,8) )
  1126          newline
  1127          print string(" ".prefix." extdisp=".itos(v_extdisp,0))
  1128          newline
  1129          print string(" ".prefix."  format=".itos(v_format,0))
  1130          newline
  1131          print string(" ".prefix."    size=".itos(v_size,0))
  1132          newline
  1133          print string(" ".prefix."   pbase=".itos(v_pbase,0))
  1134          newline
  1135          print string(" ".prefix."   extra=".itos(v_extra,0))
  1136          newline
  1137          newline
  1138      %end
  1139  
  1140      ! Simple ABORT routine
  1141      %routine abort(%string(255) message)
  1142          %integer j
  1143  
  1144          select output(report)
  1145          printstring("Pass 2 abandoned at line ");
  1146          write(current line, 0);
  1147          printstring(" : ");
  1148          printstring(message)
  1149          newline
  1150          %if (stp # 0) %start
  1151              print string("STACK:");  newline
  1152              spaces(11) %and show(stack(j)) %for j = 1,1,stp
  1153          %finish
  1154          %signal 0,-1
  1155      %end
  1156  
  1157      !                                                  >> WARN <<
  1158      %routine  warn(%integer  n)
  1159          %string(255) warning
  1160          %switch  w(1:8)
  1161          -> w(n)
  1162  w(1):   warning = "Division by zero";                  -> at
  1163  w(2):   warning = "Illegal FOR";                       -> at
  1164  w(3):   warning = "Non-local control variable?";       -> at
  1165  w(4):   warning = "Invalid parameter for READ SYMBOL"; -> at
  1166  w(5):   warning = "String constant too long";          -> at
  1167  w(6):   warning = "No. of shifts outwith 0..31";       -> at
  1168  w(7):   warning = "Illegal constant exponent";         -> at
  1169  w(8):   warning = "Numerical constant too big";        -> at
  1170  at:
  1171          select output(report)
  1172          print string("*WARNING: line")
  1173          write(current line, 0)
  1174          print string(": ")
  1175          print string( warning )
  1176          newline
  1177          select output(objout)
  1178      %end
  1179  
  1180      !                                                  >> MONITOR <<
  1181      %routine  monitor(%record(stackfm)%name  v, %string(15) text)
  1182          select output(report)
  1183          print string(text)
  1184          print symbol(':')
  1185          spaces(10-length(text))
  1186          show(v)
  1187          select output(objout)
  1188      %end
  1189  
  1190      !                                                  >> GET GP TAG <<
  1191      %integerfn get gp tag
  1192          %integer l
  1193  
  1194          %if (gp asl = 0) %then abort("GP Tags")
  1195          l = gp asl
  1196          gp asl = gp tags(l)_link
  1197          %result = l
  1198      %end
  1199  
  1200      !                                                  >> RET GP TAG <<
  1201      %integerfn ret gp tag(%integer index)
  1202          %integer link
  1203  
  1204          link = gp tags(index)_link
  1205          gp tags(index)_link = gp asl
  1206          gp asl = index
  1207          %result = link
  1208      %end
  1209  
  1210      !------------------------------------------------------
  1211      ! Machine dependent utility routines
  1212      !------------------------------------------------------
  1213  
  1214      ! Routines to write the intermediate file
  1215      ! Record format is:
  1216      ! <type><length><data>
  1217      ! For debug purposes, the elements are all written as ascii
  1218      ! characters, where <type> is a single letter, <length> is a single
  1219      ! hex digit, length refers to the number of bytes (2 chars) of data.
  1220  
  1221      ! Intermediate file types: ( description below declaration )
  1222      %constinteger IF OBJ		=  0
  1223            { A - plain object code }
  1224      %constinteger IF DATA	    =  1
  1225            { B - dataseg offset code word }
  1226      %constinteger IF CONST	    =  2
  1227            { C - const seg offset code word }
  1228      %constinteger IF DISPLAY	=  3
  1229            { D - display seg offset code word }
  1230      %constinteger IF JUMP		=  4
  1231            { E - unconditional jump to label }
  1232      %constinteger IF JCOND	    =  5
  1233            { F - cond jump to label JE, JNE, JLE, JL, JGE, JG }
  1234      %constinteger IF CALL		=  6
  1235            { G - call a label }
  1236      %constinteger IF LABEL	    =  7
  1237            { H - define a label }
  1238      %constinteger IF FIXUP	    =  8
  1239            { I - define location for stack fixup instruction }
  1240      %constinteger IF SETFIX	    =  9
  1241            { J - stack fixup <location> <amount> }
  1242      %constinteger IF REQEXT	    = 10
  1243            { K - external name spec }
  1244      %constinteger IF REFLABEL   = 11
  1245            { L - relative address of label (JDM JDM new IBJ command) }
  1246      %constinteger IF REFEXT	    = 12
  1247            { M - external name relative offset code word (call external) }
  1248      %constinteger IF BSS		= 13
  1249            { N - BSS segment offset code word }
  1250      %constinteger IF COTWORD	= 14
  1251            { O - Constant table word }
  1252      %constinteger IF DATWORD	= 15
  1253            { P - Data segment word }
  1254      %constinteger IF SWTWORD	= 16
  1255            { Q - switch table entry - actually a label ID }
  1256      %constinteger IF SOURCE	    = 17
  1257            { R - name of the source file }
  1258      %constinteger IF DEFEXTCODE = 18
  1259            { S - define a code label that is external }
  1260      %constinteger IF DEFEXTDATA = 19
  1261            { T - define a data label that is external }
  1262      %constinteger IF SWT        = 20
  1263            { U - switch table offset code word }
  1264      %constinteger IF LINE       = 21
  1265            { V - line number info for debugger }
  1266      %constinteger IF ABSEXT     = 22
  1267            { W - external name absolute offset code word (data external) }
  1268  
  1269      %routine  writeifrecord( %integer type, length, 
  1270+                              %byteintegerarrayname buffer )
  1271          %integer c1, c2, i
  1272  
  1273          select output(objout)
  1274          printsymbol('A'+type)
  1275          %if (length > 255) %then abort("Intermediate file record too long")
  1276          writenibble(length>>4)
  1277          writenibble(length&15)
  1278  	
  1279          i = 0;
  1280          %while (length > 0) %cycle
  1281              c1 = buffer(i) >> 4
  1282              c2 = buffer(i)&15
  1283              writenibble(c1)
  1284              writenibble(c2)
  1285              i = i + 1
  1286              length = length - 1
  1287          %repeat
  1288          newline
  1289      %end
  1290  
  1291      ! Simple buffered output of code bytes...
  1292      %own %integer objectptr = 0;
  1293  	%const %integer objbufmax = 20
  1294      %own %byte %integer %array objectbytes(0:objbufmax)
  1295      ! Add corresponding bytes for the listing
  1296      !    (not always the same for fudged opcodes)
  1297      %own %integer listptr = 0
  1298  	%const %integer lstbufmax = 11
  1299      %own %byte %integer %array listbytes(0:lstbufmax)
  1300  
  1301  	! routine to clean to object buffer
  1302  	%routine ClearObjectBuffer
  1303  		%integer i
  1304  		%for i = 0,1,objbufmax %cycle
  1305  			objectbytes(i) = 0
  1306  		%repeat
  1307  		objectptr = 0
  1308  	%end
  1309  
  1310      ! Routine to provide the address and hex opcode listing in the
  1311      ! diagnostic output
  1312      %routine  listpreamble
  1313          %integer i;
  1314  
  1315          select output(listout)
  1316          space
  1317          writehex(nextcad, 4)
  1318          space
  1319          %for i = 0, 1, 9 %cycle
  1320              %if (i < listptr) %start
  1321                  writehex(listbytes(i), 2)
  1322                  space
  1323              %else
  1324                  spaces(3)
  1325              %finish
  1326          %repeat
  1327          spaces(8)
  1328          nextcad = nextcad + listptr
  1329          listptr = 0
  1330      %end
  1331  
  1332      ! flush the code buffer
  1333      %routine flushcode
  1334          %if (objectptr # 0) %start
  1335              writeifrecord(IF OBJ, objectptr, objectbytes)
  1336              ! clear the output pipe
  1337              ClearObjectBuffer
  1338          %finish
  1339      %end
  1340  
  1341      ! puts a normal code byte into the listing and code pipes
  1342      %routine  putcodebyte(%integer b)
  1343          objectbytes(objectptr) = b
  1344          objectptr = objectptr + 1
  1345      %end
  1346  
  1347      ! puts a normal code byte into the listing and code pipes
  1348      %routine  putlistbyte(%integer b)
  1349          listbytes(listptr) = b
  1350          listptr = listptr + 1
  1351      %end
  1352  
  1353      ! puts a normal code byte into the listing and code pipes
  1354      %routine  putbyte(%integer b)
  1355  		putlistbyte( b )
  1356  		putcodebyte( b )
  1357      %end
  1358  
  1359      ! A very handy little boolean function, used for instructions
  1360      ! with variable size immediate operands
  1361      %integerfn issmall(%integer i)
  1362          %result = 1 %if (-128 < i < 128)
  1363          %result = 0;
  1364      %end
  1365  
  1366      ! And aide-memoire of intel 80386 address modes...
  1367      !-------------------------
  1368      !     [EAX]
  1369      !     [ECX]
  1370      !     [EDX]
  1371      !     [EBX]
  1372      !     [][]
  1373      !     [disp32]
  1374      !     [ESI]
  1375      !     [EDI]
  1376      !-------------------------
  1377      !     [EAX+disp8]
  1378      !     [ECX+disp8]
  1379      !     [EDX+disp8]
  1380      !     [EBX+disp8]
  1381      !     [][]
  1382      !     [EBP+disp8]
  1383      !     [ESI+disp8]
  1384      !     [EDI+disp8]
  1385      !-------------------------
  1386      !     [EAX+disp32]
  1387      !     [ECX+disp32]
  1388      !     [EDX+disp32]
  1389      !     [EBX+disp32]
  1390      !     [][]
  1391      !     [EBP+disp32]
  1392      !     [ESI+disp32]
  1393      !     [EDI+disp32]
  1394      !-------------------------
  1395  
  1396      ! mod r/m format is:
  1397      ! mod LHREG R/M
  1398      ! where mod = 11 for rh registers
  1399  
  1400      ! plant a modrm reference where the rh operand is a register
  1401      ! Both parameters are actual register numbers, not internal ID's
  1402      %routine  modrmreg(%integer reg1, %integer reg2)
  1403          putbyte(16_C0 ! (reg1 << 3) ! (reg2));
  1404      %end
  1405  
  1406      ! tags corresponding to linker directives...
  1407      %const %integer %array reltag(0:6) =
  1408+     0,			{ no relocation }
  1409+ 	IF DATA,    { dataseg offset code word }
  1410+ 	IF CONST,   { const seg offset code word }
  1411+ 	IF BSS,		{ BSS relative code word }
  1412+ 	IF DISPLAY,	{ display seg offset code word }
  1413+ 	IF ABSEXT, 	{ external name absolute offset code word }
  1414+ 	IF SWT		{ switch table offset code word }
  1415  
  1416      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  1417      %routine norelocateoffset( %integer offset )
  1418          %integer i
  1419  
  1420  		%for i=1,1,word size %cycle
  1421  			putbyte(offset&255)
  1422  			offset = offset >> 8
  1423  		%repeat
  1424  
  1425      %end
  1426  
  1427      ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
  1428      %routine relocateoffset( %integer reloc, offset, extdisp )
  1429          %integer tag, i;
  1430  
  1431  		%if (reloc = 0) %start
  1432  			norelocateoffset( offset )
  1433  		%else
  1434              ! so that only the offset is going into the queue
  1435  			flushcode
  1436  
  1437  			tag = reltag(reloc);
  1438  			
  1439  			%if (tag = IF ABSEXT) %start
  1440                  ! offset byte 0
  1441  				putbyte(offset&255)
  1442                  ! get next byte
  1443                  offset = offset >> 8
  1444                  ! offset byte 1
  1445  				putbyte(offset&255)
  1446                  ! get next byte
  1447                  ! needed?
  1448                  offset = offset >> 8
  1449  
  1450                  ! extdisp byte 0
  1451  				putbyte(extdisp&255)
  1452                  ! get next byte
  1453                  extdisp = extdisp >> 8
  1454                  ! extdisp byte 1
  1455  				putbyte(extdisp&255)
  1456                  ! get next byte
  1457                  ! needed?
  1458                  extdisp = extdisp >> 8
  1459  
  1460  				writeifrecord(tag, word size, objectbytes)
  1461                  ! clear the queue
  1462  				ClearObjectBuffer	
  1463  			%else
  1464  				%for i=1,1,word size %cycle
  1465  					putbyte(offset&255)
  1466                      ! get next byte
  1467                      offset = offset >> 8
  1468  				%repeat
  1469  				writeifrecord(tag, word size, objectbytes)
  1470                  ! clear the queue
  1471  				ClearObjectBuffer
  1472  			%finish
  1473  
  1474  		%finish
  1475  
  1476      %end
  1477  
  1478      ! plant a modrm reference where the rh operand is in memory
  1479      ! Parameter REG1 is an actual register number,
  1480      !    but BASE is an internal ID
  1481      %routine  modrmmem( %integer reg1, base, disp, extdisp )
  1482          %integer mod, reloc
  1483  
  1484          reloc = base>>4
  1485          base = base&15
  1486  
  1487          %if (base = 0) %start
  1488              ! no register, just a displacement
  1489              ! mod = 000, rm = 101
  1490              putbyte((reg1 << 3) ! 5)
  1491              relocateoffset(reloc, disp, extdisp )
  1492          %else
  1493              %if (disp = 0) %and (base # BP) %start
  1494                  mod = 0
  1495              %else
  1496                  %if (issmall(disp) # 0) %start
  1497                      ! fits in one byte
  1498                      mod = 1
  1499                  %else
  1500                      mod = 2
  1501                  %finish
  1502              %finish
  1503  
  1504              ! Alas, displacement (even zero) must be output in full if
  1505              ! the offset is relocatable
  1506              %if (reloc # 0) %then mod = 2
  1507  
  1508              %if (base > DI) %or (base = SP) %start
  1509                  abort("Internal address mode error")
  1510              %finish
  1511  
  1512              ! Note - base-1 maps internal ID to real register
  1513  
  1514              putbyte((mod << 6)!(reg1 << 3)!(base - 1))
  1515  
  1516              %if (mod = 1) %start
  1517                  putbyte(disp)
  1518              %else
  1519                  %if (mod = 2) %then relocateoffset(reloc, disp, extdisp )
  1520              %finish
  1521          %finish
  1522      %end
  1523  
  1524      ! Print the corresponding memory access string
  1525      ! BASE is an internal ID, not an actual register number
  1526      %routine  printmemref( %integer base, disp )
  1527          %integer reloc
  1528  
  1529          reloc = base >> 4
  1530          base = base&15
  1531          selectoutput(listout)
  1532          printsymbol('[')
  1533          %if (base # 0) %start
  1534              printstring(regname(base))
  1535              %if (reloc # 0) %start
  1536                  printsymbol('+')
  1537                  printstring(relocname(reloc))
  1538              %finish
  1539              %if (disp # 0) %then %start
  1540                  printsymbol('+') %if (disp > 0)
  1541                  write(disp,0)
  1542              %finish
  1543          %else
  1544              %if (reloc # 0) %start
  1545                  printstring(relocname(reloc))
  1546                  printsymbol('+')
  1547              %finish
  1548              writehex(disp, 4)
  1549          %finish
  1550          printsymbol(']')
  1551      %end
  1552  
  1553      ! An opcode with no operands (eg RET)
  1554      %routine dumpsimple(%integer opn)
  1555  
  1556          putbyte(opvalue(opn))
  1557  
  1558          listpreamble
  1559          printstring(opname(opn))
  1560          newline
  1561          flushcode
  1562      %end
  1563  
  1564      ! A special bit of magic, used in record assignment
  1565      %routine dumprepmovsb
  1566          ! rep
  1567          putbyte(16_f3)
  1568          ! movsb
  1569          putbyte(16_a4)
  1570  
  1571          listpreamble
  1572          printstring("REP MOVSB")
  1573          newline
  1574          flushcode
  1575      %end
  1576  
  1577      ! Used in record = 0 assignment
  1578      %routine dumprepstosb
  1579          ! rep
  1580          putbyte(16_f3)
  1581          ! stosb
  1582          putbyte(16_aa)
  1583  
  1584          listpreamble
  1585          printstring("REP STOSB")
  1586          newline
  1587          flushcode
  1588      %end
  1589  
  1590      ! unary register operation - DEC, INC, NEG, NOT, POP, PUSH, IDIV, IMUL
  1591      ! REG is an internal ID, not an actual register number
  1592      %routine dumpur( %integer opn, reg )
  1593          %switch ops(DEC:IMUL)
  1594  
  1595          displayhint(reg) = 0
  1596  
  1597          ->ops(opn)
  1598  
  1599  ops(DEC):   putbyte(16_48 + reg - AX);                 ->break
  1600  ops(INC):   putbyte(16_40 + reg - AX);                 ->break
  1601  ops(NEG):   putbyte(16_F7); modrmreg(3, reg - AX);     ->break
  1602  ops(NOT):   putbyte(16_F7); modrmreg(2, reg - AX);     ->break
  1603  ops(POP):   putbyte(16_58 + reg - AX);                 ->break
  1604  ops(PUSH):  putbyte(16_50 + reg - AX);                 ->break
  1605  ops(IDIV):  putbyte(16_F7); modrmreg(7, reg - AX);     ->break
  1606  ops(IMUL):  putbyte(16_F7); modrmreg(5, reg - AX);     ->break
  1607  
  1608  break:
  1609          listpreamble
  1610          printstring(opname(opn))
  1611          space
  1612          printstring(regname(reg))
  1613          newline
  1614          flushcode
  1615      %end
  1616  
  1617      ! Plant code for a unary operation on memory
  1618      ! BASE is an internal ID, not the actual register number
  1619      %routine dumpum( %integer opn, base, disp, extdisp )
  1620          %switch ops(DEC:JMP)
  1621  
  1622          ->ops(opn)
  1623  
  1624  ops(DEC):   putbyte(16_FF) ;modrmmem(1, base, disp, extdisp);  ->break
  1625  ops(INC):   putbyte(16_FF) ;modrmmem(0, base, disp, extdisp);  ->break
  1626  ops(NEG):   putbyte(16_F7) ;modrmmem(3, base, disp, extdisp);  ->break
  1627  ops(NOT):   putbyte(16_F7) ;modrmmem(2, base, disp, extdisp);  ->break
  1628  ops(POP):   putbyte(16_8F) ;modrmmem(0, base, disp, extdisp);  ->break
  1629  ops(PUSH):  putbyte(16_FF) ;modrmmem(6, base, disp, extdisp);  ->break
  1630  ops(IDIV):  putbyte(16_F7) ;modrmmem(7, base, disp, extdisp);  ->break
  1631  ops(IMUL):  putbyte(16_F7) ;modrmmem(5, base, disp, extdisp);  ->break
  1632  ops(JMP):   putbyte(16_FF) ;modrmmem(4, base, disp, extdisp);  ->break
  1633  ops(CALL):  putbyte(16_FF) ;modrmmem(2, base, disp, extdisp);  ->break
  1634  
  1635  break:
  1636          listpreamble
  1637          printstring(opname(opn))
  1638          ! otherwise it's ambiguous for the reader
  1639          printstring(" WORD ")
  1640          printmemref(base, disp)
  1641          newline
  1642          flushcode
  1643      %end
  1644  
  1645      ! Plant code for a unary operation on an 8 bit memory location
  1646      ! Not all of the possible unary ops make sense as 8 bit destinations
  1647      ! BASE is an internal ID, not the actual register number
  1648      %routine dumpum8( %integer opn, base, disp, extdisp )
  1649          %integer base op, index
  1650  
  1651          %if (opn = DEC) %or (opn = INC) %start
  1652              base op = 16_FE
  1653              %if (opn = DEC) %then index = 1 %else index = 0
  1654          %else
  1655              %if (opn = NOT) %or (opn = NEG) %start
  1656                  base op = 16_F6
  1657                  %if (opn = NOT) %then index = 2 %else index = 3
  1658              %else
  1659                  Abort("Invalid UM8")
  1660              %finish
  1661          %finish
  1662  
  1663          putbyte(base op)
  1664          modrmmem(index, base, disp, extdisp )
  1665  
  1666          listpreamble
  1667          printstring(opname(opn))
  1668          ! otherwise it's ambiguous for the reader
  1669          printstring(" BYTE ")
  1670          printmemref(base, disp)
  1671          newline
  1672          flushcode
  1673      %end
  1674  
  1675      ! Plant a Memory <- Reg operation
  1676      ! Both BASE and REG are internal ID's, not actual register numbers
  1677      %routine dumpmr( %integer opn, base, disp, extdisp, reg )
  1678  
  1679          %if (opn = SHL) %start
  1680              ! special "shift by CL"
  1681              putbyte(16_D3)
  1682              modrmmem(4, base, disp, extdisp )
  1683          %else
  1684              %if (opn = SHR) %start
  1685                  putbyte(16_D3)
  1686                  modrmmem(5, base, disp, extdisp )
  1687              %else
  1688                  ! normal stuff
  1689                  putbyte(opvalue(opn))
  1690                  modrmmem(reg - AX, base, disp, extdisp )
  1691              %finish
  1692          %finish
  1693  
  1694          listpreamble
  1695          printstring(opname(opn))
  1696          space
  1697          printmemref(base, disp)
  1698          printsymbol(',')
  1699          printstring(regname(reg))
  1700          newline
  1701          flushcode
  1702      %end
  1703  
  1704      ! Plant an 8 bit Memory <- Reg operation
  1705      ! Both BASE and REG are internal ID's, not actual register numbers
  1706      %routine dumpmr8( %integer opn, base, disp, extdisp, reg )
  1707  
  1708          %if (opn = SHL) %start
  1709              ! special "shift by CL"
  1710              putbyte(16_D2)
  1711              modrmmem(4, base, disp, extdisp )
  1712          %finish %else %if (opn = SHR) %start
  1713              putbyte(16_D2)
  1714              modrmmem(5, base, disp, extdisp )
  1715          %finish %else %start
  1716              ! normal stuff
  1717              putbyte(op8value(opn))
  1718              modrmmem(reg - AL, base, disp, extdisp )
  1719          %finish
  1720  
  1721          listpreamble
  1722          printstring(opname(opn))
  1723          space
  1724          printmemref(base, disp)
  1725          printsymbol(',')
  1726          printstring(reg8name(reg))
  1727          newline
  1728          flushcode
  1729      %end
  1730  
  1731      ! Plant a 16 bit Reg <- Memory operation
  1732      ! Both BASE and REG are internal ID's, not actual register numbers
  1733      %routine dumprm( %integer opn, reg, base, disp, extdisp )
  1734  
  1735          ! We optimise the fairly common instruction MOV AX,[disp] with
  1736          ! the special short-form quirk of the 8086...
  1737  
  1738          %if (reg = AX) %and (opn = MOV) %and (base&15 = 0) %start
  1739              putbyte(16_A1)
  1740              relocateoffset(base>>4, disp, extdisp)
  1741          %else
  1742              displayhint(reg) = 0
  1743  
  1744              putbyte(opvalue(opn)+2)
  1745              modrmmem(reg - AX, base, disp, extdisp)
  1746          %finish
  1747  
  1748          listpreamble
  1749          printstring(opname(opn))
  1750          space
  1751          printstring(regname(reg))
  1752          printsymbol(',')
  1753          printmemref(base, disp)
  1754          newline
  1755          flushcode
  1756      %end
  1757  
  1758      ! Plant an 8 bit Reg <- Memory operation
  1759      ! Both BASE and REG are internal ID's, not actual register numbers
  1760      %routine dumprm8( %integer opn, reg, base, disp, extdisp )
  1761  
  1762          putbyte(op8value(opn)+2)
  1763          modrmmem(reg - AL, base, disp, extdisp )
  1764  
  1765          listpreamble
  1766          printstring(opname(opn))
  1767          space
  1768          printstring(reg8name(reg))
  1769          printsymbol(',')
  1770          printmemref(base, disp)
  1771          newline
  1772          flushcode
  1773      %end
  1774  
  1775      ! Plant a word Reg <- Reg operation
  1776      ! Both register parameters are internal ID's
  1777      %routine dumprr( %integer opn, reg1, reg2 )
  1778  
  1779          displayhint(reg1) = 0
  1780  
  1781          %if (opn = SHL) %start
  1782              ! special "shift by CL"
  1783              putbyte(16_D3)
  1784              modrmreg(4, reg1 - AX)
  1785          %finish %else %if (opn = SHR) %start
  1786              putbyte(16_D3)
  1787              modrmreg(5, reg1 - AX)
  1788          %finish %else %start
  1789              ! normal stuff
  1790              putbyte(opvalue(opn))
  1791              modrmreg(reg2 - AX, reg1 - AX)
  1792          %finish
  1793  
  1794          listpreamble
  1795          printstring(opname(opn))
  1796          space
  1797          printstring(regname(reg1))
  1798          printsymbol(',')
  1799          printstring(regname(reg2))
  1800          newline
  1801          flushcode
  1802      %end
  1803  
  1804      %routine dumprr8( %integer opn, reg1, reg2 )
  1805  
  1806          %if (opn = SHL) %start
  1807              ! special "shift by CL"
  1808              putbyte(16_D2)
  1809              modrmreg(4, reg1 - AL)
  1810          %finish %else %if (opn = SHR) %start
  1811              putbyte(16_D2)
  1812              modrmreg(5, reg1 - AL)
  1813          %finish %else %start
  1814              putbyte(op8value(opn))
  1815              modrmreg(reg2 - AL, reg1 - AL)
  1816          %finish
  1817  
  1818          listpreamble
  1819          printstring(opname(opn))
  1820          space
  1821          printstring(reg8name(reg1))
  1822          printsymbol(',')
  1823          printstring(reg8name(reg2))
  1824          newline
  1825          flushcode
  1826      %end
  1827  
  1828      %const %byte %integer %array aximmediatevalue(NOP:XOR) =
  1829+     0, 0, 0, 0, 0,
  1830+ 	0, 0, 0, 0,
  1831+ 	0, 0,
  1832+ 	0, 16_B8, 0,
  1833+ 	16_15, 16_05, 16_25, 16_3D, 16_0D, 16_2D, 16_35
  1834  
  1835      ! Register immediate operations - can be MOV, Math, or Shift
  1836      ! The immediate operand may be a relocated offset as part of
  1837      ! an address calculation
  1838      %routine dumprioffset( %integer opn, reg, reloc, immed, extdisp )
  1839          %integer subop
  1840          %switch ops(MOV:SHR)
  1841  
  1842          displayhint(reg) = 0
  1843  
  1844          ! because we pass around the or-able version
  1845          reloc = reloc >> 4
  1846  
  1847          %if (reg = AX) %and (opn <= XOR) %start
  1848              putbyte(aximmediatevalue(opn))
  1849              relocateoffset(reloc, immed, extdisp)
  1850              ->break
  1851          %else
  1852              ->ops(opn)
  1853          %finish
  1854  
  1855  ops(MOV):
  1856          putbyte(16_B8 + reg - AX)
  1857          relocateoffset(reloc, immed, extdisp )
  1858                                                         ->break
  1859  ops(ADD):
  1860          subop = 0
  1861          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1862              putbyte(16_83)
  1863              modrmreg(subop, reg - AX)
  1864              putbyte(immed&255)
  1865          %else
  1866              putbyte(16_81)
  1867              modrmreg(subop, reg - AX)
  1868              relocateoffset(reloc, immed, extdisp )
  1869          %finish
  1870                                                         ->break
  1871  ops(ADC):
  1872          subop = 2
  1873          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1874              putbyte(16_83)
  1875              modrmreg(subop, reg - AX)
  1876              putbyte(immed&255)
  1877          %else
  1878              putbyte(16_81)
  1879              modrmreg(subop, reg - AX)
  1880              relocateoffset(reloc, immed, extdisp )
  1881          %finish
  1882                                                         ->break
  1883  ops(CMP):
  1884          subop = 7
  1885          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1886              putbyte(16_83)
  1887              modrmreg(subop, reg - AX)
  1888              putbyte(immed&255)
  1889          %else
  1890              putbyte(16_81)
  1891              modrmreg(subop, reg - AX)
  1892              relocateoffset(reloc, immed, extdisp )
  1893          %finish
  1894                                                         ->break
  1895  ops(SUB):
  1896          subop = 5
  1897          %if (issmall(immed) # 0) %and (reloc = 0) %start
  1898              putbyte(16_83)
  1899              modrmreg(subop, reg - AX)
  1900              putbyte(immed&255)
  1901          %else
  1902              putbyte(16_81)
  1903              modrmreg(subop, reg - AX)
  1904              relocateoffset(reloc, immed, extdisp )
  1905          %finish
  1906                                                         ->break
  1907  ops(AND):
  1908          subop = 4
  1909          putbyte(16_81)
  1910          modrmreg(subop, reg - AX)
  1911          relocateoffset(reloc, immed, extdisp )
  1912                                                         ->break
  1913  ops(OR):
  1914          subop = 1
  1915          putbyte(16_81)
  1916          modrmreg(subop, reg - AX)
  1917          relocateoffset(reloc, immed, extdisp )
  1918                                                         ->break
  1919  ops(XOR):
  1920          subop = 6
  1921          putbyte(16_81)
  1922          modrmreg(subop, reg - AX)
  1923          relocateoffset(reloc, immed, extdisp )
  1924                                                         ->break
  1925  ops(SHL):
  1926          subop = 4
  1927          %if (immed = 1) %start
  1928              ! special shift-by-one instruction
  1929              putbyte(16_D1)
  1930              modrmreg(subop, reg - AX)
  1931          %else
  1932              putbyte(16_C1)
  1933              modrmreg(subop, reg - AX)
  1934              putbyte(immed)
  1935          %finish
  1936                                                         ->break
  1937  ops(SHR):
  1938          subop = 5
  1939          %if (immed = 1) %start
  1940              ! special shift-by-one instruction
  1941              putbyte(16_D1)
  1942              modrmreg(subop, reg - AX)
  1943          %else
  1944              putbyte(16_C1)
  1945              modrmreg(subop, reg - AX)
  1946              putbyte(immed)
  1947          %finish
  1948                                                         ->break
  1949  break:
  1950          listpreamble
  1951          printstring(opname(opn))
  1952          space
  1953          printstring(regname(reg))
  1954          printsymbol(',')
  1955          %if (reloc # 0) %start
  1956              printstring(relocname(reloc))
  1957              printsymbol('+')
  1958          %finish
  1959          write(immed, 0)
  1960          newline
  1961          flushcode
  1962      %end
  1963  
  1964      ! Register immediate operations - can be MOV, Math, or Shift
  1965      %routine dumpri( %integer opn, reg, immed )
  1966          %integer subop
  1967          %switch ops(MOV:SHR)
  1968  
  1969          displayhint(reg) = 0
  1970  
  1971          %if (reg = AX) %and (opn <= XOR) %start
  1972              putbyte(aximmediatevalue(opn))
  1973              norelocateoffset( immed )
  1974              ->break
  1975          %else
  1976              ->ops(opn)
  1977          %finish
  1978  
  1979  ops(MOV):
  1980          putbyte(16_B8 + reg - AX)
  1981          norelocateoffset( immed )
  1982                                                         ->break
  1983  ops(ADD):
  1984          subop = 0
  1985          %if (issmall(immed) # 0) %start
  1986              putbyte(16_83)
  1987              modrmreg(subop, reg - AX)
  1988              putbyte(immed&255)
  1989          %else
  1990              putbyte(16_81)
  1991              modrmreg(subop, reg - AX)
  1992              norelocateoffset( immed )
  1993          %finish
  1994                                                         ->break
  1995  ops(ADC):
  1996          subop = 2
  1997          %if (issmall(immed) # 0) %start
  1998              putbyte(16_83)
  1999              modrmreg(subop, reg - AX)
  2000              putbyte(immed&255)
  2001          %else
  2002              putbyte(16_81)
  2003              modrmreg(subop, reg - AX)
  2004              norelocateoffset( immed )
  2005          %finish
  2006                                                         ->break
  2007  ops(CMP):
  2008          subop = 7
  2009          %if (issmall(immed) # 0) %start
  2010              putbyte(16_83)
  2011              modrmreg(subop, reg - AX)
  2012              putbyte(immed&255)
  2013          %else
  2014              putbyte(16_81)
  2015              modrmreg(subop, reg - AX)
  2016              norelocateoffset( immed )
  2017          %finish
  2018                                                         ->break
  2019  ops(SUB):
  2020          subop = 5
  2021          %if (issmall(immed) # 0) %start
  2022              putbyte(16_83)
  2023              modrmreg(subop, reg - AX)
  2024              putbyte(immed&255)
  2025          %else
  2026              putbyte(16_81)
  2027              modrmreg(subop, reg - AX)
  2028              norelocateoffset( immed )
  2029          %finish
  2030                                                         ->break
  2031  ops(AND):
  2032          subop = 4
  2033          putbyte(16_81)
  2034          modrmreg(subop, reg - AX)
  2035          norelocateoffset( immed )
  2036                                                         ->break
  2037  ops(OR):
  2038          subop = 1
  2039          putbyte(16_81)
  2040          modrmreg(subop, reg - AX)
  2041          norelocateoffset( immed )
  2042                                                         ->break
  2043  ops(XOR):
  2044          subop = 6
  2045          putbyte(16_81)
  2046          modrmreg(subop, reg - AX)
  2047          norelocateoffset( immed )
  2048                                                         ->break
  2049  ops(SHL):
  2050          subop = 4
  2051          %if (immed = 1) %start
  2052              ! special shift-by-one instruction
  2053              putbyte(16_D1)
  2054              modrmreg(subop, reg - AX)
  2055          %else
  2056              putbyte(16_C1)
  2057              modrmreg(subop, reg - AX)
  2058              putbyte(immed)
  2059          %finish
  2060                                                         ->break
  2061  ops(SHR):
  2062          subop = 5
  2063          %if (immed = 1) %start
  2064              ! special shift-by-one instruction
  2065              putbyte(16_D1)
  2066              modrmreg(subop, reg - AX)
  2067          %else
  2068              putbyte(16_C1)
  2069              modrmreg(subop, reg - AX)
  2070              putbyte(immed)
  2071          %finish
  2072                                                         ->break
  2073  break:
  2074          listpreamble
  2075          printstring(opname(opn))
  2076          space
  2077          printstring(regname(reg))
  2078          printsymbol(',')
  2079          write(immed, 0)
  2080          newline
  2081          flushcode
  2082      %end
  2083  
  2084      ! Memory (long) immediate operations - can be MOV, Math, or Shift
  2085      %routine dumpmi( %integer opn, base, disp, extdisp, immed )
  2086          %integer subop
  2087          %switch ops(MOV:SHR)
  2088  
  2089          ->ops(opn)
  2090  
  2091  ops(MOV):
  2092          putbyte(16_C7)
  2093          modrmmem(0, base, disp, extdisp )
  2094          norelocateoffset( immed )
  2095                                                         ->break
  2096  ops(ADD):
  2097          subop = 0
  2098          %if (issmall(immed) # 0) %start
  2099              putbyte(16_83)
  2100              modrmmem(subop, base, disp, extdisp )
  2101              putbyte(immed&255)
  2102          %else
  2103              putbyte(16_81)
  2104              modrmmem(subop, base, disp, extdisp )
  2105              norelocateoffset( immed )
  2106          %finish
  2107                                                         ->break
  2108  ops(ADC):
  2109          subop = 2
  2110          %if (issmall(immed) # 0) %start
  2111              putbyte(16_83)
  2112              modrmmem(subop, base, disp, extdisp )
  2113              putbyte(immed&255)
  2114          %else
  2115              putbyte(16_81);
  2116              modrmmem(subop, base, disp, extdisp )
  2117              norelocateoffset( immed )
  2118          %finish
  2119                                                         ->break
  2120  ops(CMP):
  2121          subop = 7
  2122          %if (issmall(immed) # 0) %start
  2123              putbyte(16_83)
  2124              modrmmem(subop, base, disp, extdisp )
  2125              putbyte(immed&255)
  2126          %else
  2127              putbyte(16_81)
  2128              modrmmem(subop, base, disp, extdisp )
  2129              norelocateoffset( immed )
  2130          %finish
  2131                                                         ->break
  2132  ops(SUB):
  2133          subop = 5
  2134          %if (issmall(immed) # 0) %start
  2135              putbyte(16_83)
  2136              modrmmem(subop, base, disp, extdisp )
  2137              putbyte(immed&255)
  2138          %else
  2139              putbyte(16_81)
  2140              modrmmem(subop, base, disp, extdisp )
  2141              norelocateoffset( immed )
  2142          %finish
  2143                                                         ->break
  2144  ops(AND):
  2145          subop = 4
  2146          putbyte(16_81)
  2147          modrmmem(subop, base, disp, extdisp )
  2148          norelocateoffset( immed )
  2149                                                         ->break
  2150  ops(OR):
  2151          subop = 1
  2152          putbyte(16_81)
  2153          modrmmem(subop, base, disp, extdisp )
  2154          norelocateoffset( immed )
  2155                                                         ->break
  2156  ops(XOR):
  2157          subop = 6
  2158          putbyte(16_81)
  2159          modrmmem(subop, base, disp, extdisp )
  2160          norelocateoffset( immed )
  2161                                                         ->break
  2162  ops(SHL):
  2163          subop = 4
  2164          %if (immed = 1) %start
  2165              ! special shift-by-one instruction
  2166              putbyte(16_D1)
  2167              modrmmem(subop, base, disp, extdisp )
  2168          %else
  2169              putbyte(16_C1)
  2170              modrmmem(subop, base, disp, extdisp )
  2171              putbyte(immed)
  2172          %finish
  2173                                                         ->break
  2174  ops(SHR):
  2175          subop = 5
  2176          %if (immed = 1) %start
  2177              ! special shift-by-one instruction
  2178              putbyte(16_D1)
  2179              modrmmem(subop, base, disp, extdisp )
  2180          %else
  2181              putbyte(16_C1)
  2182              modrmmem(subop, base, disp, extdisp )
  2183              putbyte(immed)
  2184          %finish
  2185                                                         ->break
  2186  break:
  2187          listpreamble
  2188          printstring(opname(opn))
  2189          ! otherwise it's ambiguous for the reader
  2190          printstring(" LONG ")
  2191          printmemref(base, disp)
  2192          printsymbol(',')
  2193          write(immed, 0)
  2194          newline
  2195          flushcode
  2196      %end
  2197  
  2198      ! Memory (8 bit) immediate operations - can be MOV, Math, or Shift
  2199      %routine dumpmi8( %integer opn, base, disp, extdisp, immed )
  2200          %integer subop
  2201          %switch ops(MOV:SHR)
  2202  
  2203  		->ops(opn)
  2204  
  2205  ops(MOV):
  2206          subop = 0
  2207          putbyte(16_C6)
  2208          modrmmem(subop, base, disp, extdisp )
  2209          putbyte(immed&255)
  2210                                                         ->break
  2211  ops(ADD):
  2212          subop = 0
  2213          putbyte(16_80)
  2214          modrmmem(subop, base, disp, extdisp )
  2215          putbyte(immed&255)
  2216                                                         ->break
  2217  ops(ADC):
  2218          subop = 2
  2219          putbyte(16_80)
  2220          modrmmem(subop, base, disp, extdisp )
  2221          putbyte(immed&255)
  2222                                                         ->break
  2223  ops(CMP):
  2224          subop = 7
  2225          putbyte(16_80)
  2226          modrmmem(subop, base, disp, extdisp )
  2227          putbyte(immed&255)
  2228                                                         ->break
  2229  ops(SUB):
  2230          subop = 5
  2231          putbyte(16_80)
  2232          modrmmem(subop, base, disp, extdisp )
  2233          putbyte(immed&255)
  2234                                                         ->break
  2235  ops(AND):
  2236          subop = 4
  2237          putbyte(16_80)
  2238          modrmmem(subop, base, disp, extdisp )
  2239          putbyte(immed&255)
  2240                                                         ->break
  2241  ops(OR):
  2242          subop = 1
  2243          putbyte(16_80)
  2244          modrmmem(subop, base, disp, extdisp )
  2245          putbyte(immed&255)
  2246                                                         ->break
  2247  ops(XOR):
  2248          subop = 6
  2249          putbyte(16_80)
  2250          modrmmem(subop, base, disp, extdisp )
  2251          putbyte(immed&255)
  2252                                                         ->break
  2253  ops(SHL):
  2254          subop = 4
  2255          %if (immed = 1) %start
  2256              ! special shift-by-one instruction
  2257              putbyte(16_D0)
  2258              modrmmem(subop, base, disp, extdisp )
  2259          %else
  2260              putbyte(16_C0)
  2261              modrmmem(subop, base, disp, extdisp )
  2262              putbyte(immed)
  2263          %finish
  2264                                                         ->break
  2265  ops(SHR):
  2266          subop = 5
  2267          %if (immed = 1) %start
  2268              ! special shift-by-one instruction
  2269              putbyte(16_D0)
  2270              modrmmem(subop, base, disp, extdisp )
  2271          %else
  2272              putbyte(16_C0)
  2273              modrmmem(subop, base, disp, extdisp )
  2274              putbyte(immed)
  2275          %finish
  2276                                                         ->break
  2277  break:
  2278          listpreamble
  2279          printstring(opname(opn))
  2280          ! otherwise it's ambiguous for the reader
  2281          printstring(" BYTE ")
  2282          printmemref(base, disp)
  2283          printsymbol(',')
  2284          write(immed, 0)
  2285          newline
  2286          flushcode
  2287      %end
  2288  
  2289      ! Finally, a catch-all that recasts operations using generic
  2290      ! Var Stack structures
  2291      ! Plant a 16 bit Reg <- Var operation
  2292      %routine dumprv( %integer opn, reg, %record(stackfm)%name v )
  2293  
  2294          %if (v_form = V in R) %start
  2295              dumprr(opn, reg, v_base)
  2296          %finish %else %if (v_form = V in S) %start
  2297              dumprm(opn, reg, v_base!v_scope, v_disp, v_extdisp )
  2298          %finish %else %if (v_form = constant) %start
  2299              dumprioffset(opn, reg, v_scope, v_disp, v_extdisp )
  2300          %finish %else %start
  2301              abort("Address Mode")
  2302          %finish
  2303      %end
  2304  
  2305      ! Another special dumper - the only "Unary" operation that
  2306      ! takes an immediate operand is PUSH
  2307      %routine dumppushi( %integer reloc, immed, extdisp )
  2308  
  2309  
  2310          ! because we pass around the or-able version
  2311          reloc = reloc >> 4
  2312  
  2313          %if (reloc = 0) %and (is small(immed) # 0) %start
  2314              putbyte(16_6A)
  2315              putbyte(immed&255)
  2316          %else
  2317              putbyte(16_68)
  2318              relocateoffset(reloc, immed, extdisp )
  2319          %finish
  2320  
  2321          listpreamble
  2322          printstring("PUSH")
  2323          space
  2324          %if (reloc # 0) %start
  2325              printstring(relocname(reloc))
  2326              printsymbol('+')
  2327          %finish
  2328          write(immed, 0)
  2329          newline
  2330          flushcode
  2331      %end
  2332  
  2333      %routine dumpvpush(%record(stackfm)%name v)
  2334  
  2335          %if (v_form = V in R) %start
  2336              dumpur(PUSH, v_base)
  2337          %finish %else %if (v_form = V in S) %start
  2338              dumpum(PUSH, v_base!v_scope, v_disp, v_extdisp )
  2339          %finish %else %if (v_form = constant) %start
  2340              dumppushi(v_scope, v_disp, v_extdisp )
  2341          %finish %else %start
  2342              abort("Push Mode")
  2343          %finish
  2344      %end
  2345        
  2346      !----------------------------------------------------------
  2347      ! Floating point instructions - much simpler since there are
  2348      ! only two forms - RR and RM
  2349  
  2350      %conststring(10)%array flopname(FILD:FLDPI) =
  2351+     "FILD", "FLD DWORD", "FLD QWORD", "FISTP",
  2352+     "FSTP DWORD", "FSTP QWORD", "FADDP", "FSUBP",
  2353+     "FSUBRP", "FMULP", "FDIVP", "FDIVRP",
  2354+     "FCOMPP", "FCHS", "FABS",
  2355+     "FSTSW AX", "FLDZ", "FLDPI"
  2356  
  2357      ! The prefix opcode
  2358      %constbyteintegerarray flprefix(FILD:FLDPI) =
  2359+     16_DB, 16_D9, 16_DD, 16_DB,
  2360+     16_D9, 16_DD, 16_DE, 16_DE,
  2361+     16_DE, 16_DE, 16_DE, 16_DE,
  2362+     16_DE, 16_D9, 16_D9,
  2363+     16_DF, 16_D9, 16_D9
  2364  
  2365      ! The function selector to put in the field in the second byte
  2366      ! (or the second byte)
  2367      %constbyteintegerarray flindex(FILD:FLDPI) =
  2368+     16_00, 16_00, 16_00, 16_03,
  2369+     16_03, 16_03, 16_C0, 16_E8,
  2370+     16_E0, 16_C8, 16_F8, 16_F0,
  2371+     16_D8, 16_E0, 16_E1,
  2372+     16_E0, 16_EE, 16_EB
  2373  
  2374      ! Plant a Floating Point Reg <- Memory operation
  2375      ! BASE is an internal ID, not actual register number
  2376      ! Destination register is implicitly the stack top
  2377      %routine dumpfloprm( %integer opn, base, disp, extdisp )
  2378  
  2379          %if (opn <= FLDQ) %start
  2380              ! a load type
  2381              fpu stack = fpu stack + 1
  2382              %if (fpu stack > 8) %then abort("FPU Stack Overflow")
  2383          %else
  2384              fpu stack = fpu stack - 1
  2385              %if (fpu stack < 0) %then abort("FPU Stack Underflow")
  2386          %finish
  2387  
  2388          ! JDM JDM old code used with external 8087 numeric co-processor
  2389  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2390          putbyte(flprefix(opn))
  2391          modrmmem(flindex(opn), base, disp, extdisp )
  2392  
  2393          listpreamble
  2394          printstring(flopname(opn))
  2395          space
  2396          printmemref(base, disp)
  2397          newline
  2398          flushcode
  2399      %end
  2400  
  2401      ! Plant a Floating Point Reg <- Reg operation
  2402      ! Both register parameters are internal ID's that we
  2403      ! convert to stack offsets
  2404      %routine dumpfloprr( %integer opn, reg1, reg2 )
  2405          %integer top
  2406  
  2407          top = fpustack + (FR0 - 1)
  2408  
  2409          %if (reg2 # top) %then abort("FPU Stack Address")
  2410  
  2411          %if (opn < FCHS) %start
  2412              ! two operands - will pop one
  2413              fpu stack = fpu stack - 1
  2414              ! COMPP pops both registers
  2415              %if (opn = FCMP) %then fpu stack = fpu stack - 1
  2416              %if (fpu stack < 0) %then abort("FPU Stack Underflow")
  2417          %finish
  2418  
  2419          ! JDM JDM old code used with external 8087 numeric co-processor
  2420  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2421          putbyte(flprefix(opn))
  2422          putbyte(flindex(opn)!(top - reg1))
  2423  
  2424          listpreamble
  2425          printstring(flopname(opn))
  2426          space
  2427          printstring("ST(")
  2428          write(top-reg1, 0)
  2429          printstring("),ST")
  2430          newline
  2431          flushcode
  2432      %end
  2433  
  2434      ! Plant a "special" floating point operation
  2435      %routine dumpflopspec(%integer opn)
  2436  
  2437          %if (opn >= FLDZ) %start
  2438              ! load a constant
  2439              fpu stack = fpu stack + 1
  2440              %if (fpu stack > 8) %then abort("FPU Stack Overflow")
  2441          %finish
  2442  
  2443          ! JDM JDM old code used with external 8087 numeric co-processor
  2444  !		putbyte(16_9B);         ! we prepend a WAIT to everything
  2445          putbyte(flprefix(opn));
  2446          putbyte(flindex(opn))
  2447  
  2448          listpreamble
  2449          printstring(flopname(opn))
  2450          newline
  2451          flushcode
  2452      %end
  2453  
  2454      %routine dumpjump( %integer opn, labelid )
  2455          ! we put conventional assembler into the pipe for the listing
  2456          ! (with a zero jump offset) but then re-use the pipe for the
  2457          ! pseudo-code for the jump
  2458          putbyte(opvalue(opn))
  2459          putbyte(0)
  2460          %if (opn = CALL) %then putbyte(0)
  2461  
  2462          listpreamble
  2463          printstring(opname(opn))
  2464          space
  2465          { JDM JDM start new code }
  2466          %if (opn = CALL) %start
  2467              ! JDM JDM See if we can show the routine name
  2468              printstring( "'" )
  2469              %if (top_var no = 0) %start
  2470                  printstring( "$L" )
  2471                  write(labelid,0)
  2472              %finish %else %start
  2473                  printstring( var(top_var no)_idname )
  2474              %finish
  2475              printstring( "' (INTERNAL ")
  2476              printsymbol('L')
  2477              write(labelid,0)
  2478              printstring(" )")
  2479          %else
  2480              printsymbol('L')
  2481              write(labelid,0)
  2482          %finish
  2483          { JDM JDM end new code }
  2484          newline
  2485  
  2486  		! zap the current contents of the pipe
  2487          ClearObjectBuffer
  2488          %if (opn = JMP) %start
  2489  			putcodebyte( labelid&255 )
  2490  			putcodebyte( labelid >> 8 )
  2491  			writeifrecord(IF JUMP, 2, objectbytes)
  2492  
  2493              ! zap the current contents of the pipe
  2494  			ClearObjectBuffer
  2495          %finish %else %if (opn = CALL) %start
  2496  ! JDM replaced use of IF CALL command by IF REFLABEL command
  2497  ! old code retained Just-in-case
  2498  !           ! Generated code using IF CALL ibj command
  2499  !           putcodebyte( labelid&255 )
  2500  !           putcodebyte( labelid >> 8 )
  2501  !           writeifrecord(IF CALL, 2, objectbytes)
  2502  !            ! zap the current contents of the pipe
  2503  !           ClearObjectBuffer
  2504  
  2505              ! JDM JDM Generated code using IF REFLABEL ibj command
  2506              ! plant the CALL code
  2507              ! call with relative address
  2508              putcodebyte( 16_E8 )
  2509              writeifrecord(IF OBJ, 1, objectbytes)
  2510  
  2511              ! zap the current contents of the pipe
  2512              ClearObjectBuffer
  2513              ! plant the relative address of the label
  2514              putcodebyte( labelid&255 )
  2515              putcodebyte( labelid >> 8 )
  2516  
  2517              ! JDM set offset to zero
  2518              putcodebyte(0)
  2519              putcodebyte(0)
  2520              writeifrecord(IF REFLABEL, 4, objectbytes)
  2521  
  2522              ! zap the current contents of the pipe
  2523              ClearObjectBuffer
  2524          %finish %else %start
  2525              ! not an unconditional JMP or a CALL
  2526              ! assume it is a conditional JMP (i.e. JE,JNE, etc.)
  2527              putcodebyte(opn - JE)
  2528              putcodebyte( labelid&255 )
  2529              putcodebyte( labelid >> 8 )
  2530              writeifrecord(IF JCOND, 3, objectbytes)
  2531  
  2532              ! zap the current contents of the pipe
  2533              ClearObjectBuffer
  2534          %finish
  2535  
  2536          ! finally, calls may trash registers...
  2537          %if (opn = CALL) %start
  2538              displayhint(BX) = 0
  2539              displayhint(SI) = 0
  2540              displayhint(DI) = 0
  2541          %finish
  2542      %end
  2543  
  2544      ! call the n'th external routine we've spec'ed
  2545      %routine dumpextcall(%integer labelid)
  2546  
  2547          displayhint(BX) = 0
  2548          displayhint(SI) = 0
  2549          displayhint(DI) = 0
  2550  
  2551          ! plant the "CALL" instruction
  2552          putbyte(opvalue(CALL))
  2553          flushcode
  2554  
  2555          putbyte( labelid&255 )
  2556          putbyte( labelid >> 8 )
  2557          listpreamble
  2558          ! JDM JDM attempt to show external routine name
  2559          printstring("CALL ")
  2560          %if (labelid <= lastperm) %start
  2561              ! This is an internal "perm" routine
  2562              ! So, show the name
  2563              printstring("'".permname(labelid)."'")
  2564          %else
  2565              ! JDM JDM this is an external routine
  2566              printstring("'".var(top_var no)_idname."'")
  2567          %finish
  2568          printstring(" (EXTERN ")
  2569          write(labelid,0)
  2570          printstring(")")
  2571          newline
  2572          ! JDM JDM end attempt
  2573  
  2574          writeifrecord(IF REFEXT, word size, objectbytes)
  2575  !        writeifrecord(IF REFEXT, 2, objectbytes)
  2576  
  2577          ! zap the current contents of the pipe
  2578          ClearObjectBuffer
  2579      %end
  2580  
  2581      %routine dumplabel(%integer labelid)
  2582  
  2583          select output(listout)
  2584          space
  2585          writehex(nextcad, 4)
  2586          spaces(22)
  2587          printsymbol('L')
  2588          write(labelid,0)
  2589          printstring("  EQU $")
  2590          newline
  2591  
  2592          ! zap the current contents of the pipe
  2593          ClearObjectBuffer
  2594  
  2595  		putcodebyte(labelid & 255)
  2596  		putcodebyte(labelid >> 8)
  2597          writeifrecord(IF LABEL, 2, objectbytes)
  2598  
  2599          ! zap the current contents of the pipe
  2600          ClearObjectBuffer
  2601  
  2602          displayhint(BX) = 0
  2603          displayhint(SI) = 0
  2604          displayhint(DI) = 0
  2605      %end
  2606  
  2607      %routine dumpstaticalloc(%integer which, level, %string(255)%name name)
  2608          %integer i, len
  2609          ! we pretend to dump "C8 00 00 lev  ENTER 0000,lev"
  2610          ! but we actually plant a special pass 2 directive
  2611  
  2612          putbyte(16_C8)
  2613          putbyte(16_00)
  2614          putbyte(16_00)
  2615          putbyte(level)
  2616          listpreamble
  2617          printstring("ENTER 0000,")
  2618          write(level,0)
  2619          newline
  2620  
  2621          ! zap the current contents of the pipe
  2622          ClearObjectBuffer
  2623  		putcodebyte( which&255 )
  2624  		putcodebyte( which >> 8 )
  2625  		putcodebyte( level )
  2626  
  2627          ! we also pass the (truncated) name of the routine
  2628          !  - for pass3 diagnostic use
  2629  
  2630          len = length(name)
  2631          %if (len > 16) %then len = 16
  2632          %for i=1,1,len %cycle
  2633              putcodebyte(charno(name,i))
  2634          %repeat
  2635          writeifrecord(IF FIXUP, len+3, objectbytes)
  2636          ! zap the current contents of the pipe
  2637          ClearObjectBuffer
  2638      %end
  2639  
  2640      ! Pass 3 goes back and plants the correct preamble code for
  2641      ! the static allocation based on this directive, and also fills
  2642      ! in the event trap block as appropriate
  2643      %routine dumpstaticfill(%integer which, size, events, evep, evfrom)
  2644  
  2645          ! zap the current contents of the pipe
  2646          ClearObjectBuffer
  2647  
  2648          putcodebyte( which& 255 )
  2649          putcodebyte( which >> 8 )
  2650  
  2651          putcodebyte( size& 255 )
  2652          putcodebyte( size >> 8 )
  2653  
  2654          putcodebyte( events& 255 )
  2655          putcodebyte( events >> 8 )
  2656  
  2657          putcodebyte( evep&255 )
  2658          putcodebyte( evep >> 8 )
  2659  
  2660          putcodebyte( evfrom&255 )
  2661          putcodebyte(evfrom >> 8)
  2662  
  2663          writeifrecord(IF SETFIX, 10, objectbytes)
  2664  
  2665          ! zap the current contents of the pipe
  2666          ClearObjectBuffer
  2667      %end
  2668  
  2669      ! dump words for the constant segment or the data segment
  2670      ! Adjusts CAD so that the diagnostic listing looks sensible
  2671      %routine dumpcdword( %integer word, which )
  2672  
  2673          %integer tag, tmpcad, hi, lo
  2674          %owninteger cptr = 0
  2675          %owninteger dptr = 0
  2676          %owninteger sptr = 0
  2677  
  2678          tmpcad = next cad
  2679          %if (which = 2) %start
  2680              tag = IF SWTWORD
  2681              next cad = sptr
  2682              sptr = sptr + 2
  2683          %finish %else %if (which = 1) %start
  2684              tag = IF COTWORD
  2685              next cad = cptr
  2686              cptr = cptr + 2
  2687          %finish %else %start
  2688              tag = IF DATWORD
  2689              next cad = dptr
  2690              dptr = dptr + 2
  2691          %finish
  2692  
  2693          hi = word >> 8
  2694          lo = word&255
  2695          putbyte(lo)
  2696          putbyte(hi)
  2697          listpreamble
  2698          printstring("db ")
  2699          writehex(lo, 2)
  2700          printsymbol(',')
  2701          writehex(hi, 2)
  2702          printstring(" ; ")
  2703          %if (32 < lo < 127) %then printsymbol(lo) %else printsymbol('.')
  2704          %if (32 < hi < 127) %then printsymbol(hi) %else printsymbol('.')
  2705          newline
  2706          writeifrecord(tag, 2, objectbytes)
  2707  
  2708          ! clear the pipe
  2709          ClearObjectBuffer
  2710  
  2711          ! restore the real CAD
  2712          nextcad = tmp cad
  2713      %end
  2714  
  2715      ! tell the object file maker what source line we are on
  2716      %routine dumplinenumber(%integer line)
  2717  
  2718          %byteintegerarray buffer(0:1)
  2719  
  2720          buffer(0) = (line&255)
  2721          buffer(1) = (line >> 8)
  2722          writeifrecord(IF LINE, 2, buffer)
  2723  
  2724      %end
  2725  
  2726      ! utility to copy an IMP string into a simple buffer to
  2727      ! pass to the IF Record routine
  2728      %routine str to xsym(%string(255)%name s)
  2729          %integer l
  2730  
  2731          l = length(s)
  2732          xlen = 0
  2733          %while xlen < l %cycle
  2734              x sym buff(xlen) = charno(s, xlen+1)
  2735              xlen = xlen + 1
  2736          %repeat
  2737      %end
  2738  
  2739      ! tell the object maker the source file name
  2740      %routine dumpsourcename(%string(255) filename)
  2741  
  2742          str to xsym(filename)
  2743          writeifrecord(IF SOURCE, xlen, x sym buff)
  2744  
  2745      %end
  2746  
  2747      ! Plant a request to the linker for the external name, and
  2748      ! return an index number to refer to it with in future
  2749      %integerfn externalref(%string(255) extname)
  2750          %owninteger nextextref=1
  2751  
  2752          str to xsym(extname)
  2753          writeifrecord(IF REQEXT, xlen, x sym buff)
  2754          nextextref = nextextref + 1
  2755          %result = nextextref - 1
  2756      %end
  2757  
  2758      ! tell the linker about an external definition
  2759      %routine fill external(%integer seg, offset, %string(255) extname)
  2760  
  2761          str to xsym(extname)
  2762          %if (seg = CODE) %start
  2763              writeifrecord(IF DEFEXTCODE, xlen, x sym buff)
  2764          %else
  2765              writeifrecord(IF DEFEXTDATA, xlen, x sym buff)
  2766              ! JDM JDM pass3 amended to allow external data
  2767          %finish
  2768      %end
?OFFSET unused
  2769  
  2770      !------------------------------------------------------
  2771      ! Constant table utility routines
  2772      !
  2773      ! Rather than dump literal constants as they occur,
  2774      ! we collect them in a table.
  2775      ! Whenever the compiler wants any kind of literal,
  2776      ! we look to see if we already have it.
  2777      ! Note this automatically solves re-use of things like
  2778      ! floating point constants, string newline, and fixed array dope vectors.
  2779      ! When the table starts to get fairly full, we flush it.
  2780      ! Obviously that means in a large program we might not
  2781      ! actually get full re-use of constants after we've flushed,
  2782      ! but the idea is sound.
  2783      !
  2784      ! For the convenience of the caller, several versions of
  2785      ! pretty much the same thing are provided.
  2786      !------------------------------------------------------
  2787      %constinteger cot size = 2000
  2788      %ownbyteintegerarray contable(0:cot size)
  2789      %owninteger cotp = 0
  2790  
  2791      ! updated on a flush
  2792      %owninteger cotoffset = 0
  2793  
  2794      %routine flushcot
  2795          %integer i
  2796  
  2797          ! We output a position hint to the diagnostic stream
  2798          ! Note that although this is intended to look like
  2799          ! 8086 assembly directives the real work is done by
  2800          ! pass 3 - this is only to guide the human reader as
  2801          ! to what is going on
  2802  
  2803          selectoutput(listout)
  2804          printstring("      _TEXT  ENDS")
  2805          newline
  2806          printstring("      CONST  SEGMENT WORD PUBLIC 'CONST'")
  2807          newline
  2808  
  2809          i = 0
  2810          %while i < cotp %cycle
  2811              dumpcdword((contable(i+1) << 8) ! contable(i), 1)
  2812              i = i + 2
  2813          %repeat
  2814  
  2815          ! Update the pointers
  2816          cotp = 0
  2817          cotoffset = cotoffset + i
  2818  
  2819          ! and send another hint
  2820          selectoutput(listout)
  2821          printstring("      CONST  ENDS")
  2822          newline
  2823          printstring("      _TEXT  SEGMENT WORD PUBLIC 'CODE'")
  2824          newline
  2825  
  2826      %end
  2827  
  2828      ! return the offset in the const segment of a byte
  2829      ! with value b
  2830      %integerfn getcotb(%byteinteger b)
  2831          %integer i
  2832  
  2833          i = 0
  2834          %while (i < cotp) %cycle
  2835              %if (contable(i) = b) %then %result = i + cotoffset
  2836              i = i + 1
  2837          %repeat
  2838  
  2839          ! value wasn't there
  2840          %if (cotp = cotsize) %then flushcot
  2841  
  2842          contable(cotp) = b
  2843          cotp = cotp + 1
  2844          %result = (cotp - 1) + cotoffset
  2845      %end
  2846  
  2847      ! return the offset in the const segment of a word
  2848      ! with value w
  2849      %integerfn getcotw(%integer w)
  2850          %integer i, cw
  2851  
  2852          i = 0
  2853          %while (i < cotp-3) %cycle
  2854              cw = 0
  2855              cw = cw!(contable(i)<<0)
  2856              cw = cw!(contable(i+1)<<8)
  2857              cw = cw!(contable(i+2)<<16)
  2858              cw = cw!(contable(i+3)<<24)
  2859              %if (cw = w) %then %result = i + cotoffset
  2860              i = i + word size
  2861          %repeat
  2862  
  2863          ! value wasn't there - first make sure there is space
  2864          %if (cotp > cotsize-word size) %then flushcot
  2865  
  2866          ! now round off the COT
  2867          cotp = (cotp + align) & (\align)
  2868  
  2869          %for i=1,1,word size %cycle
  2870              contable(cotp) = w&255
  2871              w = w >> 8
  2872              cotp = cotp + 1
  2873          %repeat
  2874  
  2875          %result = (cotp - word size) + cotoffset
  2876      %end
  2877  
  2878      ! return the offset in the const segment of double precision real number
  2879      %integerfn getcotdouble( %longreal double )
  2880          %integer i
  2881  
  2882          i = 0
  2883          %while (i < cotp-7) %cycle
  2884              %if      (contable(i)   = byteinteger(addr(double)))   %c
  2885+                 %and (contable(i+1) = byteinteger(addr(double)+1)) %c
  2886+                 %and (contable(i+2) = byteinteger(addr(double)+2)) %c
  2887+                 %and (contable(i+3) = byteinteger(addr(double)+3)) %c
  2888+                 %and (contable(i+4) = byteinteger(addr(double)+4)) %c
  2889+                 %and (contable(i+5) = byteinteger(addr(double)+5)) %c
  2890+                 %and (contable(i+6) = byteinteger(addr(double)+6)) %c
  2891+                 %and (contable(i+7) = byteinteger(addr(double)+7)) %c
  2892+             %then %result = i + cotoffset
  2893              i = i + 4
  2894          %repeat
  2895  
  2896          ! value wasn't there - first make sure there is space
  2897          %if (cotp > cotsize-8) %then flushcot
  2898  
  2899          ! now round off the COT
  2900          cotp = (cotp + align) & (\align)
  2901  
  2902          %for i=0,1,7 %cycle
  2903              contable(cotp) = byteinteger(addr(double)+i)
  2904              cotp = cotp + 1
  2905          %repeat
  2906  
  2907          %result = (cotp - 8) + cotoffset
  2908      %end
  2909  
  2910      ! return the offset in the const segment of a quad word
  2911      ! with value q0:q1:q2:q3 (lo to hi)
  2912      %integerfn getcot4(%integer q0, q1, q2, q3)
  2913          %integer i, cw0, cw1, cw2, cw3
  2914  
  2915          i = 0
  2916          cw0 = 0
  2917          cw0 = cw0!(contable(i+0)<<0)
  2918          cw0 = cw0!(contable(i+1)<<8)
  2919          cw0 = cw0!(contable(i+2)<<16)
  2920          cw0 = cw0!(contable(i+3)<<24)
  2921  
  2922          cw1 = 0
  2923          cw1 = cw1!(contable(i+4)<<0)
  2924          cw1 = cw1!(contable(i+5)<<8)
  2925          cw1 = cw1!(contable(i+6)<<16)
  2926          cw1 = cw1!(contable(i+7)<<24)
  2927  
  2928          cw2 = 0
  2929          cw2 = cw2!(contable(i+8)<<0)
  2930          cw2 = cw2!(contable(i+9)<<8)
  2931          cw2 = cw2!(contable(i+10)<<16)
  2932          cw2 = cw2!(contable(i+11)<<24)
  2933          %while i < cotp-15 %cycle
  2934              cw3 = 0
  2935              cw3 = cw3!(contable(i+12)<<0)
  2936              cw3 = cw3!(contable(i+13)<<8)
  2937              cw3 = cw3!(contable(i+14)<<16)
  2938              cw3 = cw3!(contable(i+15)<<24)
  2939  
  2940              %if      (cw0 = q0) %c
  2941+                 %and (cw1 = q1) %c
  2942+                 %and (cw2 = q2) %c
  2943+                 %and (cw3 = q3) %then %result = i + cotoffset
  2944              i = i + word size
  2945              cw0 = cw1
  2946              cw1 = cw2
  2947              cw2 = cw3
  2948          %repeat
  2949  
  2950          ! value wasn't there - first make sure there is space
  2951          %if (cotp > cotsize - 16) %then flushcot
  2952  
  2953          ! now round off the COT
  2954          cotp = (cotp + align) & (\align)
  2955  
  2956          %for i=1,1,word size %cycle
  2957              contable(cotp) = q0&255
  2958              q0 = q0 >> 8
  2959              cotp = cotp + 1
  2960          %repeat
  2961  
  2962          %for i=1,1,word size %cycle
  2963              contable(cotp) = q1&255
  2964              q1 = q1 >> 8
  2965              cotp = cotp + 1
  2966          %repeat
  2967  
  2968          %for i=1,1,word size %cycle
  2969              contable(cotp) = q2&255
  2970              q2 = q2 >> 8
  2971              cotp = cotp + 1
  2972          %repeat
  2973  
  2974          %for i=1,1,word size %cycle
  2975              contable(cotp) = q3&255
  2976              q3 = q3 >> 8
  2977              cotp = cotp + 1
  2978          %repeat
  2979  
  2980          %result = (cotp - 16) + cotoffset
  2981      %end
  2982  
  2983      %owninteger null string = -1
  2984  
  2985      ! get an index into the constant table for the string literal
  2986      ! in the array s
  2987      %integerfn getcots( %byteintegerarrayname b )
  2988          %integer i, first, slen, match
  2989  
  2990  		slen = b(0)
  2991  
  2992          ! We optimise the Null String "" in comparisons, so we remember
  2993          ! the location here
  2994          %if (slen = 0) %start
  2995              null string = getcotb(0)
  2996              %result = null string
  2997          %finish
  2998  
  2999          ! offset to search in contable
  3000          first = 0
  3001  
  3002          %while (first + slen < cotp) %cycle
  3003              ! so long as there are that many bytes left
  3004              match = 1
  3005  			! Simple check of string lengths
  3006              %if (slen # contable(first)) %start
  3007                  match = 0
  3008                  %exit
  3009              %finish
  3010  			! ok, so lengths match but do the contents
  3011              %for i = 1, 1, slen %cycle
  3012                  %if (b(i) # contable(first + i)) %start
  3013                      match = 0
  3014                      %exit
  3015                  %finish
  3016              %repeat
  3017              %if (match = 1) %then %result = first + cotoffset
  3018  
  3019              ! try the next solution
  3020              first = first + 1
  3021          %repeat
  3022  
  3023          ! if we get here, it wasn't already in the constant table
  3024  		! Ok, so will we overflow the buffer
  3025          %if (cotp + slen + 1) >= cotsize %then flushcot
  3026  
  3027  		! dump the string length
  3028          first = cotp
  3029          contable(cotp) = slen
  3030          cotp = cotp + 1
  3031  		! Now, dump the string contents
  3032  		%for i = 1,1,slen %cycle
  3033              contable(cotp) = b(i)
  3034              cotp = cotp + 1
  3035          %repeat
  3036          %result = first + cotoffset
  3037      %end
  3038  
  3039      !------------------------------------------------------
  3040      ! Data segment utility routines
  3041      !
  3042      ! Unlike constants, we can't re-use data segment items,
  3043      ! which makes this much simpler.  We still accumulate
  3044      ! the bytes in a table because (1) we can make life
  3045      ! more efficient for Pass 3 that way and (2) by collecting
  3046      ! the bytes together we can produce more convincing debug
  3047      ! code listings, especially for programs that don't need
  3048      ! to flush the table in the middle of the code.
  3049      ! Note that because data segment offsets are used directly
  3050      ! as variable displacements, our pointer DATATP doesn't
  3051      ! wrap like the COTP does, and instead we subtract the
  3052      ! offset before we use it...
  3053      !------------------------------------------------------
  3054  
  3055      ! Size in bytes of data segment table
  3056      %constinteger datat limit = 1999
  3057      %byteintegerarray datat(0:datat limit)
  3058  
  3059      ! pointer to next data segment byte
  3060      %owninteger datatp = 0
  3061  
  3062      ! updated on a flush
  3063      %owninteger datat offset = 0
  3064  
  3065      ! Flush the accumulated data table
  3066      %routine flush data
  3067          %integer i, limit
  3068  
  3069          ! We output a position hint to the diagnostic stream
  3070  
  3071          selectoutput(listout)
  3072          printstring("            ENDS")
  3073          newline
  3074          printstring("      DATA  SEGMENT WORD PUBLIC 'DATA'")
  3075          newline
  3076  
  3077          i = 0
  3078          limit = datatp - datat offset
  3079          %while i < limit %cycle
  3080              ! JDM JDM DANGER ! in line below is a Bitwise OR not a comment
  3081              dumpcdword((datat(i+1) << 8) ! datat(i), 0)
  3082              i = i + 2;
  3083          %repeat
  3084  
  3085          datat offset = datat p
  3086  
  3087          ! and send another hint
  3088          selectoutput(listout)
  3089          printstring("      DATA    ENDS")
  3090          newline
  3091      %end
  3092  
  3093      !                                                  >> GBYTE <<
  3094      ! Simple byte in data segment
  3095      %routine  gbyte(%integer  n)
  3096  
  3097          flush data %if (datatp - datat offset > datat limit)
  3098          datat(datatp - datat offset) = n & 255;
  3099          datatp = datatp + 1
  3100      %end
  3101  
  3102      !                                                  >> GPUT <<
  3103      ! Put a word into data segment
  3104      %routine  gput(%integer  n)
  3105          %integer i
  3106  
  3107          %for i=1,1,word size %cycle
  3108              gbyte(n)
  3109              n = n >> 8;
  3110          %repeat
  3111      %end
  3112  
  3113      !                                                  >> GFIX <<
  3114      ! round off the data-segment pointer for alignment
  3115      %routine  gfix(%integer align)
  3116          gbyte(0) %while (datatp&align # 0)
  3117      %end
  3118  
  3119      !-----------------------------------------------------
  3120      ! The last table we collect as we go along is the switch
  3121      ! table.  We don't provide individual routines to fill
  3122      ! it in, but for neatness we provide this routine to send
  3123      ! the contents to pass 3
  3124  
  3125      %routine flush switch
  3126          %integer i
  3127  
  3128          select output(listout)
  3129          printstring("              ENDS")
  3130          newline
  3131          printstring("      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'")
  3132          newline
  3133          i = 0
  3134          %while i < swtp %cycle
  3135              dumpcdword(swtab(i), 2)
  3136              i = i + 1
  3137          %repeat
  3138  
  3139          ! and send another hint
  3140          selectoutput(listout)
  3141          printstring("      _SWTAB   ENDS")
  3142          newline
  3143      %end
  3144  
  3145      !-------------------------------------------------------------
  3146      ! Print the source code lines up to the indicated line
  3147      ! number - these will interleave with the diagnostic assembly
  3148      ! output
  3149      %owninteger echoline = 0
  3150  
  3151      %routine echo source line
  3152          %integer ch
  3153          %owninteger source eof = 0
  3154  
  3155          ! update the count even if there's no input
  3156          echoline = echoline + 1
  3157  
  3158          ! silently ignore lack of source file
  3159          %if (source eof # 0) %then %return
  3160  
  3161          select input(source)
  3162          select output(listout)
  3163          %cycle
  3164              readsymbol(ch)
  3165              printsymbol(ch)
  3166              %exit %if (ch = 10) %or (ch < 0)
  3167          %repeat
  3168  
  3169          %if (ch < 0) %then source eof = 1
  3170  
  3171          select input(icode)
  3172          select output(objout)
  3173      %end
  3174  
  3175      !-----------------------------------------------------------
  3176      ! General descriptor and register manipulation routines
  3177      !-----------------------------------------------------------
  3178  
  3179      !                                                  >> FLOATING <<
  3180      %integerfn  floating( %record(stackfm)%name v )
  3181          ! check descriptor for floating point quantity
  3182          %result = 1 %if (v_type = real)
  3183          %result = 1 %if (v_type = lreal)
  3184          %result = 0
  3185      %end
  3186  
  3187      !                                                  >> ZERO <<
  3188      %integerfn  zero( %record(stackfm)%name  v )
  3189          ! CHECK DESCRIPTOR FOR (INTEGER) ZERO
  3190          ! JDM JDM sequence of %result = 0 %if is equivalent to %or sequence
  3191          %result = 0 %if (v_disp # 0)
  3192          %result = 0 %if (v_base # 0)
  3193          %result = 0 %if ((v_form # constant) %and (v_form # A V in S))
  3194          %result = 1
  3195      %end
  3196  
  3197      !                                                  >> CONST <<
  3198      %integerfn  const( %record(stackfm)%name  v )
  3199          ! CHECK DESCRIPTOR FOR CONSTANT (INTEGER) VALUE
  3200          %result = 0 %unless (v_form = constant)
  3201          %result = 0 %if (v_type > byte)
  3202          %result = 1
  3203      %end
  3204  
  3205      %integerfn Min Record Size( %record(stackfm)%name A, B )
  3206          %integer N, M
  3207          N = A_format
  3208          N = var(N)_size&16_7FFF %if (N # 0)
  3209          M = B_format
  3210          M = var(M)_size&16_7FFF %if (M # 0)
  3211          N = M %if (N = 0) %or ((M # 0) %and (M < N))
  3212          %result = N %if (N > 0)
  3213          Abort("Min Rec Size")
  3214      %end
  3215  
  3216      !                                                  >> MULSHIFT <<
  3217      %integerfn mulshift( %integer n )
  3218          %integer shift, ref
  3219          ref = 1
  3220          %for shift = 1, 1, 14 %cycle
  3221              ref = ref<<1
  3222              %if (ref >= n) %start
  3223                  %if (ref = n) %then %result = shift %else %result = -1
  3224              %finish
  3225          %repeat
  3226          %result = -1
  3227      %end
  3228  
  3229      !                                                  >> SAME <<
  3230      %integerfn  same( %record(stackfm)%name  v,w )
  3231          ! Test whether or not V and W describe the same object.
  3232          ! JDM JDM code altered avoid %or to become simple test
  3233          %result = 0 %if (v_disp # w_disp)
  3234          %result = 0 %if (v_base # w_base)
  3235  
  3236          %result = 0 %if (v_type # w_type)
  3237          %result = 0 %if (v_form # w_form)
  3238  
  3239          %result = 0 %if (v_extra # w_extra)
  3240          %result = 0 %if (v_scope # w_scope)
  3241  
  3242          %result = 1
  3243      %end
  3244  
  3245      ! grab a slab of working store in the local stack
  3246      %integerfn getwork(%integer size)
  3247          %integer cell
  3248  
  3249          cell = worklist(level)
  3250          %while (cell # 0) %cycle
  3251              %if      (gp tags(cell)_info = size) %c
  3252+                 %and (gp tags(cell)_flags = 0) %start
  3253                  ! suitable candidate?
  3254                  ! mark it as in use
  3255                  gp tags(cell)_flags = 1
  3256                  %result = gp tags(cell)_addr
  3257              %finish
  3258              cell = gp tags(cell)_link
  3259          %repeat
  3260  
  3261          ! no space available already - make more
  3262          cell = get gp tag
  3263  
  3264          ! make them all even boundaries
  3265          frame = (frame - size) & (\align)
  3266          gp tags(cell)_addr = frame
  3267          gp tags(cell)_info = size
  3268          gp tags(cell)_link = worklist(level)
  3269          worklist(level) = cell
  3270  
  3271          ! in use
  3272          gp tags(cell)_flags = 1
  3273          %result = frame
  3274      %end
  3275  
  3276      ! Return a slab of working store to the free pool
  3277      ! Note that ReturnWork is cautious about what it accepts
  3278      ! - it only takes in items it has previously given out,
  3279      !   so we can call it fairly liberally with any old
  3280      !   rubbish and it will do the right thing
  3281      %routine Return Work( %integer addr )
  3282          %integer cell
  3283  
  3284          cell = worklist(level)
  3285          %while (cell # 0) %cycle
  3286              %if (gp tags(cell)_addr = addr) %start
  3287                  %if (gp tags(cell)_flags = 0) %then abort("Return Work")
  3288  
  3289                  ! mark it as free
  3290                  gp tags(cell)_flags = 0
  3291                  %return
  3292              %finish
  3293              cell = gp tags(cell)_link
  3294          %repeat
  3295  
  3296          ! Here, work area was not found - it probably wasn't a work area!
  3297      %end
  3298  
  3299      ! Check to see if a variable is in a work list assigned block.
  3300      ! Used in string expression compilation to avoid un-necessary copying,
  3301      ! hence only marked true for 256 byte chunks
  3302      %integerfn Is Work( %record(stackfm)%name v )
  3303          %integer cell
  3304  
  3305          ! JDM JDM replaced long %or test sequence by individual tests
  3306          ! order of tests could be altered for speed
  3307          %result = 0 %if (v_base # BP)
  3308          %result = 0 %if (v_disp >= 0)
  3309          %result = 0 %if (v_scope # 0)
  3310          %result = 0 %if (v_form # V in S)
  3311  
  3312          cell = worklist(level);
  3313          %while (cell # 0) %cycle
  3314              %if (gp tags(cell)_addr = v_disp) %start
  3315                  %if (gp tags(cell)_flags = 0) %then abort("Is Work")
  3316                  %if (gp tags(cell)_info # 256) %then %result = 0
  3317                  %result = 1
  3318              %finish
  3319              cell = gp tags(cell)_link
  3320          %repeat
  3321  
  3322          %result = 0
  3323      %end
  3324  
  3325      !                                                  >> RELEASE <<
  3326      %routine  release( %integer  reg )
  3327          ! Hazard the value in a register
  3328  
  3329          ! JDM JDM replaced long %or test sequence by individual tests
  3330          ! order of tests could be altered for speed
  3331          ! check if LOCKED
  3332          %return %if (reg = 0)
  3333          %return %if (reg > fr7)
  3334          %return %if (activity(reg) < 0)
  3335  
  3336          activity(reg) = activity(reg)-1
  3337          abort("Release inactive") %if (activity(reg) < 0)
  3338          claimed = claimed - 1
  3339      %end
  3340  
  3341      !                                                  >> CLAIM <<
  3342      %routine  claim( %integer  reg )
  3343          ! Cherish the value in a register
  3344          abort("Claim bad register") %if (reg > fr7)
  3345  
  3346          ! JDM JDM replaced long %or test sequence by individual tests
  3347          ! order of tests could be altered for speed
  3348  
  3349          %return %if (reg = 0)
  3350          %return %if (activity(reg) < 0)
  3351  
  3352          activity(reg) = activity(reg)+1
  3353          claimed = claimed+1
  3354      %end
  3355  
  3356      !                                                  >> HAZARD <<
  3357      ! Protect any value in register REG by storing in a temporary.
  3358      %routine  hazard( %integer  reg )
  3359          %integer  i, n, t, type
  3360  
  3361          %routine  mod(%record(stackfm)%name  v)
  3362              %switch  sw(0:a in rec)
  3363              v_base = BP
  3364              n = n-1
  3365              -> sw(v_form)
  3366  sw(a in rec):
  3367  sw(av in rec):
  3368  sw(v in rec):
  3369  sw(constant):
  3370              abort("Mod")
  3371  sw(v in s):
  3372              %if (v_disp = 0) %and (v_scope = 0) %start
  3373                  v_disp = t
  3374                  v_form = a in s
  3375              %else
  3376                  !  change (X in S) to (X in REC)
  3377                  v_form = v_form + 3
  3378                  v_extra = t
  3379              %finish
  3380                                                         -> out1
  3381  sw(a in s):
  3382  sw(av in s):
  3383              !  change (X in S) to (X in REC)
  3384              v_form = v_form + 3
  3385              v_extra = t
  3386                                                         -> out1
  3387  sw(v in r):
  3388              v_form = v in s
  3389              v_disp = t
  3390              v_type = type
  3391                                                         -> out1
  3392  out1:
  3393          %end
  3394  
  3395          n = activity(reg)
  3396  
  3397          ! NOT IN USE OR CLAIMED?
  3398          %return %if (n <= 0)
  3399          claimed = claimed - n
  3400          activity(reg) = 0
  3401          %if (reg >= fr0) %start
  3402              ! Note that the FPU can only save the top of the stack.
  3403              ! If we need to save something lower down,
  3404              ! we need to pop the things above me first...
  3405              ! and recurse as required
  3406              %if (reg - FR0 >= FPU Stack) %then hazard(reg+1)
  3407              type = lreal
  3408              t = getwork(8)
  3409              dumpfloprm(FSTQ, BP, t, 0)
  3410          %else
  3411              type = integer
  3412              t = getwork(word size)
  3413              dumpmr(MOV, BP,t, 0, reg)
  3414          %finish
  3415          %for i = 1, 1, stp %cycle
  3416              mod(stack(i)) %if (stack(i)_base = reg)
  3417          %repeat
  3418  
  3419          ! USE STILL OUTSTANDING?
  3420          abort("Usage Outstanding") %if (n # 0)
  3421      %end
  3422  
  3423      !                                                  >> HAZARD ALL <<
  3424      %routine  hazard all
  3425          %integer  j
  3426  
  3427          %if (claimed # 0) %start
  3428              ! at least one register claimed
  3429              hazard(j) %for j = AX,1,FR7
  3430          %finish
  3431      %end
  3432  
  3433      !                                                  >> GP REG <<
  3434      ! Get a general (integer) register
  3435      ! Note that registers AX, CX, DX, BX are, in order
  3436      ! numbers 1, 2, 3 and 4 (which is convenient)
  3437      %integerfn  gpreg
  3438          %integer  r
  3439  
  3440          ! look for an empty one
  3441          %for r = AX,1,BX %cycle
  3442              %result = r %if (activity(r) = 0)
  3443          %repeat
  3444  
  3445          ! look for an unlocked one
  3446          %for r = AX,1,BX %cycle
  3447              %if (activity(r) > 0) %start
  3448                  hazard(r)
  3449                  %result = r
  3450              %finish
  3451          %repeat
  3452  
  3453          abort("Get Reg")
  3454      %end
  3455  
  3456      !                                                  >> PT REG <<
  3457      %integerfn  pt reg
  3458          ! Get a register we can use as a pointer.
  3459          ! We deliberately rotate around the candidates
  3460          ! - to make re-use more likely
  3461          %constbyteintegerarray  pt pref(0:2) =
  3462+            7,  8,  4
  3463          ! SI, DI, BX
  3464          %owninteger next = 0
  3465          %integer  r,j
  3466  
  3467          ! look for an empty one
  3468          %for j = 1,1,3 %cycle
  3469              r = pt pref(next)
  3470              next = next+1
  3471              next = 0 %if (next = 3)
  3472              %result = r %if (activity(r) = 0)
  3473          %repeat
  3474  
  3475          ! look for an unlocked one
  3476          %for j = 1,1,3 %cycle
  3477              r = pt pref(j)
  3478              %if (activity(r) > 0) %start
  3479                  hazard(r)
  3480                  %result = r
  3481              %finish
  3482          %repeat
  3483  
  3484          abort("Get PT Reg")
  3485      %end
  3486  
  3487      !                                                  >> GET DISPLAY <<
  3488      ! return the register to use to access display level <n>
  3489      %integerfn getdisplay( %integer l )
  3490          %integer r, lev
  3491  
  3492          ! get rid of any relocation info
  3493          lev = l&15
  3494  
  3495          ! global?
  3496          %if (lev = 0) %then %result = l
  3497  
  3498          ! local?
  3499          %if (lev = level) %then %result = BP
  3500  
  3501          ! We now try the 3 pointer register
  3502          ! - they are not contiguously numbered,
  3503          !   which is why this is unrolled!
  3504          %if (displayhint(BX) = lev) %then %result = BX
  3505          %if (displayhint(SI) = lev) %then %result = SI
  3506          %if (displayhint(DI) = lev) %then %result = DI
  3507  
  3508          r = pt reg
  3509  
  3510          ! displays are first words in frame
  3511          dumprm(MOV, r, BP, -(lev * word size), 0 )
  3512          displayhint(r) = lev
  3513          %result = r
  3514      %end
  3515  
  3516      !                                                  >> SET DOPE VECTOR <<
  3517      ! Plants a dope vector for a 1-D constant bound array (usually
  3518      ! OWN or CONST arrays) in the CONST segment, returns the offset
  3519      ! Note that it also modifies the vlb and vub variables - after
  3520      ! the call, VLB contains the byte offset for the first member
  3521      ! and VUB contains the size to allocate for the array in bytes.
  3522      %integerfn  set dope vector( %integer size, type )
  3523          %integer  entries, dv, descriptor
  3524  
  3525          ! Make DV _size field to be a size/type/flag format descriptor
  3526          descriptor = (size<<5) ! (type<<1) ! 1
  3527  
  3528          entries = vub-vlb+1
  3529          dv = getcot4(1, vlb, vub, descriptor)
  3530          vub = entries*size
  3531          vlb = vlb*size
  3532          %result = dv
  3533      %end
  3534  
  3535      !                                                  >> PERM <<
  3536      ! calls a PERM and adjusts the stack by SPACE words afterwards
  3537      %routine  perm(%integer  n, space)
  3538          ! PERM routines were written in MS C,
  3539          ! as such they preserved SI and DI,
  3540          ! but trash the general purpose registers
  3541          hazard(AX)
  3542          hazard(CX)
  3543          hazard(DX)
  3544          hazard(BX)
  3545          ! JDM perm routines now implemented as IMP routines
  3546          ! so be more careful and hazard the SI,DI registers as well
  3547          hazard(SI)
  3548          hazard(DI)
  3549          dumpextcall(n)
  3550          %if (space # 0) %then dumpri( ADD, SP, space * word size)
  3551      %end
  3552  
  3553      %routine Load Perm( %integer  n, space )
  3554  
  3555          ! JDM JDM debug show the iCode instruction
  3556          %if (ShowIcode=1) %start
  3557              ListICodeNoOp
  3558          %finish
  3559          ! JDM JDM end debug
  3560  
  3561          perm( n, space )
  3562      %end
  3563  
  3564      !                                                  >> ASSEMBLE <<
  3565      ! AMODE:
  3566      !  -3: initial call
  3567      !  -2: alternate record format
  3568      !  -1: record format
  3569      !   0: begin block
  3570      !   1: procedure
  3571      !   2: %spec
  3572      %routine Assemble( %integer  amode, labs, names )
  3573          %switch c(33:127)
  3574          
  3575          ! General purpose pointer
  3576          %record(varfm)%name v
  3577  
  3578          ! Var of the current procedure we're compiling
  3579          %record(varfm)%name procvar
  3580  
  3581          ! Actual parameter ptr, used to copy parms to parm area
  3582          %record(varfm)%name   ap
  3583  
  3584          ! formal parameter ptr, used to copy parms to parm area
  3585          %record(varfm)%name   fp
  3586          ! General stack pointer
  3587          %record(stackfm)%name lhs
  3588  
  3589          ! General stack pointers
  3590          %record(stackfm)%name rhs
  3591  
  3592          ! Used for alternate records to find the largest alternate
  3593          %integer max frame
  3594  
  3595          ! First descriptor at this level
  3596          %integer first name
  3597  
  3598          ! Tag used by pass 3 to fix up this level's stack allocation
  3599          %integer staticalloc
  3600  
  3601          ! Used to jump around routines
  3602          %integer skipproc, lastskip
  3603  
  3604          ! Event info (mask, entry point, block start)
  3605          %integer events, evep, evfrom
  3606  
  3607          ! First label at this level
  3608          %integer First label
  3609  
  3610          ! Previous level's static allocation
  3611          %integer old frame
  3612  
  3613          %integer j, t
  3614          %integer dv
  3615  
  3616          %routinespec   compile to string(%record(stackfm)%name v)
  3617          ! JDM change name from load()
  3618          %routinespec   loadreg(%record(stackfm)%name  v, %integer  reg)
  3619          ! JDM new code
  3620          %routinespec   storereg(%record(stackfm)%name  v, %integer  reg)
  3621          %routinespec   assign(%integer  assop)
  3622          %routinespec   array ref(%integer  mode)
  3623          %routinespec   Operation(%integer n)
  3624          %routinespec   compare(%record(stackfm)%name  l,r)
  3625          %routinespec   test zero(%record(stackfm)%name v)
  3626          %integerfnspec new tag
  3627  
  3628          ! Actual code for Assemble is down around label NEXT
  3629  
  3630  		! The following functions "parse" an iCode instructions' parameters
  3631  		! These functions are the only places where the iCode stream is read
  3632  		!                                                      >> TAG <<
  3633  		!                                                      >> TAG+COMMA <<
  3634  		!                                                      >> INTEGER <<
  3635  		!                                                      >> BYTE <<
  3636  		!                                                      >> REAL <<
  3637  		%integerfn  ReadTag
  3638  			%integer s1, s2
  3639  			s1 = Pending
  3640  			readsymbol(s2)
  3641  			readsymbol(Pending)
  3642  			%result = s1<<8!s2
  3643  		%end
  3644  
  3645  		%integerfn  ReadTagComma
  3646  			%integer t
  3647  			t = ReadTag
  3648  			readsymbol(Pending)
  3649  			%result = t
  3650  		%end
  3651  
  3652  		%integerfn  ReadInteger
  3653  			%integer s1, s2, s3, s4
  3654  			s1 = Pending
  3655  			readsymbol(s2)
  3656  			readsymbol(s3)
  3657  			readsymbol(s4)
  3658  			readsymbol(Pending)
  3659  			%result = (s1<<24)!(s2<<16)!(s3<<8)!s4
  3660  		%end
  3661  
  3662  		%integerfn ReadByte
  3663  			%integer s1
  3664  			s1 = Pending
  3665  			readsymbol(Pending)
  3666  			%result = s1
  3667  		%end
  3668  
  3669  		!                                                      >> READ REAL <<
  3670  		! Read a floating point literal.  Pass 1 treats these as strings
  3671  		! and leaves it up to us to make a floating point number out of it
  3672  		! We therefore expect [COUNT]NNN.NNN@NN
  3673  		%longrealfn  ReadReal
  3674  			%integer n
  3675  			%longreal p, r
  3676  			n = ReadTagComma;	! char count, skip comma
  3677  
  3678  			r = 0
  3679  			! Start with the bit ahead of the decimal point
  3680  			%cycle
  3681  				sym = Pending;  read symbol(Pending)
  3682  				%exit %if (sym = '.')
  3683  				n = n-1
  3684  				-> power %if (sym = '@')
  3685  				r = r*10+(sym-'0')
  3686  				-> SIGN %if (n = 0)
  3687  			%repeat
  3688  			p = 1
  3689  			%cycle
  3690  				n = n-1
  3691                  -> SIGN %if (n = 0)
  3692  				sym = Pending
  3693                  read symbol(Pending)
  3694  				-> POWER %if (sym = '@')
  3695  				p = p/10
  3696  				r = r + (sym-'0')*p
  3697  			%repeat
  3698  
  3699  POWER:
  3700  			n = ReadTag
  3701              ! Pass1 writes a Tag as an unsigned 16-bit integer (0..65535)
  3702              ! but is read into a 32-bit signed integer
  3703              ! and so 0 < n < 65535
  3704              ! BUT:
  3705              ! in this case a tag is to be regarded as a 16-bit signed integer
  3706              ! So 0 < n < 32768 is to be regarded as a positive integer
  3707              ! and 32767 < n < 65536 is a negative integer
  3708              ! n     => correct n
  3709              ! 65536 =>  0
  3710              ! 65535 => -1      (65536 - n)
  3711              ! 65534 => -2      (65536 - n)
  3712              ! ..
  3713              ! 32768 => -32768  (65536 - n)
  3714  
  3715              ! Now to tweak the floating point value. This method is
  3716  			! somewhat clunky so that we can be portable to a system that
  3717  			! doesn't do exponents
  3718  
  3719              ! This version of the pass2 code generator targets the 8087
  3720              ! and later versions as the numeric processor for floating
  3721              ! point arithmetic
  3722              ! e.g. double real (== %longreal)
  3723              ! Double real uses an 11-bit exponent so we should ensure
  3724              ! that the tag represents an exponent in the range
  3725              !             -1023 <= exp <= 1023
  3726              ! -1024 is omitted to ensure no overflow for reciprocals
  3727              ! The exponent however, has a bias of 1023 so the actual
  3728              ! 8087 exponent is in the range 0 <= exp <= 2046
  3729  
  3730              ! Currently don't bother to check that the exponent is in
  3731              ! the range -1023 < exp < 1023
  3732              %if (n # 0) %start
  3733                  ! ok, non-zero exponent
  3734                  %if (0 < n < 32768) %start
  3735                      ! positive exponent
  3736                      %while (n > 0) %cycle
  3737                          r = r * 10
  3738                          n = n - 1
  3739                      %repeat
  3740                  %else
  3741                      ! a negative exponent
  3742                      ! So, convert to negative value
  3743                      n = n - 65536
  3744  
  3745                      ! Now, attempt to update the float value
  3746                      %while (n < 0) %cycle
  3747                          r = r / 10
  3748                          n = n + 1
  3749                      %repeat
  3750                  %finish
  3751              %finish
  3752  SIGN:
  3753              ! sign of whole value
  3754  			%if (Pending = 'U') %start
  3755  				read symbol(Pending)
  3756  				r = -r
  3757  			%finish
  3758  
  3759  			%result = r
  3760  		%end
  3761  
  3762  		%string(255)%function ReadString
  3763              ! JDM JDM changed Limit to be a %constinteger
  3764              %constinteger limit = 255
  3765  			%integer J, Sym
  3766  			%string(255) s
  3767  
  3768  			s = ""
  3769  			%for J = Pending, -1,1 %cycle
  3770  				Readsymbol(Sym)
  3771  				s = s.Tostring(Sym) %if (Length(s) < Limit)
  3772  			%repeat
  3773  			Readsymbol(Pending)
  3774  			
  3775  			%result = s
  3776  		%end
  3777  
  3778  		%string(255)%function Get Ascii( %integer terminator)
  3779  			%string(255) a
  3780  			%integer Sym
  3781  			a = ""
  3782  			%cycle
  3783  				sym = Pending
  3784                  read symbol(Pending)
  3785                  %exit %if (sym = terminator)
  3786  				%if (length( a ) # 255) %start
  3787  					a = a.to string(sym)
  3788  				%finish
  3789  			%repeat
  3790  			%result = a
  3791  		%end
  3792  		! End of parsing routines
  3793  
  3794          %routine Load Language Flags( %integer flags )
  3795  
  3796              ! JDM JDM debug show the iCode instruction
  3797              %if (ShowIcode=1) %start
  3798                  ListICode
  3799                  spaces(4)
  3800                  printstring( itos(flags,0) )
  3801                  newline
  3802              %finish
  3803              ! JDM JDM end debug
  3804  
  3805              Language Flags = flags;
  3806          %end
  3807  
  3808          !                                              >> DEFINE VAR <<
  3809          %routine  Define Var( %integer decl, %string(255) internal id, %integer tf, size, scope )
  3810              %integer  type, form, format, s, new, round, dimension
  3811              %integer  dv;              ! dope vector offset
  3812              %owninteger  prim no = 0
  3813              %integer flags
  3814              %string(255) sx,flagstring
  3815  
  3816              ! Now parse the type and form word
  3817              type = (tf>>4)
  3818              form = tf&15
  3819  
  3820              ! If this var is really an array,
  3821              !     then remember the array entry type
  3822              ! simple arrays have their bounds defined AFTER the "Define Var"
  3823              ! %switch arrays have their bounds defined BEFORE the "Define Var"
  3824              !     and we would "tag" them as "label" array entry type
  3825              array entry type = get entry type( type, size )
  3826  
  3827              ! Now analyse the Scope word
  3828              dimension = (scope>>8)&255
  3829              ! JDM JDM debug
  3830              flags = (scope>>3)&31
  3831  
  3832              spec = (scope>>3)&1
  3833              otype = scope&7
  3834  
  3835              ! JDM JDM debug show the iCode instruction
  3836              %if (ShowIcode=1) %start
  3837                  ListICode
  3838                  spaces(4)
  3839                  printstring( itos(decl,0) )
  3840                  printsymbol( ',' )
  3841                  printsymbol( '"' )
  3842                  printstring( internal id )
  3843                  printsymbol( '"' )
  3844                  printsymbol( ',' )
  3845                  printstring( itos(tf,0) )
  3846                  printsymbol( ',' )
  3847                  printstring( itos(size,0) )
  3848                  printsymbol( ',' )
  3849                  printstring( itos(scope,0) )
  3850                  spaces(4)
  3851  
  3852                  sx = ""
  3853                  sx = sx . " " . get own string( otype )
  3854                  sx = sx . " " . get type def( type, size )
  3855                  sx = sx . " " . get external form name( form )
  3856                  { See if there are any flags set }
  3857                  flagstring = get flags string( flags )
  3858  
  3859                  { Ok, flags were set so show them }
  3860                  %if (length(flagstring) > 0) %start
  3861                      sx = sx . " [" . flagstring . "]"
  3862                  %finish
  3863  
  3864                  printsymbol( '(' )
  3865                  printstring( sx )
  3866                  space
  3867                  printsymbol( ')' )
  3868  
  3869                  newline
  3870              %finish
  3871              ! JDM JDM end debug
  3872  
  3873              new = 0
  3874              round = align
  3875  
  3876              ! Get the var index
  3877              %if (decl = 0) %start
  3878                  ! RECORD FORMAT ELEMENT NAME
  3879                  parms = parms-1
  3880                  abort("Def Var Parms") %if (parms <= names)
  3881                  decvar == var(parms)
  3882                  decvar = 0
  3883              %else
  3884                  abort("Def Var Names (decl=".itos(decl,0)." parms=".itos(parms,0).")") %if (decl >= parms)
  3885                  decvar == var(decl)
  3886                  %if (decl > names) %start
  3887                      names = decl
  3888                      new = 1
  3889                      decvar = 0
  3890                  %finish
  3891              %finish
  3892  
  3893              ! Map external type numbers into internal equivalents,
  3894              ! and adjust for short/byte/long things
  3895              %if (type = integer) %and (size # 1) %start
  3896                  ! INTEGER
  3897                  type = byte  %and round = 0 %if size = 2
  3898                  size = vsize(type)
  3899              %finish %else %if (type = real) %start
  3900                  ! REAL
  3901                  ! or possibly
  3902                  ! LONG REAL
  3903                  type = lreal %if (size = 4)
  3904                  size = vsize(type)
  3905              %finish %else %if (type = record) %start
  3906                  ! record
  3907                  format = size
  3908                  decvar_format = format
  3909                  size = var(format)_size %if (format <= names)
  3910              %finish %else %if (type = string) %start
  3911                  ! string
  3912                  round = 0
  3913                  decvar_size = size
  3914                  size = size + 1
  3915              %else
  3916                  size = vsize(type)
  3917              %finish
  3918              
  3919  
  3920              ! JDM JDM remember the variable name
  3921              ! Needed should an embedded code fragment refer to an IMP variable
  3922              var(decl)_idname = internal id
  3923  
  3924              decvar_size = size %if (type # string)
  3925              decvar_type = type
  3926              decvar_form = form
  3927  
  3928              %if (otype # 0) %start
  3929                  ! Set external linkage name if appropriate
  3930                  %if (otype >= external) %start
  3931                      %if (length(alias) # 0) %start
  3932                          external id = alias
  3933                      %finish %else %if (otype = system) %start
  3934                          external id = system prefix.internal id
  3935                      %else
  3936                          external id = "_".internal id
  3937                      %finish
  3938                      ! external, system, dynamic?
  3939                      otype = external %if (otype <= dynamic)
  3940                  %finish
  3941              %finish
  3942              alias = ""
  3943  
  3944  			! JDM: Ensure the external displacement is zero
  3945  			decvar_extdisp = 0
  3946  
  3947              %if (switch < form) %and (form < array) %start
  3948                  ! PROCEDURE
  3949                  ! 1 for normal proc, 2 for spec
  3950                  block type = 1 + spec
  3951                  %if (otype # 0) %and (spec # 0) %start
  3952                      ! external spec
  3953                      %if (otype = primrt) %start
  3954                          primno = primno + 1
  3955                          decvar_level = 128
  3956                          decvar_disp = prim no
  3957                          %return
  3958                      %finish
  3959                      decvar_disp = externalref(external id)
  3960                      ! JDM: Remember the base external displacement
  3961  					decvar_extdisp = decvar_disp
  3962                      decvar_level = 0
  3963                      decvar_scope = EXT
  3964                      %return
  3965                  %finish
  3966  
  3967                  %if (in params = 0) %start
  3968                      ! NOT A PARAMETER
  3969                      potype = otype
  3970                      %if (new # 0) %start
  3971                          ! NEW NAME
  3972                          decvar_disp = new tag
  3973                          ! Procedure ID
  3974                      %finish
  3975                      block name = internal id %if (spec = 0)
  3976                      %return
  3977                  %finish
  3978  
  3979                  otype = 0
  3980                  size = word size
  3981                  data size = word size
  3982                  ! procedure parameter
  3983  
  3984              %else
  3985                  ! This is not a procedure declaration
  3986                  data size = size
  3987                  %if (form # simple) %start
  3988                      Round = Align
  3989                      %if (type = general) %start
  3990                          ! General %name
  3991                          ! FOR LABELS
  3992                          decvar_extra = in params
  3993                          size = word size * 2
  3994                      %finish %else %if (form = array) %or (form = name array) %start
  3995                          ! We will fill in dimensions and allocate space when
  3996                          ! we are told the bounds later
  3997                          size = 0
  3998                          data size = word size %if (form = name array)
  3999                      %finish %else %if (form = array name) %or (form = name array name) %start
  4000                          ! array header
  4001                          decvar_dim = dimension
  4002                          size = word size * 2
  4003                          ! array header
  4004                          round = align
  4005                      %else
  4006                          size = word size;                       ! integer (etc) %name
  4007                      %finish
  4008                  %finish
  4009              %finish
  4010  
  4011              ! Now deal with OWN (or const/extern/etc) data items
  4012              %if (otype # 0) %start
  4013                  ! OWN DATA
  4014                  %if (otype = con) %start
  4015                      ! CONST INTEGER ETC.
  4016                      ! use actual size for plain strings
  4017                      data size = 0 %if (type = string) %and (form = simple)
  4018                      %if (form = name) %or (form = arrayname) %or (form = namearrayname) %start
  4019                          ! Treat as special later
  4020                          otype = 0
  4021                      %finish
  4022                  %else
  4023                      ! OWN, not CONST
  4024                      ! so make it even if needed
  4025                      gfix(round)
  4026                  %finish
  4027                  ! set globals used by our data collection utilities
  4028                  own type = type
  4029                  own form = form
  4030  
  4031                  ! %name's are really integers
  4032                  own type = integer %and data size = word size %if (form = 2)
  4033  
  4034                  %if (spec = 0) %start
  4035                      %if (form = array) %or (form = name array) %start
  4036                          gfix(align)
  4037                          ! N.B.  changes vlb, vub
  4038                          dv = set dope vector( data size, array entry type )
  4039                          ! We treat OWN and CONST arrays identically - both are in data segment
  4040                          gfix(align)
  4041                          decvar_disp = datatp - vlb;
  4042                          decvar_level = 0
  4043                          decvar_scope = DATA
  4044  
  4045                          ! save the dope vector pointer here
  4046                          decvar_pbase = dv
  4047                          ! own arrays are always 1-D
  4048                          decvar_dim = 1
  4049                      %finish
  4050                      fill external(DATA, decvar_disp, external id) %if (otype = external)
  4051                  %else
  4052                      decvar_level = 0
  4053                      decvar_scope = EXT
  4054                      decvar_disp = external ref(external id)
  4055  					! JDM: We have a reference to external data so note the external ref id
  4056  					!      inside the _extdisp field
  4057  					!      _extdisp will NEVER be modified unlike _disp
  4058  					!      Eventually it will be used when generating ABSEXT ibj records
  4059                      !      The difference between _disp and _extdisp represents the offset
  4060                      !      from the location specified by _disp
  4061                      !      offset == _extdisp - _disp
  4062                      decvar_extdisp = decvar_disp
  4063                  %finish
  4064              %finish %else %if (form = label) %start
  4065                  !%label
  4066                  decvar_disp = new tag
  4067              %finish %else %if (form = switch) %start
  4068                  size = vub - vlb
  4069                  %if (swtp + size > Max Switch) %then abort("Switch Table Full")
  4070                  decvar_scope = SWT
  4071                  decvar_disp = swtp - vlb
  4072                  decvar_extra = set dope vector( data size, switch )
  4073                  %for s = swtp, 1, swtp + size %cycle
  4074                      ! should really deal with undefined switch entries
  4075                      swtab(s) = 0
  4076                  %repeat
  4077                  swtp = swtp + size + 1
  4078              %finish %else %if (form = record format) %start
  4079                  %if (in params # 0) %start
  4080                      frame = decvar_size %if (decvar_size > frame)
  4081                  %else
  4082                      block type = -1
  4083                      spec = -1
  4084                  %finish
  4085              %finish %else %start
  4086                  ! Here we've got an ordinary local variable, parameter or record entry
  4087                  decvar_level = level
  4088                  %if (in params = 0) %start
  4089                      ! local variable
  4090                      frame = (frame - size) & (\round)
  4091                      decvar_disp = frame
  4092                  %finish %else %if (block type > 0) %start
  4093                      ! procedure parameters
  4094                      ! parameters are always word aligned
  4095                      frame = (frame + size + align) & (\align)
  4096  
  4097                      ! offset will be adjusted at iCode '}'
  4098                      decvar_disp = frame
  4099                  %finish %else %start
  4100                      ! records
  4101                      frame = (frame + round) & (\round)
  4102                      decvar_disp = frame
  4103                      frame = frame + size
  4104  
  4105                      ! no base register
  4106                      decvar_level = 0
  4107                  %finish
  4108              %finish
  4109          %end
  4110          !    Define Var
  4111  
  4112          !---------------------------------------------------------------------
  4113          ! Stack manipulation routines
  4114          !---------------------------------------------------------------------
  4115          !                                                      >> POP STACK <<
  4116          ! Pop the top of the stack
  4117          %routine  Pop Stack
  4118              %if (stp = 0) %then abort("Pop")
  4119              monitor(top, "Pop") %if (diagnose&1 # 0)
  4120              stp = stp - 1
  4121              %if (stp # 0) %then top == stack(stp) %else top == null
  4122          %end
  4123  
  4124          !                                                      >> POP REL <<
  4125          ! Pop the top of the stack, and release its' register
  4126          %routine  pop rel
  4127              release(top_base)
  4128              pop stack
  4129          %end
  4130  
  4131          %constbyteintegerarray fmap(0:15) =
  4132+                  0, V in S,    A in S, pgm label, recordformat,         0,        switch,       0,
  4133+         {     void, simple,      name,     label, recordformat,         ?,        switch, routine, }
  4134+             V in R, V in S,    V in R,    V in S,       A in S,    V in S,        A in S,       0
  4135          { function,    map, predicate,     array,    arrayname, namearray, namearrayname,       ?  }
  4136  
  4137          !                                                           >> STACK VAR <<
  4138          ! Push a descriptor on the stack corresponding to Var "var no"
  4139          ! We map the variable form to a stack form, and assign a register
  4140          ! for the base if it is non local.  Finally, we absorb the scope
  4141          ! into the base register.
  4142          %routine  Stack Var(%integer  var no)
  4143              %record(varfm)%name  w
  4144  
  4145              abort("Stack Var Idx") %unless 0 <= var no %and var no <= max vars
  4146              w == var(varno)
  4147              stp = stp + 1
  4148              %if (stp > Max Stack) %then abort("Push V Stack Overflow")
  4149              top == stack(stp)
  4150              top = 0
  4151  
  4152              ! Translate "level" into "base register" - if it is non local
  4153              ! we flag it by adding 16 to the desired level, which later will
  4154              ! force us to pick up a pointer register
  4155              %if (w_level # 0) %start
  4156                  %if (w_level = level) %then top_base = BP %else top_base = w_level + 16
  4157              %else
  4158                  top_base = 0
  4159              %finish
  4160  
  4161              ! AFORM contains the real original declared form, while
  4162              ! FORM contains the on-the-stack subset of possible forms
  4163              top_aform = w_form
  4164              top_form = fmap(w_form)
  4165              top_dim = w_dim
  4166              top_type = w_type
  4167              top_disp = w_disp
  4168  			top_extdisp = w_disp
  4169              top_scope = w_scope
  4170              top_format = w_format
  4171              top_size = w_size
  4172              top_extra = w_extra
  4173              top_pbase = w_pbase
  4174  
  4175              ! JDM remember variable name via varno
  4176              top_varno = varno
  4177  
  4178              monitor(top, "Var stack") %if (diagnose&1 # 0)
  4179          %end
  4180  
  4181          !                                                      >> LOAD VAR <<
  4182          ! Load a var onto the stack (using StackVar)
  4183          ! JDM JDM this is a wrapper to ensure when reading the iCode data
  4184          ! the iCode data is listed only once.
  4185          ! Why? because Stack Var is used in many locations
  4186          %routine  Load Var(%integer  var no)
  4187  
  4188              ! JDM JDM debug show the iCode instruction
  4189              %if (ShowIcode=1) %start
  4190                  ListICode
  4191                  spaces(4)
  4192                  printstring( itos(var No,0) )
  4193                  printsymbol( ',' )
  4194                  printsymbol( '"' )
  4195                  printstring( var(varno)_id name )
  4196                  printsymbol( '"' )
  4197                  newline
  4198              %finish
  4199              ! JDM JDM end debug
  4200  
  4201              StackVar( var no )
  4202          %end
  4203  
  4204          !                                                      >> PUSH COPY <<
  4205          ! Push a duplicate of a stack record onto the stack
  4206          %routine  push copy(%record(stackfm)%name  v)
  4207              stp = stp + 1
  4208              %if (stp > Max Stack) %then abort("Stack Copy")
  4209              top == stack(stp)
  4210              top = v
  4211  
  4212              monitor(top, "Stack Copy") %if (diagnose&1 # 0)
  4213          %end
  4214  
  4215          !                                                      >> PUSH CONST <<
  4216          ! Push a constant on the stack
  4217          %routine  push const(%integer  n)
  4218              stp = stp + 1
  4219              %if (stp > Max Stack) %then abort("Stack Const")
  4220              top == stack(stp)
  4221              top = 0
  4222              top_disp = n
  4223  			top_extdisp = 0
  4224              top_type = integer
  4225              top_form = constant
  4226              monitor(top, "push const") %if (diagnose&1 # 0)
  4227          %end
  4228  
  4229          ! Load a const onto the stack (using Push Const)       >> PUSH CONST <<
  4230          ! JDM JDM this is a wrapper to ensure when reading the iCode data
  4231          ! the iCode data is listed only once.
  4232          ! Why? because Push Const is used in many locations
  4233          %routine  Load Const(%integer  n)
  4234  
  4235              ! JDM JDM debug show the iCode instruction
  4236              %if (ShowIcode=1) %start
  4237                  ListICode
  4238                  spaces(4)
  4239                  printstring( itos(N,0) )
  4240                  newline
  4241              %finish
  4242              ! JDM JDM end debug
  4243          
  4244              push const( n )
  4245          %end
  4246  
  4247          !---------------------------------------------------------------------
  4248          !STRING PROCESSING
  4249          !---------------------------------------------------------------------
  4250          !                                                      >> INPUT STRING VALUE<<
  4251          ! Read a string literal from the iCode stream
  4252          %routine  Input String Value( %string(255) s)
  4253              %integer  i
  4254  
  4255              ! JDM JDM debug show the iCode instruction
  4256              %if (ShowIcode=1) %start
  4257                  ListICode
  4258                  spaces(4)
  4259                  printsymbol( '"' )
  4260                  printstring( s )
  4261                  printsymbol( '"' )
  4262                  newline
  4263              %finish
  4264              ! JDM JDM end debug
  4265  
  4266  			current string(0)= length(s)
  4267  			%for i = 1,1,length(s) %cycle
  4268  				current string(i) = charno(s,i)
  4269  			%repeat
  4270  
  4271              ! if this is about to be used as a literal, put it straight into
  4272              ! the CONST segment and stack it, otherwise leave it in curr string to see
  4273              ! what comes next and stack a dummy zero
  4274              ! 
  4275              %if (Pending # 'A') %and (Pending # '$') %start
  4276                  otype = con;        ! anonymous %const
  4277                  push const( getcots(current string) );
  4278  				top_type = string
  4279                  top_base = 0;
  4280  				top_scope = COT;
  4281  				top_form = V in S;
  4282  				top_format = current string(0)+1
  4283              %else
  4284                  ! explicit string initialisation coming next
  4285                  push const(0)
  4286              %finish
  4287          %end
  4288  
  4289  		%routine Get Alias Value( %string(255) s )
  4290  
  4291              ! JDM JDM debug show the iCode instruction
  4292              %if (ShowIcode=1) %start
  4293                  ListICode
  4294                  spaces(4)
  4295                  printsymbol( '"' )
  4296                  printstring( s )
  4297                  printsymbol( '"' )
  4298                  newline
  4299              %finish
  4300              ! JDM JDM end debug
  4301  
  4302  			alias = s
  4303  
  4304  		%end
  4305  
  4306  		%routine Input Real Value( %longreal r)
  4307  
  4308              ! JDM JDM debug show the iCode instruction
  4309              %if (ShowIcode=1) %start
  4310                  ListICode
  4311                  spaces(4)
  4312                  print( r,8 )
  4313                  newline
  4314              %finish
  4315              ! JDM JDM end debug
  4316  
  4317  			%if (r = 0) %then %start
  4318  				push const(0)
  4319  			%else
  4320  				%if (Pending # 'A') %then %start
  4321                      !  anonymous %const
  4322  					otype = con
  4323  					push const(0)
  4324  					top_type = lreal
  4325  					top_scope = COT
  4326                      !  N.B. ** %fn + side-effect **
  4327  					top_disp = getcotdouble(r)
  4328  					top_extdisp = 0
  4329  					top_form = V in S
  4330  				%finish
  4331  			%finish
  4332  			rvalue = r
  4333  		%end
  4334  
  4335          !-------------------------------------------------------
  4336          !LABEL PROCESSING
  4337          !
  4338          ! Labels fixups are handled by pass 3 - we just plant
  4339          ! numerical labels for code locations, and then jump to or call
  4340          ! those labels.  Pass 3 turns them into real locations.
  4341          ! Unfortunately Pass 3 needs unique label numbers whereas
  4342          ! Pass 1 produces lame local label numbers that can
  4343          ! be reused once they've been defined.  We therefore
  4344          ! maintain an indirect database to map Pass 1 label numbers
  4345          ! into unique tags
  4346  
  4347          !                                                      >> NEW TAG <<
  4348          ! Get the next consecutive Pass 3 label ID
  4349          %integerfn  new tag
  4350              %owninteger free tag = 999
  4351  
  4352              free tag = free tag + 1
  4353              %result = free tag
  4354          %end
  4355  
  4356          !                                                      >> NEW LABEL <<
  4357          ! Get the next available label database index
  4358          %integerfn  New Label
  4359              labs = labs+1
  4360              abort("Labels") %if (labs > Max Labs)
  4361              %result = labs
  4362          %end
  4363  
  4364          !                                                        >> FIND LABEL<<
  4365          ! return the index in our label table of the Pass 1 label
  4366          %integerfn  Find Label(%integer  label)
  4367              %integer  lp
  4368  
  4369              lp = labs
  4370              %while (lp # first label) %cycle
  4371                  %result = lp %if (labels(lp)_id = label)
  4372                  lp = lp-1
  4373              %repeat
  4374              %result = 0
  4375          %end
  4376  
  4377          !                                                     >> DEFINE LABEL <<
  4378          ! This label is "here"
  4379          %routine  Define Label(%integer  label)
  4380              %integer lp
  4381              %record(labelfm)%name  l
  4382  
  4383              lp = Find Label(label)
  4384              %if (lp = 0) %start
  4385                  ! Not yet been used
  4386                  lp = New Label
  4387                  l == labels(lp)
  4388                  l_id = label
  4389                  l_tag = new tag
  4390              %else
  4391                  l == labels(lp)
  4392                  %if (l_tag&16_8000 # 0) %and (label > 0) %then l_tag = new tag
  4393              %finish
  4394  
  4395              dump label(l_tag)
  4396              l_tag = l_tag ! 16_8000
  4397              ! You can get here
  4398              uncond jump = 0
  4399          %end
  4400          ! define label
  4401  
  4402          !                                                          >> JUMP TO <<
  4403          ! A wrapper for conditional jumps to labels that we're going
  4404          ! to map into tags
  4405          %routine  Jump To(%integer  label, op, flag)
  4406              %record(labelfm)%name  l
  4407              %integer  lp
  4408  
  4409              lp = Find Label(label)
  4410              %if (lp = 0) %start
  4411                  lp = New Label
  4412                  l == labels(lp)
  4413                  l_id = label
  4414                  l_tag = new tag
  4415              %else
  4416                  l == labels(lp)
  4417                  %if (flag # 0) %and (l_tag&16_8000 # 0) %then l_tag = new tag
  4418              %finish
  4419  
  4420              ! As a side effect, we also set the global J Tag, which is used
  4421              ! in planting Event block information (a bit hacky, but a PSR feature)
  4422              JTag = l_tag & 16_7FFF
  4423  
  4424              dump jump(op, JTag)
  4425  
  4426              %if (op = JMP) %then uncond jump = nextcad
  4427          %end
  4428          ! jump to
  4429  
  4430  		%routine Jump Forward( %integer val, test )
  4431  			%integer opr
  4432  
  4433              ! JDM JDM debug show the iCode instruction
  4434              %if (ShowIcode=1) %start
  4435                  ListICode
  4436                  spaces(4)
  4437                  printsymbol( 'L' )
  4438                  printstring( itos(val,0) )
  4439                  newline
  4440              %finish
  4441              ! JDM JDM end debug
  4442  
  4443  			! FF,TT tests need a value to compare
  4444  			! TT == TRUE (#0)
  4445  			! FF == FALSE (=0)
  4446  			%if (Test = FF) %or (Test = TT) %then dumpri(CMP, AX, 0)
  4447  			! Get the required operator for the test
  4448  			! We may need to amend the choice of operator
  4449  			! depending on the invert/compare unsign "flags"
  4450  			opr = TestToOp( test )
  4451  
  4452  			%if (val = 0) %then %start
  4453  				%if (last skip # next cad) %then %start
  4454  					skip proc = new tag
  4455  					dumpjump(opr, skip proc)
  4456  				%finish
  4457  			%else
  4458  				! Check if we need to reverse the test
  4459  				! So, re-choose the operator
  4460  				%if (invert # 0) %then Test = Reverse( Test )
  4461  				invert = 0;
  4462  
  4463  				! convert the operators to unsigned versions if needed
  4464  				%if (compare unsign # 0) %then opr = TestToUnsignedOp( Test ) %else opr = TestToOp( Test )
  4465  				compare unsign = 0
  4466  
  4467  				jump to(val, opr, 1)
  4468  			%finish
  4469  		%end;				! Jump Forward
  4470  
  4471  		%routine Jump Backward( %integer val )
  4472  
  4473              ! JDM JDM debug show the iCode instruction
  4474              %if (ShowIcode=1) %start
  4475                  ListICode
  4476                  spaces(4)
  4477                  printsymbol( 'L' )
  4478                  printstring( itos(val,0) )
  4479                  newline
  4480              %finish
  4481              ! JDM JDM end debug
  4482  
  4483  			jump to(val, JMP, 0);
  4484  		%end
  4485  
  4486          !-------------------------------------------------------
  4487          ! Stack variable transformations
  4488          !-------------------------------------------------------
  4489          !                                           >> REDUCE <<
  4490          ! Convert a variable which is addressed in a Rec into a simple variable
  4491          ! by loading the indirect value into a register and changing the form
  4492          %routine  reduce(%record(stackfm)%name  v)
  4493              %integer  type, form, disp, scope, extdisp
  4494     
  4495              form = v_form - 3;         ! X in REC => X in S
  4496              type = v_type
  4497              disp = v_disp
  4498  			extdisp = v_extdisp
  4499              ! Here's a trick - we've got two displacements, DISP and EXTRA, but only
  4500              ! one SCOPE hint.  Which does it belong to?  If the REC form came from
  4501              ! a HAZARD then the scope belongs to the DISP, but for all other cases
  4502              ! the scope belongs to the EXTRA.  If we got here through HAZARD then
  4503              ! the BASE will be BP - for all other cases it will be either a different
  4504              ! register, or zero.
  4505              %if (v_base = BP) %start
  4506                  scope = v_scope
  4507                  v_scope = 0
  4508              %else
  4509                  scope = 0
  4510              %finish
  4511              v_disp = v_extra;
  4512  			v_type = integer;
  4513  			v_form = v in s
  4514  
  4515              loadreg(v, anyp)
  4516  
  4517              v_type = type;
  4518  			v_form = form
  4519              v_disp = disp;
  4520  			v_extdisp = extdisp;
  4521  			v_scope = scope
  4522          %end
  4523  
  4524          !                                              >> AMAP <<
  4525          ! convert V into a descriptor for the address of V
  4526          %routine  amap(%record(stackfm)%name  v)
  4527              %integer f
  4528              %constintegerarray  addr map(0:15) =
  4529+             {    0,        1,  2,  3,       4,   5,               6,                   7, }
  4530+                 -1,       -2, -3, -4, AV in S,  -5,          V in S,           AV in REC,
  4531+ 
  4532+             {    8,        9, 10, 11,      12,  13,              14,                  15  }
  4533+                 -6, V in REC, -7, -8,      -9, -10, {PGM LABEL} -11, {record format} -12
  4534  
  4535              ! ABD - should be code here to deal with ADDR(pgm label)
  4536  
  4537              f = addr map(v_form)
  4538              %if (f < 0) %start
  4539                  monitor(v, "AMAP target")
  4540                  abort("AMAP")
  4541              %finish
  4542  
  4543              ! Try to simplify some forms...
  4544              %if (v_disp = 0) %and (v_scope = 0) %start
  4545                  %if (f = A V in S) %start
  4546                      %if (v_base = 0) %then f = constant %else f = V in R
  4547                  %finish %else %if (f = V in REC) %or (f = A V in REC) %start
  4548                      ! eliminate redundant LOAD
  4549                      %if (f = V in REC) %then f = A in S %else f = V in S
  4550                      v_disp = v_extra
  4551                  %finish
  4552              %finish
  4553              v_type = integer
  4554              v_form = f
  4555          %end
  4556  
  4557          !                                              >> VMAP <<
  4558          ! The inverse of AMAP:  i.e. vmap(amap(x)) => x
  4559          %routine  vmap(%record(stackfm)%name  v)
  4560              %integer  f, t
  4561              %constintegerarray  var map(0:8) =
  4562+             {      0,      1,  2,  3,      4,      5,  6,        7,        8 }
  4563+               V in S, V in S, -1, -2, A in S, V in S, -3, A in REC, V in REC
  4564  
  4565              %if (v_form = A in S) %or (v_form = A in REC) %start
  4566                  t = v_type
  4567                  amap(v)
  4568                  loadreg(v,anyp)
  4569                  v_type = t
  4570                  v_form = V in S
  4571              %finish
  4572              f = var map(v_form)
  4573              v_form = f
  4574              abort("VMap") %if (f < 0)
  4575          %end
  4576          !  v map
  4577  
  4578          !                                              >> ADDRESS <<
  4579          ! convert V into a form in which it is directly addressable
  4580          ! that means either V in R, V in S or Constant
  4581          %routine  address(%record(stackfm)%name  v)
  4582              %integer  type, form
  4583     
  4584              monitor(v, "ADDRESS") %if (diagnose&2 # 0)
  4585  
  4586              form = v_form
  4587              type = v_type
  4588              %if (form >= V in REC) %start
  4589                  reduce(v)
  4590                  form = v_form
  4591              %finish
  4592  
  4593              ! Now pick up a base register if we needed one...
  4594              %if (v_base > 16) %start
  4595                  v_base = get display(v_base - 16)
  4596                  claim(v_base)
  4597              %finish
  4598  
  4599              %return %if (form = V in R) %or (form = constant)
  4600  
  4601              %if (form = A V in S) %start
  4602                  %if (v_base = 0) %start
  4603                      v_form = constant
  4604                  %else
  4605                      %if (v_disp = 0) %and (v_scope = 0) %start
  4606                          v_form = V in R
  4607                      %else
  4608                          loadreg(v, any)
  4609                      %finish
  4610                  %finish
  4611                  %return
  4612              %finish
  4613  
  4614              %return %if (form = V in S)
  4615     
  4616              %if (form = A in S) %start
  4617                  v_form = V in S
  4618                  v_type = integer
  4619                  loadreg(v,anyp)
  4620                  v_type = type
  4621                  v_form = V in S
  4622                  v_disp = 0
  4623              %finish
  4624          %end
  4625          ! address
  4626  
  4627          !                                              >> LOAD REG <<
  4628          ! Load variable V into register R
  4629          ! Along the way any register the variable owned is released, and
  4630          ! the new register is claimed.
  4631  		%routine LoadReg(%record(stackfm)%name v, %integer r)
  4632  			%switch f(0:9)
  4633  			%integer ptr, op
  4634  
  4635  			monitor(v, "LOAD") %if (diagnose&2 # 0)
  4636  
  4637  			%if (r = anyf) %start
  4638  				! Equivalents for real numbers...
  4639  				! because there's very little clever we can do, we first simplify somewhat...
  4640  				Address(v)
  4641  				! Now it's either Constant, V in R or V in S - we now turn them
  4642  				! all into V in S - the only thing we can load
  4643  				! Start with one we have no instructions for, and promote it to
  4644  				! something we know how to handle...
  4645  				%if (v_type = byte) %then loadreg(v, any)
  4646  				%if (v_form = V in R) %start
  4647  					%return %if (v_base >= FR0)
  4648  					! This must be an integer in a CPU register - we need to store it
  4649  					! before we can use it
  4650  					v_disp = getwork(word size)
  4651  					dumpmr(MOV, BP, v_disp, v_extdisp, v_base)
  4652  					release(v_base)
  4653  					v_base = BP
  4654  					v_scope = 0
  4655  					v_form = V in S
  4656  					! Now it looks like an integer V in S
  4657  				%finish
  4658  				%if (v_form = constant) %start
  4659                      ! This is an integer constant
  4660  					%if (v_disp = 0) %start
  4661                          ! We have a special instruction for zero
  4662  						r = FR0 + FPU Stack
  4663  						dumpflopspec(FLDZ)
  4664  						v_base = r
  4665  						claim(r)
  4666  						v_disp = 0;
  4667  						v_form = V in R
  4668  						v_type = real
  4669  						%return
  4670  					%finish
  4671  					! Otherwise, we need it in store
  4672  					v_disp = getcotw(v_disp)
  4673  					v_form = V in S
  4674  					v_base = 0
  4675  					v_scope = COT
  4676  				%finish
  4677  
  4678  				! Now everything that's left is a V in S
  4679  				%if (v_type = integer) %start
  4680  					op = FILD
  4681  				%else
  4682  					%if (v_type = real) %start
  4683  						op = FLDD
  4684  					%else
  4685  						op = FLDQ
  4686  					%finish
  4687  				%finish
  4688  
  4689  				! register is going to be the top of stack
  4690  				r = FR0 + FPU Stack
  4691  		
  4692  				dumpfloprm(op, v_base!v_scope, v_disp, v_extdisp )
  4693  				release(v_base)
  4694  				v_base = r
  4695  				claim(r)
  4696  				v_disp = 0;
  4697  				v_form = V in R
  4698  				v_type = real
  4699  				%return
  4700  			%finish
  4701  
  4702  			! If the request is one of the variations on "any" then we need
  4703  			! to first allocate a target register.  First, we make a local
  4704  			! adjustment because we can't load bytes into "any" register,
  4705  			! only into the GP registers...
  4706  			%if (v_type = byte) %start
  4707  				%if (r = any) %then r = anyg
  4708  				! What's more, there is only one register that is both a pointer
  4709  				! and a legal byte destination
  4710  				%if (r = anyp) %then r = BX
  4711  			%finish
  4712  
  4713  			! We also map the virtual display into a real register if we
  4714  			! need to.  Also, it is possible that an in-store form may
  4715  			! be derived from a non-pointer register, so we fix that too.
  4716  			%if (v_base > 16) %then %start
  4717  				v_base = get display(v_base - 16)
  4718  				claim(v_base)
  4719  			%finish
  4720  
  4721  			! Now go ahead and allocate a register
  4722  			%if (r = any) %then %start
  4723  				! If we've got a base,
  4724                  ! it's not in use by anyone else,
  4725                  ! and isn't a display register,
  4726                  ! then use it
  4727  				%if (v_base # 0) %and (activity(v_base) = 1) %and (displayhint(v_base) = 0) %start
  4728  					r = v_base
  4729  				%else
  4730  					r = gp reg
  4731  				%finish
  4732  			%else
  4733  				%if (r = anyg) %then %start
  4734  					%if (0 < v_base <= BX) %and (activity(v_base) = 1) %start
  4735  						r = v_base
  4736  					%else
  4737  						r = gp reg
  4738  					%finish
  4739  				%else
  4740  					%if (r = anyp) %then %start
  4741  						%if (activity(v_base) = 1) %and ((v_base = BX) %or (v_base = SI) %or (v_base = DI)) %then %start
  4742  							r = v_base
  4743  						%else
  4744  							r = pt reg
  4745  						%finish
  4746  					%else
  4747  						%if (v_base = r) %start
  4748  							%if (activity(r) > 1) %start
  4749                                  ! protect other uses
  4750  								release(r)
  4751  
  4752                                  ! Hide my ownership for the moment
  4753                                  v_base = 0
  4754  
  4755                                  ! Zap everybody else
  4756  								hazard(r)
  4757  
  4758                                  ! Get it back
  4759  								claim(r)
  4760                                  v_base = r
  4761  							%finish
  4762  						%else
  4763  							hazard(r)
  4764  						%finish
  4765  					%finish
  4766  				%finish
  4767  			%finish
  4768  			-> f(v_form)
  4769  
  4770  f(V in REC):
  4771  			reduce(v); ->f(v_form)
  4772  
  4773  f(AV in REC):
  4774              reduce(v); ->f(v_form)
  4775  
  4776  f(A in REC):
  4777              reduce(v); ->f(v_form)
  4778  
  4779  f(AV in R): Abort("Unexpected Stack Form")
  4780  
  4781  f(A in R):  Abort("Unexpected Stack Form")
  4782  
  4783  f(constant):
  4784  			%if (v_disp = 0) %and (v_scope = 0) %start
  4785  				dumprr(XOR, r, r)
  4786  			%else
  4787  				dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  4788  			%finish
  4789  			v_base = r
  4790  			v_disp = 0
  4791  			v_scope = 0
  4792  			v_form = V in R
  4793  			claim(r)
  4794  			%return
  4795  
  4796  f(V in R):
  4797              %return %if (v_base = r)
  4798  			dumprr(MOV, r, v_base)
  4799  			release(v_base)
  4800  			v_base = r
  4801  			v_disp = 0
  4802  			v_scope = 0
  4803  			v_form = V in R
  4804  			claim(r)
  4805  			%return
  4806  
  4807  f(A in S):
  4808              ! is the register a pointer?
  4809  			%if (r = BX) %or (r = SI) %or (r = DI) %start
  4810  				ptr = r
  4811  			%else
  4812  				ptr = pt reg
  4813  			%finish
  4814  			dumprm(MOV, ptr, v_base!v_scope, v_disp, v_extdisp )
  4815  			release(v_base)
  4816              claim(ptr)
  4817  			v_base = ptr
  4818  			v_disp = 0
  4819  			v_scope = 0
  4820  			%if (v_type = integer) %start
  4821  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  4822  			%else
  4823  				%if (v_type = byte) %start
  4824  					! watch out for register re-use here...
  4825  
  4826                      ! clear it, but only if it isn't needed
  4827  					%if (r # v_base) %then dumprr(XOR, r, r)
  4828  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  4829  
  4830                      ! otherwise a more expensive clear later
  4831  					%if (r = v_base) %then dumpri(AND, r, 255)
  4832  					v_type = integer
  4833  				%else
  4834                      ! reals
  4835  					abort("Load Real")
  4836  				%finish
  4837  			%finish
  4838  			release(v_base)
  4839  			v_base = r
  4840  			v_disp = 0
  4841  			v_scope = 0
  4842  			v_form = V in R
  4843  			claim(r)
  4844  			%return
  4845  
  4846  f(V in S):
  4847              %if (v_type = integer) %start
  4848  				dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
  4849  			%else
  4850  				%if (v_type = byte) %start
  4851  					! watch out for register re-use here...
  4852  
  4853                      ! clear it, but only if it isn't needed
  4854  					%if (r # v_base) %then dumprr(XOR, r, r)
  4855  					dumprm8(MOV, r+16, v_base!v_scope, v_disp, v_extdisp )
  4856  
  4857                      ! otherwise a more expensive clear later
  4858  					%if (r = v_base) %then dumpri(AND, r, 255)
  4859  					v_type = integer
  4860  				%else
  4861                      ! reals
  4862  					abort("Load Real")
  4863  				%finish
  4864  			%finish
  4865  			release(v_base)
  4866  			v_base = r
  4867  			v_disp = 0
  4868  			v_scope = 0
  4869  			v_form = V in R
  4870  			claim(r)
  4871  			%return
  4872  
  4873  f(A V in S):
  4874  			%if (v_base # 0) %start
  4875  				dumprm(LEA, r, v_base!v_scope, v_disp, v_extdisp )
  4876  				release(v_base)
  4877  				v_type = integer
  4878  			%else
  4879  				! else
  4880  				%if (v_disp = 0) %and (v_scope = 0) %start
  4881  					dumprr(XOR, r, r)
  4882  				%else
  4883  					dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
  4884  				%finish
  4885  			%finish
  4886  			v_base = r
  4887  			v_disp = 0
  4888  			v_scope = 0
  4889  			v_form = V in R
  4890  			claim(r)
  4891  			%return
  4892  		%end
  4893          ! LOAD REG
  4894  
  4895          ! JDM JDM Adapted from Store routine in Assign
  4896          ! Store the register item reg in location given by LHS stackfm.
  4897          ! This only deals with the integer registers.
  4898          ! Store Reg does NOT cater for floating point registers.
  4899          ! The destination can be one of:
  4900          ! 1) Integer
  4901          ! 2) Byte
  4902          ! 3) Name/Pointer
  4903          %routine Store Reg(%record(stackfm)%name lhs, %integer reg)
  4904  
  4905              %if (lhs_base = SP) %start
  4906                  ! it's a push
  4907                  %if (lhs_type = integer) %or (lhs_type = byte) %start
  4908                      dumpur(PUSH, reg)
  4909                  %finish
  4910              %finish %else %if (lhs_type = integer) %start
  4911                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  4912              %finish %else %if (lhs_type = byte) %start
  4913                  dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg+16)
  4914              %finish %else %if (lhs_type = record) %start
  4915                  dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, reg)
  4916              %finish
  4917          %end
  4918          ! STORE REG
  4919  
  4920          !                                              >> OPERATION <<
  4921          ! perform the operation OP on the top two elements of the stack.
  4922          !   (single element for unary operators)
  4923          %routine  Operation(%integer op)
  4924              %record(stackfm)%name  lhs, rhs
  4925              %integer assign pending, work, value, s
  4926              %switch oper(1:17), roper(1:17), fold(1:17)
  4927              %constintegerarray opmap(1:17) = 
  4928+             ADD, SUB, IMUL, IDIV,  0,  AND, OR, XOR, SHL, SHR, IDIV,   0,    0,   0,  NOT, NEG,   0
  4929  
  4930              %constintegerarray flopmap(1:17) = 
  4931+             FADD, FSUB, FMUL, FDIV, 0, 0, 0, 0, 0, 0, 0,   0,   0,    FDIV, 0, FCHS, FABS
  4932  
  4933              %constintegerarray indec(-1:1) = DEC, 0, INC; ! decrement, and increment opcodes
  4934  
  4935              %routine swap
  4936                  %record(stackfm) temp
  4937                  temp = lhs
  4938                  lhs = rhs
  4939                  rhs = temp
  4940              %end
  4941  
  4942              assign pending = 0
  4943              rhs == top
  4944              %if (op < Unaries) %then %start
  4945                  lhs == stack(stp-1)
  4946                  %if (lhs_type = real) %or (lhs_type = lreal) %or (op >= REXPx) %then ->reals
  4947              %finish
  4948  
  4949              %if (rhs_type = real) %or (rhs_type = lreal) %then ->reals
  4950  
  4951              %if (rhs_form = constant) %and ((op >= Unaries) %or (lhs_form = constant)) %then ->fold(op)
  4952  
  4953              ! now look for optimisations for x = x <op> whatever
  4954              %if (Pending = 'S') %or (Pending = 'j') %start
  4955                  ! the next task is an assignment
  4956                  %if (op >= Unaries) %start
  4957                      %if (same(top, stack(stp-1)) # 0) %then assign pending = 1
  4958                  %else
  4959                      %if (same(lhs, stack(stp-2)) # 0) %then assign pending = 1
  4960                  %finish
  4961              %finish
  4962  
  4963              ->oper(op)
  4964  oper(NOTx):
  4965  oper(NEGx):
  4966              ! we optimise for e.g. fred = -fred as one instruction
  4967              %if (assign pending # 0) %then %start
  4968                  read symbol(Pending)
  4969                  address(rhs)
  4970                  %if (rhs_type = byte) %start
  4971                      dumpum8(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  4972                  %else
  4973                      dumpum(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  4974                  %finish
  4975                  pop rel
  4976                  pop rel
  4977                  %return
  4978              %finish
  4979              loadreg(rhs, any)
  4980              dumpur(opmap(op), rhs_base)
  4981              %return
  4982  
  4983              ! 8086 has no "abs" instructions, so we do a test and jump
  4984  oper(ABSx):
  4985              loadreg(rhs, any)
  4986  			dumpri(CMP, rhs_base, 0)
  4987              work = new tag
  4988              dumpjump(JGE, work)
  4989              dumpur(NEG, rhs_base)
  4990              dumplabel(work)
  4991              %return
  4992  
  4993  oper(ADDX):
  4994              %if (lhs_form = constant) %then swap
  4995              ! and fall through to minus
  4996  oper(SUBx):
  4997              ! First look for fred = fred + <whatever>
  4998              ! We can only safely do this for bytes if we're jamming or ignoring overflow
  4999              %if (assign pending # 0) %and %c
  5000+                 ((lhs_type = integer) %or ((control & check capacity) = 0) %or (Pending = 'j')) %then %start
  5001  
  5002                  ! we will do the assignment ourselves
  5003                  readsymbol(Pending)
  5004  
  5005                  ! make LHS accessible
  5006                  address(lhs)
  5007                  %if (rhs_form = constant) %then %start
  5008                      value = rhs_disp
  5009                      %if (value # 0) %start
  5010                          %if (op = SUBx) %then value = -value
  5011                          ! look for increment or decrement instructions
  5012                          %if (-2 < value < 2) %then %start
  5013                              %if (lhs_type = byte) %start
  5014                                  dumpum8(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  5015                              %else
  5016                                  dumpum(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  5017                              %finish
  5018                          %else
  5019                              %if (lhs_type = byte) %start
  5020                                  dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5021                              %else
  5022                                  dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5023                              %finish
  5024                          %finish
  5025                      %finish
  5026                  %else
  5027                      ! RHS not a constant
  5028                      loadreg(rhs, any)
  5029                      %if (lhs_type = byte) %start
  5030                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  5031                      %else
  5032                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  5033                      %finish
  5034                  %finish
  5035                  pop rel
  5036                  pop rel
  5037                  pop rel
  5038                  %return
  5039              %finish
  5040  
  5041              ! So, there is no assign pending        
  5042              %if (rhs_form = constant) %then %start
  5043                  value = rhs_disp
  5044                  %if (op = SUBx) %then value = -value
  5045                  ! If it is already an address, do the math on the address offset
  5046                  %if (lhs_form = AV in S) %or (lhs_form = AV in Rec) %start
  5047                      lhs_disp = lhs_disp + value
  5048                  %else
  5049                      loadreg(lhs, any)
  5050                      ! We don't particularly try for it, but if we ended up with a pointer
  5051                      ! register, we might as well convert this to use the address form...
  5052                      %if (lhs_base = BX) %start
  5053                          ! BX is the only GP reg that's also a pointer
  5054                          lhs_form = AV in S
  5055                          lhs_disp = value
  5056                      %else
  5057                          ! otherwise, don't bother deferring the operation
  5058                          ! look for increment or decrement instructions
  5059                          %if (-2 < value < 2) %then %start
  5060                              %if (value # 0) %then dumpur(indec(value), lhs_base)
  5061                          %else
  5062  							dumpri(opmap(op), lhs_base, rhs_disp)
  5063                          %finish
  5064                      %finish
  5065                  %finish
  5066              %else
  5067                  ! not a constant
  5068                  ! commutative?, so flip it
  5069                  %if (op = ADDx) %and (rhs_form = V in R) %then swap
  5070                  loadreg(lhs, any)
  5071                  %if (rhs_type = byte) %start
  5072                      loadreg(rhs, any)
  5073                  %else
  5074                      address(rhs)
  5075                  %finish
  5076                  dumprv(opmap(op), lhs_base, rhs)
  5077              %finish
  5078  
  5079              ! the RHS
  5080              pop rel
  5081              %return
  5082  oper(ANDx):
  5083  oper(ORx):
  5084  oper(XORx):
  5085              !  Logical ops are a subset of ADD - similar behaviour, but no inc/dec/addr short forms
  5086              %if lhs_form = constant %then swap
  5087              ! First look for fred = fred <op> <whatever>
  5088              %if (assign pending # 0) %then %start
  5089                  ! we will do the assignment ourselves
  5090                  readsymbol(Pending)
  5091  
  5092  				! make LHS accessible
  5093                  address(lhs)
  5094                  %if (rhs_form = constant) %then %start
  5095                      value = rhs_disp
  5096                      %if (lhs_type = byte) %start
  5097                          warn(8) %if (rhs_disp&(\255) # 0)
  5098                          dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5099                      %else
  5100                          dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5101                      %finish
  5102                  %else
  5103                      ! RHS not a constant
  5104                      loadreg(rhs, any)
  5105                      %if (lhs_type = byte) %start
  5106                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  5107                      %else
  5108                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  5109                      %finish
  5110                  %finish
  5111  
  5112                  ! RHS
  5113                  pop rel
  5114  
  5115                  ! LHS
  5116                  pop rel
  5117  
  5118                  ! Assignment destination
  5119                  pop rel
  5120  
  5121                  %return
  5122              %finish
  5123  
  5124              ! So, there is no assign pending        
  5125              %if (rhs_form = constant) %then %start
  5126                  value = rhs_disp
  5127                  loadreg(lhs, any)
  5128  				dumpri(opmap(op), lhs_base, value)
  5129              %else
  5130                  ! not a constant
  5131                  ! all these are commutative, so flip it to make it easier
  5132                  %if (rhs_form = V in R) %then swap
  5133                  loadreg(lhs, any)
  5134                  %if (rhs_type = byte) %and (op = ANDx) %start
  5135                      ! AND needs all the bits to make sense
  5136                      ! NB Load changes type to Integer
  5137                      loadreg(rhs, any)
  5138                  %else
  5139                      address(rhs)
  5140                  %finish
  5141                  %if (rhs_type = byte) %start
  5142                      ! must be V in S - everything else would be Integer
  5143                      dumprm8(opmap(op), lhs_base+16, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5144                  %else
  5145                      dumprv(opmap(op), lhs_base, rhs)
  5146                  %finish
  5147              %finish
  5148  
  5149              ! the RHS
  5150  			pop rel
  5151  
  5152              %return
  5153  
  5154  oper(MULx):
  5155              %if (lhs_form = constant) %or (rhs_base = AX) %then swap
  5156              %if (rhs_form = constant) %then %start
  5157                  value = rhs_disp
  5158                  %if (value = 0) %then %start
  5159                      ! mul by zero is zero
  5160                      release(lhs_base)
  5161                      lhs = rhs
  5162                      pop stack
  5163                      %return
  5164                  %finish
  5165                  %if (value = 1) %then %start
  5166                      ! mul by 1 is the identity
  5167                      pop stack
  5168                      %return
  5169                  %finish
  5170  
  5171                  ! find a shift factor
  5172                  s = mulshift(value)
  5173                  %if (s > 0) %then %start
  5174                      rhs_disp = s
  5175                      op = LSHx
  5176                      -> shift it
  5177                  %finish
  5178                  ! 8086 multiply instruction doesn't have an immediate operand form
  5179                  ! so we use an entry in the constant table...
  5180                  rhs_base = 0
  5181                  rhs_scope = COT
  5182                  rhs_disp = getcotw(value)
  5183                  rhs_form = V in S
  5184                  ! and fall through to the not-a-constant path
  5185              %finish
  5186  do mul:
  5187              loadreg(lhs, AX)
  5188              address(rhs)
  5189              hazard(DX)
  5190              %if (rhs_form = V in R) %start
  5191                  dumpur(IMUL, rhs_base)
  5192              %else
  5193                  dumpum(IMUL, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5194              %finish
  5195              pop rel
  5196              %return
  5197  oper(DIVx):
  5198  oper(REMx):
  5199              loadreg(lhs, AX)
  5200              address(rhs)
  5201              hazard(DX)
  5202              dumpsimple(CWD)
  5203              ! Plain 8086 Divide instruction also has no immediate operand form, so
  5204              ! we move constants to the COT
  5205              %if (rhs_form = constant) %start
  5206                  %if (rhs_disp = 0) %then warn(1)
  5207                  rhs_base = 0
  5208                  rhs_scope = COT
  5209                  rhs_disp = getcotw(rhs_disp)
  5210                  rhs_form = V in S
  5211              %finish
  5212              %if (rhs_form = V in R) %start
  5213                  dumpur(IDIV, rhs_base)
  5214              %else
  5215                  dumpum(IDIV, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5216              %finish
  5217              pop rel
  5218              %if (op = DIVx) %then %start
  5219                  lhs_base = AX
  5220              %else
  5221                  lhs_base = DX
  5222                  release(AX)
  5223                  claim(DX)
  5224              %finish
  5225              %return
  5226  oper(LSHx):
  5227  oper(RSHx):
  5228  shift it:
  5229              %if (assign pending # 0) %and %c
  5230+                 ((op = RSHx) %or (lhs_type = integer) %or (control&check capacity = 0) %or (Pending = 'j')) %then %start
  5231                  ! we will do the assignment ourselves
  5232                  readsymbol(Pending)
  5233  
  5234                  ! make LHS accessible
  5235                  address(lhs)
  5236                  %if (rhs_form = constant) %start
  5237                      warn(6) %unless (0 <= rhs_disp <= 31)
  5238                      %if (rhs_disp # 0) %start
  5239                          ! shift by zero is a no-op
  5240                          %if (lhs_type = byte) %start
  5241                              dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5242                          %else
  5243                              dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5244                          %finish
  5245                      %finish
  5246                  %else
  5247                      ! RHS not a constant
  5248                      ! Since the shift instruction only uses the bottom 5 bits of the
  5249                      ! value in CX, the value is "byte safe".  Rather than do a full
  5250                      ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  5251                      ! to save redundant coding
  5252                      %if (rhs_type = byte) %start
  5253                          hazard(CX)
  5254                          address(rhs)
  5255                          dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5256                      %else
  5257                          loadreg(rhs,CX)
  5258                      %finish
  5259                      %if (lhs_type = byte) %start
  5260                          dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CL)
  5261                      %else
  5262                          dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CX)
  5263                      %finish
  5264                  %finish
  5265  
  5266                  ! RHS
  5267                  pop rel
  5268                  ! LHS
  5269                  pop rel
  5270                  ! Assignment destination
  5271                  pop rel
  5272                  %return
  5273              %finish
  5274  
  5275              ! deal with constant shifts first...
  5276              %if (rhs_form = constant) %then %start
  5277                  value = rhs_disp
  5278                  warn(6) %unless (0 <= value <= 31)
  5279                  %if (value # 0) %start
  5280                      loadreg(lhs, any)
  5281  					dumpri(opmap(op), lhs_base, value)
  5282                  %finish
  5283              %else
  5284                  ! RHS variable
  5285                  ! Since the shift instruction only uses the bottom 4 bits of the
  5286                  ! value in CX, the value is "byte safe".  Rather than do a full
  5287                  ! "loadreg(rhs,CX)" we therefore fiddle about and do it the hard way
  5288                  ! to save redundant coding
  5289                  %if (rhs_type = byte) %start
  5290                      hazard(CX)
  5291                      address(rhs)
  5292                      dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
  5293                      release(rhs_base)
  5294                      rhs_base = CX
  5295                      claim(CX)
  5296                  %else
  5297                      loadreg(rhs,CX)
  5298                  %finish
  5299                  loadreg(lhs, any)
  5300                  dumprr(opmap(op), lhs_base, CX);
  5301              %finish
  5302              pop rel
  5303              %return
  5304  oper(EXPx):
  5305              %if (rhs_form = constant) %then %start
  5306                  %if (rhs_disp = 0) %start
  5307                      pop rel
  5308                      pop rel
  5309                      push const(1)
  5310                      %return
  5311                  %finish
  5312                  %if (rhs_disp = 1) %then %start
  5313                      pop rel
  5314                      %return
  5315                  %finish
  5316                  %if (rhs_disp = 2) %then %start
  5317                      rhs = lhs
  5318                      claim(rhs_base)
  5319                      ->do mul
  5320                  %finish
  5321              %finish
  5322              loadreg(rhs, any)
  5323              dumpur(PUSH, rhs_base)
  5324              pop rel
  5325              loadreg(lhs, any)
  5326              dumpur(PUSH, lhs_base)
  5327              release(lhs_base)
  5328              perm(iexp, 2)
  5329              
  5330              lhs_base = AX
  5331              claim(AX)
  5332              lhs_form = V in R
  5333              %return
  5334  oper(REXPx):
  5335  oper(RDIVx):
  5336              abort("Oper unexpected op")
  5337  
  5338              !-----------------------------------------------
  5339              ! Fold constant expressions at compile time
  5340  fold(NEGx):
  5341              value = -rhs_disp; -> set unary
  5342  fold(NOTx):
  5343              value = \rhs_disp; -> set unary
  5344  fold(ABSx):
  5345              value = rhs_disp; %if (value < 0) %then value = -value; -> set value
  5346  fold(ADDx):
  5347              value = lhs_disp + rhs_disp; -> set value
  5348  fold(SUBx):
  5349              value = lhs_disp - rhs_disp; -> set value
  5350  fold(ORx):
  5351              value = lhs_disp ! rhs_disp; -> set value
  5352  fold(ANDx):
  5353              value = lhs_disp & rhs_disp; -> set value
  5354  fold(XORx):
  5355              value = lhs_disp !! rhs_disp; -> set value
  5356  fold(LSHx):
  5357              value = lhs_disp << rhs_disp; -> set value
  5358  fold(MULx):
  5359              value = lhs_disp * rhs_disp; -> set value
  5360  fold(RSHx):
  5361              value = lhs_disp >> rhs_disp; -> set value
  5362  fold(EXPx):
  5363              %if (rhs_disp < 0) %then abort("Fold -ve Exp")
  5364  			value = 1
  5365              %for op=1, 1, rhs_disp %cycle
  5366                  value = value * lhs_disp
  5367              %repeat
  5368              -> set value
  5369  fold(REMx):
  5370  fold(DIVx):
  5371              value = rhs_disp;
  5372              warn(1) %and value = 1 %if (value = 0)
  5373              value = lhs_disp // value
  5374              %if (op = DIVx) %then -> set value
  5375              value = lhs_disp - (rhs_disp * value)
  5376              -> set value
  5377  fold(REXPx):
  5378              abort("Fold REXPx - Not implemented")
  5379  fold(RDIVx):
  5380              abort("Fold RDIVx - Not implemented")
  5381  
  5382  set value:
  5383              pop stack
  5384  set unary:
  5385              top_disp = value
  5386              %return
  5387  fold(CONCx):
  5388              abort("Fold CONCx - Not implemented")
  5389  
  5390              !--------------------------------------------------------------------
  5391              ! String operations - the only one is concatenate...
  5392  oper(CONCx):
  5393              %if (assign pending # 0) %start
  5394                  ! It's S = S.T
  5395                  amap(lhs)
  5396                  loadreg(lhs, any)
  5397                  dumpur(PUSH, lhs_base)
  5398                  amap(rhs)
  5399                  loadreg(rhs, any)
  5400                  dumpur(PUSH, rhs_base)
  5401                  pop rel
  5402                  pop rel
  5403                  dumppushi(0, lhs_size, 0)
  5404                  %if (Pending = 'S') %then perm(sconc, 3) %else perm(sjconc, 3)
  5405                  ! and finally, skip the pending assignment, and drop the LHS
  5406                  readsymbol(Pending)
  5407                  pop rel
  5408                  %return
  5409              %finish
  5410  
  5411              ! here we've got T.U - if T is already in a WORK location
  5412              ! we've got a simple append.  If it is a user variable, we've
  5413              ! got to both copy it to a temp area and do the append
  5414              %if (Is Work(lhs) = 0) %start
  5415                  ! Not a work area
  5416                  work = getwork(256)
  5417                  push const(work)
  5418                  top_form = av in s
  5419                  top_base = BP
  5420                  loadreg(top, any)
  5421                  dumpur(PUSH, top_base)
  5422                  pop rel
  5423                  amap(lhs)
  5424                  loadreg(lhs, any)
  5425                  dumpur(PUSH, lhs_base)
  5426                  release(lhs_base)
  5427                  dumppushi(0, 255, 0)
  5428                  perm(smove, 3)
  5429                  ! Now we need to redefine the LHS as our temporary area
  5430                  ! gratuitous clear-it-all-out
  5431                  lhs = 0
  5432                  lhs_type = string
  5433                  lhs_form = V in S
  5434                  lhs_base = BP
  5435                  lhs_disp = work
  5436                  lhs_size = 255
  5437              %finish
  5438  
  5439              ! Here we are doing an in-situ concatenation
  5440              ! We want to leave the result as a normal variable, so we
  5441              ! suck up a copy for the AMAP fiddling
  5442              push copy(lhs)
  5443              amap(top)
  5444              loadreg(top, any)
  5445              dumpur(PUSH, top_base)
  5446              poprel
  5447              amap(rhs)
  5448              loadreg(rhs, any)
  5449              dumpur(PUSH, rhs_base)
  5450              pop rel
  5451              dumppushi(0, lhs_size, 0)
  5452              perm(sconc, 3)
  5453              %return
  5454  Reals:
  5455              %if (op < Unaries) %then loadreg(lhs, anyf)
  5456              %if (op # REXPx) %then loadreg(rhs, anyf)
  5457              ->roper(op)
  5458  
  5459  roper(NEGx):
  5460  roper(ABSx):
  5461              dumpfloprr(flopmap(op), rhs_base, rhs_base)
  5462              %return
  5463  
  5464  roper(ADDx):
  5465  roper(MULx):
  5466              ! Commutative, so we don't care
  5467              %if (lhs_base > rhs_base) %then swap
  5468              dumpfloprr(flopmap(op), lhs_base, rhs_base)
  5469              pop rel
  5470              %return
  5471  
  5472  roper(SUBx):
  5473  roper(DIVx):
  5474  roper(RDIVx):
  5475              ! We can't swap these, so we use the reverse form of
  5476              ! the opcode (which in our internal form is always one
  5477              ! more than the basic opcode index)
  5478              op = flopmap(op)
  5479              %if (lhs_base > rhs_base) %start
  5480                  swap
  5481                  op = op + 1
  5482              %finish
  5483              dumpfloprr(op, lhs_base, rhs_base)
  5484              pop rel
  5485              %return
  5486  
  5487  roper(REXPx):
  5488              ! This is implemented as a PERM routine
  5489              loadreg(rhs, any)
  5490              dumpur(PUSH, rhs_base)
  5491              pop rel
  5492              ! The usual slightly clunky floating point "push"
  5493              work = ptreg
  5494  			dumpri(SUB, SP, 8)
  5495              dumprr(MOV, work, SP)
  5496              dumpfloprm(FSTQ, work, 0, 0)
  5497              release(lhs_base)
  5498              perm(fexp, 1 + (8//word size))
  5499              ! Since rexp is actually a standard C routine, the result will
  5500              ! be on the FPU stack
  5501              ! JDM JDM All perm routines have been re-written in IMP
  5502              lhs_base = FR0
  5503              claim(FR0)
  5504              fpu stack = 1
  5505              lhs_form = V in R
  5506              lhs_type = lreal
  5507              %return
  5508  
  5509  roper(NOTx):
  5510  			abort("NOTx: Unsupported Real Operation")
  5511  roper(ANDx):
  5512  			abort("ANDx: Unsupported Real Operation")
  5513  roper(ORx):
  5514  			abort("ORx: Unsupported Real Operation")
  5515  roper(XORx):
  5516  			abort("XORx: Unsupported Real Operation")
  5517  roper(REMx):
  5518  			abort("REMx: Unsupported Real Operation")
  5519  roper(LSHx):
  5520  			abort("LSHx: Unsupported Real Operation")
  5521  roper(RSHx):
  5522  			abort("RSHx: Unsupported Real Operation")
  5523  roper(EXPx):
  5524  			abort("EXPx: Unsupported Real Operation")
  5525  
  5526          %end
  5527          !     Operation
  5528  
  5529          !                                              >> LOAD OPERATION <<
  5530          ! perform the operation OP on the top two elements of the stack.
  5531          !   (single element for unary operators)
  5532          ! This is a wrapper to Operation
  5533          ! It avoids multiple dumps of the Operation iCode instruction 
  5534          %routine  Load Operation(%integer op)
  5535  
  5536              ! JDM JDM debug show the iCode instruction
  5537              %if (ShowIcode=1) %start
  5538                  ListICodeNoOp
  5539              %finish
  5540              ! JDM JDM end debug
  5541  
  5542              Operation( op )
  5543          %end
  5544  
  5545          ! Store the item in RHS to LHS.  Encapsulates the difficulties
  5546          ! of variable length items and pushing things on the stack to
  5547          ! keep the rest of "Assign" looking tidy
  5548          %routine Store(%record(stackfm)%name lhs, rhs)
  5549              %integer pt, s, op
  5550  
  5551              %if (lhs_base = SP) %start
  5552                  ! it's a push
  5553                  %if (lhs_type = integer) %or (lhs_type = byte) %start
  5554                      %if (rhs_type = byte) %start
  5555                          loadreg(rhs, any)
  5556                      %else
  5557                          address(rhs)
  5558                      %finish
  5559                      dumpvpush(rhs)
  5560                  %else
  5561                      ! must be a real
  5562                      %if (lhs_type = real) %start
  5563                          s = 4
  5564                          op = FSTD
  5565                      %else
  5566                          s = 8
  5567                          op = FSTQ
  5568                      %finish
  5569                      loadreg(rhs, anyf)
  5570                      pt = ptreg
  5571                      dumpri(SUB, SP, s)
  5572                      dumprr(MOV, pt, SP)
  5573                      dumpfloprm(op, pt, 0, 0)
  5574                  %finish
  5575                  %return
  5576              %finish
  5577  
  5578              %if (lhs_type = integer) %start
  5579                  %if (rhs_form = constant) %and (rhs_scope = 0) %start
  5580                      dumpmi(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5581                  %else
  5582                      loadreg(rhs, any)
  5583                      dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
  5584                  %finish
  5585              %else
  5586                  %if (lhs_type = byte) %start
  5587                      %if (rhs_form = constant) %and (rhs_scope = 0) %start
  5588                          dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
  5589                      %else
  5590                          %if (rhs_type = byte) %start
  5591                              ! try to avoid pointless promoting to an int
  5592                              ! We will reproduce a "Load" but without the word extension
  5593                              address(rhs)
  5594                              pt = gp reg
  5595                              dumprm8(MOV, pt+16, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
  5596                              release(rhs_base)
  5597                              rhs_base = pt
  5598                              rhs_form = V in R
  5599                              rhs_type = Integer
  5600                              claim(pt)
  5601                          %else
  5602                              loadreg(rhs, any)
  5603                              ! ABD - should add a capacity check here
  5604                          %finish
  5605                          dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base+16)
  5606                      %finish
  5607                  %else
  5608                      loadreg(rhs, anyf)
  5609                      %if (lhs_type = real) %start
  5610                          op = FSTD
  5611                      %else
  5612                          ! long real
  5613                          op = FSTQ
  5614                      %finish
  5615                      dumpfloprm(op, lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
  5616                  %finish
  5617              %finish
  5618          %end
  5619  
  5620          !                                                          >> ASSIGN <<
  5621          ! ASSOP =   -1:  parameter assignment
  5622          !            0:  == assignment
  5623          !            1:  =  assignment
  5624          !            2:  <- assignment
  5625          %routine  assign(%integer  assop )
  5626              %record(stackfm)%name  lh,rh
  5627              %record(stackfm)  temp
  5628              %integer  n, p, form, r
  5629  
  5630              abort("Assign Stack") %if (stp < 2)
  5631  
  5632              rh == top
  5633              lh == stack(stp-1)
  5634  
  5635              ! to avoid the ravages of amap, load etc
  5636              form = lh_form
  5637     
  5638              %if (diagnose&4 # 0) %start
  5639                  monitor(lh, "ASS LH")
  5640                  monitor(rh, "ASS RH")
  5641              %finish
  5642     
  5643              %if (same(lh, rh) # 0) %then %start
  5644                  pop rel
  5645                  pop rel
  5646                  %return
  5647              %finish
  5648  
  5649              %if (assop < 0) %start
  5650                  ! Parameter
  5651  
  5652                  %if (lh_base >= 128) %start
  5653                      ! Special - prim routine
  5654  
  5655                      ! JDM JDM comment
  5656                      ! The next iCode should be CALL (if not then an ERROR has arisen)
  5657                      ! So swop the stack entries ensuring the internal macro has valid parameters
  5658                      temp = lh
  5659                      lh = rh
  5660                      rh = temp
  5661                      %return
  5662                  %finish
  5663  
  5664                  ! Extract the next formal parameter and make it our target
  5665                  lh_pbase = lh_pbase - 1
  5666                  Stack Var(lh_pbase)
  5667                  ! Now make our destination look reasonable
  5668                  lh == top
  5669  
  5670                  ! target is the stack
  5671                  lh_base = SP
  5672   
  5673                  ! %name parameter is '=='
  5674                  assop = 0 %if (lh_form # V in S)
  5675  
  5676                  ! We need special treatment for procedure parameters
  5677                  %if (7 <= lh_aform <= 10) %start
  5678                      ! this is a procedure
  5679  
  5680                      ! we will treat it as a value assignment
  5681                      assop = 1
  5682  
  5683                      ! of an integer
  5684                      rh_type = integer
  5685                      lh_type = integer
  5686                      lh_form = V in S
  5687                      %if (rh_base # 0) %start
  5688                          ! RH is already a parameter
  5689                          rh_form = V in S
  5690                      %finish %else %if (rh_scope = EXT) %start
  5691                          ! it is an external procedure
  5692                          ! pick up the address
  5693                          rh_form = A V in S
  5694                      %finish %else %start
  5695                          ! it is a local procedure
  5696                          ! HACK: local procedures are Tags until Pass3 fixes them up.  The
  5697                          ! only way we have of converting tags to addresses is with the switch
  5698                          ! table - so we'll plant a fake switch entry for the label of the
  5699                          ! local routine, and then load that value!
  5700                          %if (swtp >= Max Switch) %then abort("Proc - Switch Table Full")
  5701                          swtab(swtp) = rh_disp
  5702                          rh_disp = swtp * word size
  5703                          swtp = swtp+1
  5704                          rh_scope = SWT
  5705                          rh_form = V in S
  5706                      %finish
  5707                  %finish
  5708              %finish
  5709  
  5710              %if (array <= rh_aform <= namearrayname) %start
  5711                  ! Arrayname
  5712                  ! An array name is two words - a pointer to the data and a
  5713                  ! pointer to the dope vector.  If the RHS is already one of these
  5714                  ! then we just want to copy the two words.  If it is a static
  5715                  ! array, we need to map the data to make a pointer, and its' dope
  5716                  ! vector will be in the constant table, so we fetch that.
  5717                  amap(lh)
  5718                  address(lh)
  5719  
  5720                  ! This works because arrays are stacked as V in S, arraynames are A in S
  5721                  amap(rh)
  5722                  address(rh)
  5723  
  5724                  ! We do the dope vector first - that makes it easier when we're parameter passing
  5725                  %if (rh_aform = array) %or (rh_aform = name array) %start
  5726                      ! simple static - DV in COT
  5727                      ! We will rustle up a dummy record for the DV address
  5728                      temp = 0
  5729                      temp_form = A V in S
  5730                      temp_type = integer
  5731                      temp_disp = rh_pbase
  5732                      temp_scope = COT
  5733                  %else
  5734                      ! already an array name
  5735                      temp = rh
  5736                      claim(temp_base)
  5737                      temp_disp = temp_disp + word size
  5738                  %finish
  5739                  lh_disp = lh_disp + word size
  5740                  store(lh, temp)
  5741                  release(temp_base)
  5742                  lh_disp = lh_disp - word size
  5743                  store(lh, rh)
  5744                  pop rel
  5745                  pop rel
  5746                  %return
  5747              %finish
  5748  
  5749              %if (lh_type = general) %start
  5750                  ! general %name parameter
  5751  
  5752                  ! Only '==' is allowed
  5753                  abort("Assign GenName") %unless (assop = 0)
  5754  
  5755                  ! A general name pointer is two words
  5756                  ! - the pointer itself
  5757                  ! and
  5758                  ! - a second word to convey type information.
  5759                  ! If the RHS is already one of these guys it's easy
  5760                  !   just copy the two words.
  5761                  ! else
  5762                  !   we must rustle up the second word at compile time
  5763  
  5764                  amap(lh)
  5765                  address(lh)
  5766                  %if (rh_type = general) %start
  5767                      ! RHS already a general pointer
  5768                      ! so, make a copy for the second word
  5769                      temp = rh
  5770                      claim(temp_base)
  5771                      temp_disp = temp_disp + word size
  5772                      amap(temp)
  5773                  %else
  5774                      ! RHS not a general pointer
  5775                      ! so, rustle up the second word
  5776                      temp = 0
  5777                      temp_type = integer
  5778                      ! load the values for sizeof, typeof
  5779                      %if (rh_type = string) %start
  5780                          temp_disp = (rh_size + 1)<<4
  5781                      %finish %else %start
  5782                          temp_disp = (rh_size<<4)
  5783                      %finish
  5784                      temp_disp = temp_disp + gen map(rh_type)
  5785  
  5786                      ! DANGER! this second word needs to be differentiated
  5787                      ! from a DVP pointer
  5788                      ! JDM JDM make temp_disp an odd number
  5789                      temp_disp = (temp_disp<<1) + 1
  5790                  %finish
  5791  
  5792                  ! We do the words backwards, so that parameter push works
  5793                  lh_disp = lh_disp + word size
  5794                  store(lh, temp)
  5795                  release(temp_base)
  5796                  lh_disp = lh_disp-word size
  5797                  amap(rh)
  5798                  store(lh, rh)
  5799                  pop rel
  5800                  pop rel
  5801                  %return
  5802              %finish
  5803  
  5804              %if (assop = 0) %start
  5805                  ! ==
  5806                  ! destination
  5807                  amap(lh)
  5808  
  5809                  ! ABD %string(*)%name  NOT handled special here - should be?
  5810                  amap(rh)
  5811              %finish
  5812  
  5813              %if (Lh_Type = record) %start
  5814                  %if (lh_base = SP) %start
  5815                      ! pass record by value - destination is the stack
  5816                      n = lh_size
  5817                      hazard(DI)
  5818  					dumpri(SUB, SP, lh_size)
  5819                      dumprr(MOV, DI, SP)
  5820                      claim(DI)
  5821                      lh_base = DI
  5822                  %else
  5823                      n = Min Record Size(Lh, Rh)
  5824                      amap(lh)
  5825                      loadreg(lh, DI)
  5826                  %finish
  5827                  hazard(CX)
  5828  				dumpri(MOV, CX, n)
  5829                  %if (rh_Form = Constant) %start
  5830                      hazard(AX)
  5831                      ! Sneaky trick to get a zero
  5832                      dumprr(XOR, AX,AX)
  5833                      dumprepstosb
  5834                  %else
  5835                      amap(rh)
  5836                      loadreg(rh, SI)
  5837                      dumprepmovsb
  5838                  %finish
  5839                  pop rel
  5840                  pop rel
  5841                  %return
  5842              %finish
  5843  
  5844              %if (lh_type = string) %start
  5845                  %if (assop > 0) %and (rh_format = 1) %start
  5846                      ! null string as zero byte ?
  5847                      lh_type = byte
  5848  
  5849                      ! zap current RHS
  5850                      pop rel
  5851  
  5852                      ! get a zero
  5853                      push const(0)
  5854  
  5855                      ! and assign it
  5856                      assign(assop)
  5857                      %return
  5858                  %finish
  5859  
  5860                  ! our copy routines expect DEST then SOURCE then LENGTH on the stack
  5861                  %if (lh_base = SP) %start
  5862                      ! pass string by value - destination is the stack
  5863                      ! space is string size, plus one for length, plus make it even
  5864                      p = lh_size + 1; p = (p+align) & (\align)
  5865  					dumpri(SUB, SP, p)
  5866                      ! we want to Push SP here - sadly different versions of x86
  5867                      ! architecture have different interpretations of "PUSH SP", so...
  5868                      r = gp reg
  5869                      dumprr(MOV, r, SP)
  5870                      dumpur(PUSH, r)
  5871                  %else
  5872                      amap(lh)
  5873                      loadreg(lh, any)
  5874                      dumpur(PUSH, lh_base)
  5875                  %finish
  5876                  ! It is likely that the RH variable is a temporary work area
  5877                  ! Before we trash the information, we try to release it
  5878                  Return Work(rh_disp)
  5879                  amap(rh)
  5880                  loadreg(rh, any)
  5881                  dumpur(PUSH, rh_base)
  5882                  pop rel
  5883                  pop rel
  5884                  dumppushi(0, lh_size, 0)
  5885                  %if (assop = 2) %then perm(sjam, 3) %else perm(smove, 3)
  5886                  %return
  5887              %finish
  5888  
  5889              address(lh)
  5890              store(lh, rh)
  5891              pop rel
  5892              pop rel
  5893          %end
  5894          !  assign
  5895  
  5896          %routine  Load Assign(%integer  assop )
  5897  
  5898              ! JDM JDM debug show the iCode instruction
  5899              %if (ShowIcode=1) %start
  5900                  ListICodeNoOp
  5901              %finish
  5902              ! JDM JDM end debug
  5903  
  5904              assign( assop )
  5905          %end
  5906  
  5907          !                                                      >> ARRAY REF <<
  5908          ! Array references always use the PERM
  5909          ! unless they are 1 dimensional,
  5910          ! AND the %control bit has been turned off
  5911          %routine  array ref(%integer mode)
  5912              %record(stackfm)%name av
  5913              %integer type, form, size, format
  5914  
  5915              %if (mode # 0) %then %start
  5916                  ! Put non-terminal index onto stack for PERM
  5917                  %if (top_type = byte) %start
  5918                      loadreg(top, any)
  5919                  %else
  5920                      address(top)
  5921                  %finish
  5922                  dumpvpush(top)
  5923                  pop rel
  5924                  %return
  5925              %finish
  5926     
  5927              av == stack(stp-1)
  5928              size = av_size
  5929              size = size + 1 %if (av_type = string)
  5930              form = av_aform
  5931              %if (form=namearray) %or (form=namearrayname) %then size = word size
  5932  
  5933              %if (control&check array = 0) %and (av_dim = 1) %start
  5934                  ! This will be unchecked, the top of the stack is the only index (1D),
  5935                  ! so we can do a cheap multiplication here
  5936                  %if (size # 1) %start
  5937                      ! multiply offset by var size
  5938                      push const(size)
  5939                      Operation(MULx)
  5940                  %finish
  5941              %else
  5942                  ! This is the final (and perhaps only) subscript for a checked array,
  5943                  ! so we are going to use the Perm - therefore pass this as a parameter
  5944                  %if (top_type = byte) %start
  5945                      loadreg(top, any)
  5946                  %else
  5947                      address(top)
  5948                  %finish
  5949                  dumpvpush(top)
  5950                  pop rel
  5951              %finish
  5952  
  5953              ! How we do the rest of the access depends on whether this is a simple
  5954              ! static array, or an array name...
  5955  
  5956              %if (form = arrayname) %or (form = namearrayname) %start
  5957                  ! array is a "name"
  5958                  ! We will AMAP the name,
  5959                  ! so we remember the info and then put it all back later
  5960                  type = av_type
  5961                  format = av_format
  5962                  size = av_size
  5963                  %if (form = arrayname) %then form = V in S %else form = A in S
  5964                  amap(av)
  5965  
  5966                  %if (control&check array # 0) %or (av_dim > 1) %start
  5967                      ! do the rest of the check
  5968                      ! This is a bit clunky, because we may load registers in order
  5969                      ! to access AV, only to Hazard them for the PERM
  5970                      address(av)
  5971                      push copy(av)
  5972                      claim(top_base)
  5973  
  5974                      ! Dope Vector address follows A(0)
  5975                      top_disp = top_disp + word size
  5976                      dumpvpush(top)
  5977                      pop rel
  5978                      ! DV word, plus a word for every subscript
  5979                      perm(aref, av_dim + 1)
  5980                      push const(0)
  5981                      top_form = V in R
  5982                      top_base = AX
  5983                      claim(AX)
  5984                  %finish
  5985  
  5986                  ! make sure index is in a pointer register
  5987                  loadreg(top, anyp)
  5988                  Operation(ADDx)
  5989                  top_type = type
  5990                  top_form = form
  5991                  top_format = format
  5992                  top_size = size
  5993                  top_disp = 0
  5994              %else
  5995                  ! simple arrays are always 1D, but can still be checked
  5996                  %if (control&check array # 0) %start
  5997                      ! Pass a pointer to the Dope Vector
  5998                      ! simple arrays have compile-time DV's in the COT
  5999                      dumppushi(COT, av_pbase, 0)
  6000                      perm(aref, 2)
  6001                      push const(0)
  6002                      top_form = V in R
  6003                      top_base = AX
  6004                      claim(AX)
  6005                  %finish
  6006  
  6007                  address(av)
  6008                  %if (av_form # V in S) %then abort("Aref Form")
  6009                  %if (top_form = constant) %start
  6010                      ! simple constant a(k)
  6011                      ! just add it to the offset
  6012                      av_disp = av_disp + top_disp
  6013                  %else
  6014                      ! pick up index in a pointer
  6015                      loadreg(top, anyp)
  6016                      %if (av_base # 0) %start
  6017                          ! add the base we've already got
  6018                          dumprr(ADD, top_base, av_base)
  6019                          release(av_base)
  6020                      %finish
  6021                      av_base = top_base
  6022                  %finish
  6023                  %if (form = array) %then av_form = V in S %else av_form = A in S
  6024                  pop stack
  6025              %finish
  6026  
  6027              ! not an array any more
  6028              top_aform = 0
  6029  
  6030          %end
  6031          !  array ref
  6032  
  6033          %routine Load Array Ref( %integer mode )
  6034  
  6035              ! JDM JDM debug show the iCode instruction
  6036              %if (ShowIcode=1) %start
  6037                  ListICodeNoOp
  6038              %finish
  6039              ! JDM JDM end debug
  6040  
  6041              array ref( mode )
  6042          %end
  6043  
  6044          !                                              >> TEST ZERO <<
  6045          ! test a real/integer/byte variable against zero
  6046          %routine  test zero(%record(stackfm)%name  v)
  6047  
  6048              %if (v_type = integer) %or (v_type = byte) %start
  6049                  loadreg(v,any)
  6050  				dumpri(CMP, v_base, 0)
  6051              %else
  6052                  abort("Test Zero")
  6053              %finish
  6054          %end
  6055          ! test zero
  6056  
  6057          %routine Compare Records(%record(stackfm)%name L, R, %integer N)
  6058              ! JDM eventually compare the byte values of each record
  6059              ! in the interim, barf
  6060              abort("Compare Records")
  6061          %end
?N unused
?R unused
?L unused
  6062  
  6063          !                                              >> COMPARE REALS <<
  6064          %routine  compare reals(%record(stackfm)%name  l,r)
  6065              loadreg(l, anyf)
  6066              loadreg(r, anyf)
  6067              hazard(AX)
  6068              ! who's ended up on top?
  6069              ! l_base is the top of the FPU stack
  6070              %if (l_base > r_base) %start
  6071                  dumpfloprr(FCMP, r_base, l_base)
  6072              %else
  6073                  dumpfloprr(FCMP, l_base, r_base)
  6074                  invert = invert !! 1
  6075              %finish
  6076              ! puts status into AX
  6077              dumpflopspec(FSTSW)
  6078              ! and move it to flags
  6079              dumpsimple(SAHF)
  6080              ! because FPU reports as if operands were unsigned
  6081              compare unsign = 1
  6082          %end
  6083          ! compare reals
  6084  
  6085          !                                              >> COMPARE STRINGS <<
  6086          %routine  compare strings(%record(stackfm)%name  l,r)
  6087              %record(stackfm)%name  temp
  6088              %if (l_base = COT) %and (l_disp = null string) %start
  6089                  temp == r
  6090                  r == l
  6091                  l == temp
  6092                  invert = invert !! 1
  6093              %finish
  6094              %if (r_base = COT) %and (r_disp = null string) %start
  6095                  l_type = byte
  6096                  test zero(l)
  6097              %else
  6098                  amap(l)
  6099                  loadreg(l, any)
  6100                  dumpur(PUSH, l_base)
  6101                  amap(r)
  6102                  loadreg(r, any)
  6103                  dumpur(PUSH, r_base)
  6104                  perm(scomp, 2)
  6105  				dumpri(CMP, AX, 0)
  6106              %finish
  6107          %end
  6108          ! compare strings
  6109  
  6110          !                                              >> COMPARE <<
  6111          %routine  compare(%record(stackfm)%name  l,r)
  6112              %if (l_type = 0) %or (l_type = string) %start
  6113                  compare strings(l,r)
  6114                  %return
  6115              %finish
  6116              %if (floating(l) # 0) %or (floating(r) # 0) %start
  6117                  compare reals(l,r)
  6118                  %return
  6119              %finish
  6120              %if (zero(r) # 0) %start
  6121                  test zero(l)
  6122                  %return
  6123              %finish
  6124              %if (zero(l) # 0) %start
  6125                  test zero(r)
  6126                  invert = invert !! 1
  6127                  %return
  6128              %finish
  6129              %if (l_Type = Record) %start
  6130                  Compare Records(L, R, Min Record Size(L, R))
  6131                  %return
?access
  6132              %finish
  6133              loadreg(l,any)
  6134              %if (r_type = byte) %start
  6135                  loadreg(r, anyg)
  6136              %else
  6137                  address(r)
  6138              %finish
  6139              dumprv(CMP, l_base, r)
  6140          %end
  6141          ! compare
  6142  
  6143          !                                              >> RESOLVE <<
  6144          %routine  resolve( %integer  flag )
  6145  
  6146              ! JDM JDM debug show the iCode instruction
  6147              %if (ShowIcode=1) %start
  6148                  ListICode
  6149                  spaces(4)
  6150                  printstring( itos(flag,0) )
  6151                  newline
  6152              %finish
  6153              ! JDM JDM end debug
  6154  
  6155              !S -> A.(B).C
  6156              %if (flag&1 = 0) %then push const(0) %else amap(top); ! C missing?
  6157              loadreg(top, any)
  6158              dumpur(PUSH, top_base)
  6159              pop rel
  6160              amap(top);  ! B
  6161              loadreg(top, any)
  6162              dumpur(PUSH, top_base)
  6163              pop rel
  6164              %if (flag&2 = 0) %then push const(0) %else amap(top); ! A missing?
  6165              loadreg(top, any)
  6166              dumpur(PUSH, top_base)
  6167              pop rel
  6168              amap(top);  ! S
  6169              loadreg(top, any)
  6170              dumpur(PUSH, top_base)
  6171              pop rel
  6172              perm(sresln, 4)
  6173              %if (flag&4 # 0) %then dumpri(CMP, AX, 0)
  6174          %end
  6175          ! resolve
  6176  
  6177          %integerfn enter
  6178              %integer cad;
  6179  
  6180              uncond jump = -1; ! can get here
  6181  
  6182              ! This is a convenient place to include external definitions if needed
  6183              %if (potype >= external) %start
  6184                  fill external(CODE, next cad, external id)
  6185              %finish
  6186  
  6187              cad = nextcad;
  6188              dumpstaticalloc(cad, level, block name); ! plant dummy ENTER instruction and pass marker to pass 3
  6189              %result = cad;
  6190          %end
  6191  
  6192          !                                              >> DUMP RETURN <<
  6193          %routine  dump return
  6194              %return %if (uncond jump = next cad);          !  can't get here ?
  6195  
  6196              ! Pure 8086 would need these two
  6197              !	dumprr(MOV, SP, BP)
  6198              !	dumpur(POP, BP)
  6199              ! but now we use this instead...
  6200              dumpsimple(LEAVE)
  6201  
  6202              dumpsimple(RET);
  6203  
  6204              uncond jump = next cad
  6205          %end
  6206          ! return
  6207  
  6208          ! Routine to do "to string" as an in-line, either by making
  6209          ! a constant string in the CONST area, or putting one onto
  6210          ! the current workspace
  6211          %routine  compile to string(%record(stackfm)%name  v)
  6212              %integer tmp
  6213  
  6214              %if (const(v)#0) %start
  6215                  current string(0) = 1
  6216                  current string(1) = v_disp&255
  6217                  v_base = 0
  6218                  v_scope = COT
  6219                  v_disp = getcots(current string)
  6220              %else
  6221                  tmp = getwork(word size)
  6222                  loadreg(v,anyg);        ! Must be a byte-addressable register
  6223                  dumpmi(MOV, BP, tmp, 0, 1)
  6224                  dumpmr8(MOV, BP, tmp+1, 0, v_base+16)
  6225                  release(v_base)
  6226                  v_base = BP
  6227                  v_scope = 0
  6228                  v_disp = tmp
  6229              %finish
  6230              v_type = string
  6231              v_form = V in S
  6232              v_size = 1
  6233          %end
  6234  
  6235          !                                              >> COMPILE CALL <<
  6236          ! Call the routine on the top of the stack.  Note - the parameters
  6237          ! are all hidden underneath the routine, so we need to push them
  6238          ! here
  6239          %routine  Compile Call(%record(stackfm)%name  v)
  6240              %label form new type
  6241              ! switch b used for prim macro functions
  6242              %switch  b(1:13)
  6243              %string(255) tname
  6244              %integer     i
  6245  
  6246              !  1 = rem
  6247              !  2 = float
  6248              !  3 = to string
  6249              !  4 = addr
  6250              !  5 = integer
  6251              !  6 = byte integer
  6252              !  7 = string
  6253              !  8 = record
  6254              !  9 = real
  6255              ! 10 = long real
  6256              ! 11 = length
  6257              ! 12 = charno
  6258              ! 13 = int (from real)
  6259  
  6260              %conststring(15) %array macroname(1:13) =
  6261+             {  1 } "REM",
  6262+             {  2 } "FLOAT",
  6263+             {  3 } "TO STRING",
  6264+             {  4 } "ADDR",
  6265+             {  5 } "INTEGER",
  6266+             {  6 } "BYTE INTEGER",
  6267+             {  7 } "STRING",
  6268+             {  8 } "RECORD",
  6269+             {  9 } "REAL",
  6270+             { 10 } "LONG REAL",
  6271+             { 11 } "LENGTH",
  6272+             { 12 } "CHARNO",
  6273+             { 13 } "INT"
  6274  
  6275              %constbyteintegerarray  new type(5:12) =
  6276+                       integer, byte, string, record, real, lreal, byte, byte
  6277              %integer  t,l,p
  6278  
  6279              %if (v_base >= 128) %start
  6280                  !  built-in primitive
  6281                  l = 0;
  6282                  t = v_disp
  6283  
  6284                  ! 'sym=0' used as flag elsewhere
  6285                  sym = 0
  6286                  pop rel
  6287  
  6288                  ! JDM JDM defend against out-of-range value for t
  6289                  t = 0 %unless (0 < t < 16)
  6290                  abort("Illegal %prim macro") %unless (0 < t < 15)
  6291  
  6292                  ! JDM JDM show start of macro "call" in listing
  6293                  ! Now to say which macro was requested
  6294                  selectoutput(listout)
  6295                  spaces(38)
  6296                  printstring( "Generating CODE for '" )
  6297                  printstring( macroname(t) )
  6298                  printstring( "' (MACRO ".itos(t,0).")")
  6299                  newline
  6300  
  6301                  -> b(t)
  6302  b(1):
  6303                  ! REM
  6304                  Operation(REMx)
  6305                                                         -> esac
  6306  b(2):
  6307                 ! FLOAT
  6308                 loadreg(top, anyf)
  6309                                                         -> esac
  6310  b(3):
  6311                 ! TO STRING
  6312                 compile to string(top)
  6313                                                         -> esac
  6314  b(4):
  6315                 ! ADDR
  6316                 amap(top)
  6317                                                         -> esac
  6318  b(5):
  6319                 ! INTEGER
  6320  b(6):
  6321                 ! BYTE
  6322  b(7):
  6323                 ! STRING
  6324  b(8):
  6325                ! RECORD
  6326  b(9):
  6327                ! REAL
  6328  b(10):
  6329                ! LONG REAL
  6330  
  6331  form new type:
  6332                  vmap(top)
  6333                  top_type = new type(t)
  6334                  top_size = v size(top_type)
  6335                                                         -> esac
  6336  
  6337  b(11):
  6338                  ! LENGTH
  6339                  push const(0);                      ! length is charno zero
  6340                  amap(stack(stp-1))
  6341                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  6342  
  6343                  ! JDM JDM avoid code duplication
  6344                                                         -> form new type
  6345  b(12):
  6346                  ! CHARNO
  6347                  amap(stack(stp-1))
  6348                  Operation(ADDx);  !LHS&RHS reversed in Operation??
  6349  
  6350                  ! JDM JDM avoid code duplication
  6351                  -> form new type
  6352  b(13):
  6353                  ! INT(real)
  6354                  loadreg(top, anyf)
  6355                  release(top_base)
  6356                  p = getwork(word size)
  6357                  dumpfloprm(FSTI, BP, p, 0 )
  6358                  top_type = integer
  6359                  top_form = V in S
  6360                  top_base = BP
  6361                  top_disp = p
  6362  				                                       -> esac
  6363  esac:
  6364                  ! JDM JDM show macro "call" in listing
  6365                  ! Now to say which macro was requested
  6366                  selectoutput(listout)
  6367                  spaces(38)
  6368                  printstring( "CALL '" )
  6369                  printstring( macroname(t) )
  6370                  printstring( "' (MACRO ".itos(t,0).")")
  6371                  newline
  6372  
  6373  			%else
  6374                  !   -- normal routine calls --
  6375                  ! String functions have a hidden last parameter to point
  6376                  ! to the result area
  6377                  %if (v_type = string) %and (v_aform = 8) %start
  6378                      t = getwork(v_size+1)
  6379                      p = gp reg
  6380                      dumprm(LEA, p, BP, t, 0)
  6381                      dumpur(PUSH, p)
  6382                  %finish
  6383                  hazard all
  6384                  %if (v_scope = EXT) %start
  6385                      ! external
  6386                      dumpextcall(v_disp)
  6387                  %else
  6388                      %if (v_base # 0) %start
  6389                          ! procedure-as-parameter
  6390                          ! so, plant call indirect through variable
  6391                          dumpum(CALL, v_base, v_disp, v_extdisp )
  6392                      %else
  6393                          ! local routine
  6394                          ! plants fixup for the tag
  6395                          dumpjump(CALL, v_disp)
  6396                      %finish
  6397                  %finish
  6398                  ! adjust the stack
  6399                  %if (v_extra # 0) %then dumpri(ADD, SP, v_extra)
  6400                  %if (v_type = 0) %start
  6401                      ! not function or map
  6402                      pop rel
  6403                  %else
  6404                      ! Here we've got a result
  6405                      ! Result is local, even if the function wasn't
  6406                      v_scope = 0
  6407                      %if (v_type = string) %and (v_aform = 8) %start
  6408                          v_base = BP;             ! String result will have been copied back here
  6409                          v_disp = t
  6410                          v_form = V in S
  6411                      %else
  6412                          %if ((v_type = real) %or (v_type = lreal)) %and (v_aform = 8) %start
  6413                              ! Floating result will be on the FPU stack
  6414                              v_form = V in R
  6415                              v_base = FR0
  6416                              claim(FR0)
  6417                              fpu stack = 1
  6418                          %else
  6419                              ! Result is always in AX
  6420                              v_base = AX
  6421                              v_disp = 0;                ! Clear this for MAP results
  6422                              claim(AX)
  6423                          %finish
  6424                      %finish
  6425                  %finish
  6426  			%finish
  6427          %end;
?I unused
?TNAME unused
  6428               ;
  6428          !  Compile Call
  6429  
  6430          %routine Load Compile Call( %record(stackfm)%name  v )
  6431  
  6432              ! JDM JDM debug show the iCode instruction
  6433              %if (ShowIcode=1) %start
  6434                  ListICodeNoOp
  6435              %finish
  6436              ! JDM JDM end debug
  6437  
  6438              Compile Call( v )
  6439          %end
  6440  
  6441          !                                              >> COMPILE FOR <<
  6442          %routine  compile for( %integer lab )
  6443              %record(stackfm)%name  cv, iv, inc, fv
  6444              %integer  n
  6445  
  6446              ! JDM JDM debug show the iCode instruction
  6447              %if (ShowIcode=1) %start
  6448                  ListICode
  6449                  spaces(4)
  6450                  printstring( itos(lab,0) )
  6451                  newline
  6452              %finish
  6453              ! JDM JDM end debug
  6454  
  6455              ! Lock a value into a temporary to make sure it is invariant
  6456              %routine  stab(%record(stackfm)%name  v,  %integer  type)
  6457                  %integer  t,r
  6458                  %return %if (const(v) # 0)
  6459                  loadreg(v,any)
  6460                  r = v_base
  6461                  t = getwork(word size)
  6462                  dumpmr(MOV, BP,t, 0, r)
  6463                  v_base = BP
  6464                  v_disp = t
  6465                  v_scope = 0
  6466                  v_type = type
  6467                  v_form = V in S
  6468                  release(r)
  6469              %end
  6470  
  6471              iv == top
  6472              fv == stack(stp-1)
  6473              inc == stack(stp-2)
  6474              cv == stack(stp-3)
  6475  
  6476              stab(fv,integer)
  6477              stab(inc,integer)
  6478  
  6479              ! Check control variable is a plain value - otherwise save a pointer to it
  6480              ! in case it changes
  6481              %if (cv_form # v in s) %or ((0 < cv_base <= DI) %and (cv_base # BP)) %start
  6482                  n = cv_type
  6483                  amap(cv)
  6484                  stab(cv, n)
  6485                  cv_form = a in s
  6486              %finish
  6487     
  6488              push copy(cv)
  6489              push copy(iv)
  6490              push copy(inc);
  6491              Operation(SUBx)
  6492              assign(1);        ! cv = iv - inc
  6493  
  6494              define label(lab)
  6495              pop stack;! zap unwanted copy of IV
  6496  
  6497              ! Stack is now  top->[FV[INC[CV 
  6498              push copy(cv);		! in case compare alters it
  6499              compare(top, fv)
  6500              jump to(lab+1, JE, 1)
  6501              invert = 0; ! because the compare might have flipped this (N/A for JE)
  6502              ! Stack is now top->[CV'[FV[INC[CV where CV' is a register copy of CV
  6503              release(fv_base)
  6504  
  6505              ! trash FV and make a copy of CV' in that slot
  6506              fv = top
  6507  
  6508              ! discard the top copy
  6509              pop stack
  6510              ! stack is now top->[CV'[INC[CV
  6511              Operation(ADDx)
  6512              assign(1)
  6513          %end
  6514          ! for
  6515  
  6516  		%routine End of Block
  6517  			%if (amode >= 0) %start
  6518                  ! No return code for %endoffile
  6519  				dump return
  6520  
  6521                  ! don't include the display
  6522  				dumpstaticfill(staticalloc, frame+(level*word size), events, evep, evfrom)
  6523  			%finish
  6524  		%end
  6525  
  6526  		%routine Load End of Block
  6527  
  6528              ! JDM JDM debug show the iCode instruction
  6529              %if (ShowIcode=1) %start
  6530                  ListICodeNoOp
  6531              %finish
  6532              ! JDM JDM end debug
  6533  
  6534  			End of Block
  6535  		%end
  6536  
  6537  		%routine Compile Begin
  6538  			decvar == begin
  6539              decvar_disp = new tag
  6540  			otype = 0
  6541              spec = 0
  6542              potype = 0
  6543  			%if (level # 0) %start
  6544                  ! not outermost %begin
  6545  				push const(decvar_disp)
  6546  				top_type = 0;      ! it's not a function!
  6547  				compile call(top)
  6548  				skip proc = new tag
  6549  				dump jump(JMP, skip proc)
  6550  				dump label(decvar_disp);  ! this is where to call
  6551  			%finish
  6552  			assemble(0,labs,names)
  6553  			%if (level # 0) %start
  6554  				dump label(skip proc)
  6555  				last skip = next cad
  6556  				Uncond Jump = 0
  6557  			%finish
  6558  		%end
  6559  
  6560  		%routine Load Compile Begin
  6561  
  6562              ! JDM JDM debug show the iCode instruction
  6563              %if (ShowIcode=1) %start
  6564                  ListICodeNoOp
  6565              %finish
  6566              ! JDM JDM end debug
  6567  
  6568              Compile Begin
  6569          %end
  6570  
  6571          ! Utility routine used when dumping initialisers for OWNs
  6572          ! Note non-portable use of real values
  6573          %routine  adump
  6574              %integer i
  6575              %real		rv32
  6576              %switch ot(general:tlabel)
  6577  
  6578              ->ot(own type)
  6579  ot(general):
  6580              abort("General Own?")
  6581  ot(integer):
  6582              gput(ownval)
  6583              -> done
  6584  ot(real):
  6585              rv32 = rvalue
  6586              ! because our default variable is a 64 bit long real
  6587              %for i = 0,1,3 %cycle
  6588  				gbyte(byteinteger(addr(rv32)+i))
  6589  			%repeat
  6590  			-> done
  6591  ot(string):
  6592              %if (current string(0)+1 > data size) %start
  6593                  ! check for overflow
  6594  				! String constant too long - warn and truncate
  6595  				warn(5)
  6596                  current string(0) = data size - 1
  6597  			%finish
  6598  
  6599  			%for i = 0,1,data size - 1 %cycle
  6600  				gbyte(current string(i))
  6601  			%repeat
  6602  			-> done
  6603  ot(record):
  6604              %for i = 1,1,data size %cycle
  6605  				gbyte(0)
  6606  			%repeat
  6607  			-> done
  6608  ot(byte):
  6609              gbyte(ownval)
  6610              -> done
  6611  ot(short):
  6612              gput(ownval)
  6613              -> done
  6614  ot(long):
  6615              gput(ownval)
  6616              -> done
  6617  ot(lreal):
  6618              %for i = 0,1,7 %cycle
  6619  				gbyte(byteinteger(addr(rvalue)+i))
  6620  			%repeat
  6621  			-> done
  6622  ot(tarray):
  6623              %for i = 1,1,data size %cycle
  6624  				gbyte(0)
  6625  			%repeat
  6626  			-> done
  6627  ot(tlabel):
  6628              gput(ownval)
  6629              -> done
  6630  
  6631  done:
  6632          %end
  6633  
  6634          %integerfn user label(%integer lab)
  6635              %record(varfm)%name v
  6636              %if (lab > names) %start
  6637                  names = lab
  6638                  v == var(lab)
  6639                  v = 0
  6640                  v_form = pgm label
  6641                  v_disp = new tag
  6642                  %result = v_disp
  6643              %finish
  6644              %result = var(lab)_disp
  6645          %end
  6646  
  6647  		%routine Compare Double
  6648  			LHS == stack(stp-1)
  6649  			RHS == top
  6650  			loadreg(rhs, any)
  6651  			! We happen to know that Compare loads the left parameter in a register.
  6652  			! We've already got RHS in a register, so we flip the LHS and RHS to the
  6653  			! comparison and set Invert accordingly
  6654  			compare(rhs, lhs)
  6655  			invert = 1
  6656  			! release LH and then overwrite it with RH
  6657  			release(lhs_base)
  6658  			lhs = rhs
  6659  			pop stack
  6660  		%end
  6661  
  6662  		%routine Load Compare Double
  6663  
  6664              ! JDM JDM debug show the iCode instruction
  6665              %if (ShowIcode=1) %start
  6666                  ListICodeNoOp
  6667              %finish
  6668              ! JDM JDM end debug
  6669  
  6670              Compare Double
  6671          %end
  6672  
  6673  		%routine Compare Values
  6674  			LHS == stack(stp-1)
  6675  			RHS == top
  6676  			compare(lhs,rhs)
  6677  			pop rel
  6678  			pop rel
  6679  		%end
  6680  
  6681  		%routine Load Compare Values
  6682  
  6683              ! JDM JDM debug show the iCode instruction
  6684              %if (ShowIcode=1) %start
  6685                  ListICodeNoOp
  6686              %finish
  6687              ! JDM JDM end debug
  6688  
  6689              Compare Values
  6690  		%end
  6691  
  6692  		%routine Compare Addresses
  6693  			amap(top);
  6694  			amap(stack(stp-1));                  ! Now do same as compare values
  6695  			Compare Values
  6696  		%end
  6697  
  6698  		%routine Load Compare Addresses
  6699  
  6700              ! JDM JDM debug show the iCode instruction
  6701              %if (ShowIcode=1) %start
  6702                  ListICodeNoOp
  6703              %finish
  6704              ! JDM JDM end debug
  6705  
  6706              Compare Addresses
  6707  		%end
  6708  
  6709  		%routine Define Compiler Label( %integer label)
  6710  
  6711              ! JDM JDM debug show the iCode instruction
  6712              %if (ShowIcode=1) %start
  6713                  ListICode
  6714                  spaces(4)
  6715                  printstring( itos(label,0) )
  6716                  newline
  6717              %finish
  6718              ! JDM JDM end debug
  6719  
  6720  			%if (label = 0) %start
  6721  				dump label(skipproc)
  6722  				last skip = next cad
  6723  				Uncond Jump = 0
  6724  			%else
  6725  				define label( label );
  6726  			%finish
  6727  		%end
  6728  
  6729  		%routine Init( %integer N )
  6730  			! N = Number of values to assign
  6731  			%integer j
  6732  
  6733              ! JDM JDM debug show the iCode instruction
  6734              %if (ShowIcode=1) %start
  6735                  ListICode
  6736                  spaces(4)
  6737                  printstring( itos(N,0) )
  6738                  newline
  6739              %finish
  6740              ! JDM JDM end debug
  6741  
  6742  			%if (stp # 0) %start
  6743                  ! Value supplied?
  6744  				own val = top_disp
  6745  				%if (own type = real) %or (own type = lreal) %start
  6746  					rvalue = own val %if (top_type = integer);  ! copy integer supplied into floater
  6747  				%finish
  6748  				pop stack
  6749  			%else
  6750                  ! initialise to default pattern
  6751  				ownval = 0
  6752  				current string(0) = 0;     ! in case it's a string
  6753  			%finish
  6754  
  6755  			%if (own form = array) %or (own form = name array) %start
  6756  				adump %for j = 1,1,N
  6757  			%else
  6758  				%if (otype = 0) %start
  6759                      ! %const .... %name
  6760  !					Abort("Constant Name");
  6761  					! JDM attempt to allow assignment of %const ... %name
  6762  					decvar_scope = COT
  6763  					decvar_level = 0
  6764  					decvar_disp = own val
  6765  				%else
  6766  					! non-array normal variables
  6767  					decvar_level = 0
  6768  					%if (otype = con) %start
  6769  						! constant - must be string or real type, because
  6770  						! const integers are substituted by value in Pass 1
  6771  						! Constant strings and reals are treated as literals
  6772  						decvar_scope = COT
  6773  						%if (own type = string) %start
  6774  							decvar_disp = getcots(current string)
  6775  						%else
  6776  							%if (own type = real) %or (own type = lreal) %start
  6777  								! constant reals are put in the COT.  Depending on how
  6778  								! the value was formed, ReadReal may have already planted this.
  6779  								! Not to worry, because "real constant" will find it again.
  6780  								decvar_disp = getcotdouble(rvalue)
  6781  							%else
  6782  								abort("Init?")
  6783  							%finish
  6784  						%finish
  6785  					%else
  6786  						! must be %own or %external - use adump to put it in DATA segment
  6787  						decvar_scope = DATA
  6788  						decvar_disp = datatp
  6789  						adump
  6790  					%finish
  6791  				%finish
  6792  			%finish
  6793  		%end
  6794  
  6795  		%routine User Jump( %integer label )
  6796  
  6797              ! JDM JDM debug show the iCode instruction
  6798              %if (ShowIcode=1) %start
  6799                  ListICode
  6800                  spaces(4)
  6801                  printstring( itos(label,0) )
  6802                  newline
  6803              %finish
  6804              ! JDM JDM end debug
  6805  
  6806  			dumpjump(JMP, user label( label ))
  6807  		%end
  6808  
  6809  		%routine Define User Label( %integer label )
  6810  
  6811              ! JDM JDM debug show the iCode instruction
  6812              %if (ShowIcode=1) %start
  6813                  ListICode
  6814                  spaces(4)
  6815                  printstring( itos(label,0) )
  6816                  newline
  6817              %finish
  6818              ! JDM JDM end debug
  6819  
  6820  			dump label(user label( label ))
  6821  		%end
  6822  
  6823  		%routine Return( %integer mode)
  6824  			%integer i
  6825  
  6826  			%if (mode = False) %start
  6827  				dumpri(MOV, AX, 0)
  6828  			%finish
  6829  
  6830  			%if (mode = True) %start
  6831  				dumpri(MOV, AX, -1)
  6832  			%finish
  6833  
  6834  			%if (mode = Map) %start
  6835  				amap(top)
  6836  				loadreg(top, AX)
  6837  				pop rel
  6838  			%finish
  6839  
  6840  			%if (mode = Fn) %start
  6841  				%if (procvar_type = integer) %start
  6842  					loadreg(top, AX)
  6843  					pop rel
  6844  				%else
  6845  					%if (procvar_type = real) %or (procvar_type = lreal) %start
  6846  						! Floating point results are put into store, and AX contains
  6847  						! the address
  6848  						! JDM - No, not for 32-bit code for IA-32 architecture ABI
  6849  						! JDM - floating point results go onto the floating point stack in ST(0)
  6850  						! JDM - that is the returned floating point stack should only be 1 deep
  6851  						! JDM: loadreg(top,anyf) should push the result onto the floating point stack
  6852  						loadreg(top, anyf);
  6853  						pop rel
  6854  					%else
  6855                          ! string or record - pass back through the hidden parameter
  6856  						push copy(top);            ! Make a copy of the thing on top
  6857  						lhs == stack(stp-1);       ! point to the (now spare) next item
  6858  						lhs_type = procvar_type;   ! and make it look like a destination
  6859  						lhs_size = procvar_size
  6860  						lhs_format = procvar_format
  6861  						lhs_base = BP
  6862  						lhs_disp = word size * 2;  ! At the offset of the last parameter
  6863  						lhs_form = a in s
  6864  						assign(1)
  6865  					%finish
  6866  				%finish
  6867  			%finish
  6868  
  6869  			%if (mode = Routine) %start
  6870  				! no need to do anything special
  6871  			%finish
  6872  
  6873  			dump return
  6874  		%end
?I unused
  6875  
  6876  		%routine Load Return( %integer mode )
  6877  
  6878              ! JDM JDM debug show the iCode instruction
  6879              %if (ShowIcode=1) %start
  6880                  ListICodeNoOp
  6881              %finish
  6882              ! JDM JDM end debug
  6883          
  6884              Return( mode )
  6885          %end
  6886  
  6887  		%routine Dimension( %integer dim, n )
  6888  			%integer i,j, useCOT, descriptor
  6889  
  6890              ! JDM JDM debug show the iCode instruction
  6891              %if (ShowIcode=1) %start
  6892                  ListICode
  6893                  spaces(4)
  6894                  printstring( itos(dim,0) )
  6895                  printsymbol( ',' )
  6896                  printstring( itos(n,0) )
  6897                  newline
  6898              %finish
  6899              ! JDM JDM end debug
  6900  
  6901  			! Validate the ICODE Parameters
  6902  			abort("Array Dim") %unless (0 < dim < 6)
  6903  
  6904  			%if (in params # 0) %start
  6905                  ! This is an Array inside a Record
  6906                  ! NB. Only 1D arrays are allowed in a record!
  6907                  ! Defended against by the IMP grammar
  6908                  ! Hence the simplified code for a Dope Vector creation
  6909  				parms = parms + n
  6910  				vub = top_disp
  6911                  pop stack
  6912  				vlb = top_disp
  6913                  pop stack
  6914  				abort("Array Bounds") %if (vlb > vub)
  6915  				dv = set dope vector( data size, array entry type )
  6916              %else
  6917  				names = names - n
  6918  
  6919                  ! We should check to see if we can store the DopeVector in
  6920                  ! the COT table or on the machine stack
  6921                  ! Assume we have constant array bounds
  6922                  useCOT = 1
  6923  				! Now iterate over the bounds
  6924  				j = 0
  6925                  ! points to before the first stack value
  6926  				%for i=1,1,dim*2 %cycle
  6927  					j = j + 1
  6928                      lhs == stack(j)
  6929                      ! Determine if any bound is defined by a variable
  6930  					%if (lhs_form # constant) %start
  6931                          ! Drat! One of the bounds is NOT constant
  6932                          ! So, we'll have to store the DV on the stack
  6933                          useCOT = 0
  6934  					%finish
  6935  				%repeat
  6936  
  6937  				! Now to plant code to manufacture space for a Dope Vector
  6938                  ! original DV definition
  6939                  !   :Dim:<bound pairs>:DataSize:
  6940                  ! new DV definition
  6941                  !   :Dim:<bound pairs>:DataSize<<5!DataType<<1!1:
  6942  				frame = (frame - 2*word size*(dim + 1) )&(\align)
  6943  				dv = frame
  6944  
  6945  				! First store the dimension (constant value)
  6946  				dumpmi(MOV, BP, dv, 0, dim)
  6947  
  6948  				! Now the bounds (which may not be constant)
  6949  				j = 0
  6950                  ! points to before the first stack value
  6951  				%for i=1,1,dim*2 %cycle
  6952  					j = j + 1
  6953                      lhs == stack(j)
  6954  					%if (lhs_form = constant) %start
  6955  						dumpmi(MOV, BP, dv + (i*word size), 0, lhs_disp)
  6956  					%else
  6957  						loadreg(lhs, any)
  6958  						dumpmr(MOV, BP, dv + (i*word size), 0, lhs_base)
  6959  					%finish
  6960  				%repeat
  6961  
  6962  				! And the data size is also constant
  6963                  ! JDM JDM enhancement
  6964                  ! Make DV _size field to be a size/type/flag format descriptor
  6965                  descriptor = (data size<<5) ! ((array entry type&15)<<1) ! 1
  6966  				dumpmi(MOV, BP, dv + (2*dim + 1) * word size, 0, descriptor )
  6967  
  6968  				! Now we need to allocate the space for the array
  6969                  ! Depending on the number of array dimensions
  6970  				%if (dim > 1) %or (control&check array # 0) %start
  6971  					! Do it with the PERM
  6972  					%while (stp # 0) %cycle
  6973                          ! get rid of all the bounds
  6974                          !     they are in the DV already
  6975  						pop rel
  6976  					%repeat
  6977  
  6978  					dumprm(LEA, AX, BP, dv, 0)
  6979  					dumpur(PUSH, AX)
  6980  					perm(adef, 1)
  6981  
  6982  					! We now need to make our result match the in-line version
  6983  					! by putting AX and DX into stack-like variables
  6984  					push const(0)
  6985                      lhs == top
  6986  
  6987                      push const(0)
  6988                      rhs == top
  6989  	
  6990                      lhs_base = AX
  6991                      lhs_form = V in R
  6992                      claim(AX)
  6993  
  6994  					rhs_base = DX
  6995                      rhs_form = V in R
  6996                      claim(DX)
  6997  
  6998                      pop stack
  6999                      pop stack
  7000                  %else
  7001                      push const(1)
  7002                      Operation(ADDx)
  7003                      push const(data size)
  7004                      Operation(MULx)
  7005                      
  7006                      ! suck up the lower bound
  7007                      push copy(stack(stp-1))
  7008  					push const(data size)
  7009  					Operation(MULx)
  7010  					! top is now the lower bound,
  7011                      ! next is the upper,
  7012                      ! and a bogus copy of lb is next
  7013  					loadreg(top, any);   ! Make sure this is in a register
  7014  					lhs == top;          ! Point to it
  7015  					pop stack;           ! and drop (without release) this copy
  7016  					loadreg(top, any);   ! This is now UB - load it in a register as well
  7017  					rhs == top;          ! Point to it
  7018  					pop stack;           ! and keep RHS (Upper)
  7019  					pop stack;           ! dump the bogus lb
  7020  				%finish
  7021  
  7022  				! Note - there are 4 GP registers, and we're going to need them ALL here
  7023  				t = gp reg;             ! get a working register for the dope vector address
  7024  				dumprm(LEA, t, BP, dv, 0); ! load it
  7025  				dv = t
  7026                  claim(dv);              ! use this to hold the register number
  7027  				t = gp reg;             ! the last one! (which we don't claim, 'cos we can't lose it)
  7028  				dumprr(MOV, t, SP);     ! working copy of SP so that real SP is always "OK"
  7029  			%finish
  7030  
  7031  			%for i = 1,1,n %cycle
  7032  				decvar_dim = dim
  7033  				%if (in params = 0) %start
  7034                      !  array not in record
  7035  					names = names+1
  7036                      decvar == var(names)
  7037  					decvar_level = level
  7038  					frame = frame - (word size * 2);  ! 2-word header
  7039  					decvar_disp = frame
  7040  
  7041                      ! force arrayname?
  7042  					%if (decvar_form = array) %or (decvar_form = namearray) %then decvar_form = decvar_form + 1
  7043  
  7044  					dumprr(SUB, t, rhs_base)
  7045  					dumpmr(MOV, BP, frame, 0, t);             ! store a(0) address
  7046  					dumpmr(MOV, BP, frame + word size, 0, dv);! store dope vector pointer
  7047  					dumprr(ADD, t, lhs_base)
  7048  				%else
  7049                      ! array-in-record
  7050  					parms = parms-1
  7051                      decvar == var(parms)
  7052  					decvar_disp = frame - vlb
  7053  
  7054                      ! noting that Set Dope Vector has changed VUB to the array size
  7055  					frame = frame + vub
  7056  					decvar_pbase = dv
  7057  				%finish
  7058  			%repeat
  7059  
  7060  			%if (in params = 0) %start
  7061  				! We need to keep the stack pointer word aligned 
  7062                  ! - 8086's run faster that way,
  7063  				! and more importantly,
  7064                  !     Pentiums throw an exception if you don't!
  7065  				%if (data size&align # 0) %then dumpri(AND, t, \align)
  7066  				dumprr(MOV,SP,t)
  7067  				release(lhs_base)
  7068  				release(rhs_base)
  7069  				release(dv)
  7070  			%finish
  7071  		%end
  7072  
  7073  		%routine Update Line( %integer line )
  7074  
  7075              ! JDM JDM debug show the iCode instruction
  7076              %if (ShowIcode=1) %start
  7077                  ListICode
  7078                  spaces(4)
  7079                  printstring( itos( line,0) )
  7080                  newline
  7081              %finish
  7082              ! JDM JDM end debug
  7083  
  7084  			current line = line
  7085  			abort("Stack?") %if (stp # 0)
  7086  			abort("Claimed") %if (claimed # 0)
  7087  			! Pass1 sends the line number multiple times if there's more than
  7088  			! one statement per line - for debugging we only want "real" line numbers
  7089  			%if (echo line < current line) %start
  7090  				dump line number(current line)
  7091  				%while (echo line < current line) %cycle
  7092  					echo source line
  7093  				%repeat
  7094  			%finish
  7095  		%end
  7096  
  7097  		%routine Switch Jump( %integer switch id )
  7098  
  7099              ! JDM JDM debug show the iCode instruction
  7100              %if (ShowIcode=1) %start
  7101                  ListICode
  7102                  spaces(4)
  7103                  printstring( itos(switch id,0) )
  7104                  printsymbol( ',' )
  7105                  printsymbol( '=' )
  7106                  printsymbol( '"' )
  7107                  printstring( var( switch id)_idname )
  7108                  printsymbol( '"' )
  7109                  newline
  7110              %finish
  7111              ! JDM JDM end debug
  7112  
  7113  			v == var( switch id )
  7114  			push const(word size)
  7115              Operation(MULx);        ! subscript X Word Size
  7116  			loadreg(top, anyp)
  7117  			dumpum(JMP, SWT!top_base, v_disp * word size, 0);	! swtab is word-size
  7118  			pop rel
  7119  			uncond jump = next cad
  7120  		%end
  7121  
  7122  		%routine Set Record Format( %integer format id )
  7123  
  7124              ! JDM JDM debug show the iCode instruction
  7125              %if (ShowIcode=1) %start
  7126                  ListICode
  7127                  spaces(4)
  7128                  printstring( itos(format id,0) )
  7129                  printsymbol( ',' )
  7130                  printsymbol( '=' )
  7131                  printsymbol( '"' )
  7132                  printstring( var( format id)_idname )
  7133                  printsymbol( '"' )
  7134                  newline
  7135              %finish
  7136              ! JDM JDM end debug
  7137  
  7138  			top_format = format id
  7139  			top_type   = record
  7140  		%end
  7141  
  7142  		%routine Switch Label( %integer switch label )
  7143  
  7144              ! JDM JDM debug show the iCode instruction
  7145              %if (ShowIcode=1) %start
  7146                  ListICode
  7147                  spaces(4)
  7148                  printstring( itos(switch label,0) )
  7149                  printsymbol( ',' )
  7150                  printsymbol( '=' )
  7151                  printsymbol( '"' )
  7152                  printstring( var( switch label)_idname )
  7153                  printsymbol( '"' )
  7154                  newline
  7155              %finish
  7156              ! JDM JDM end debug
  7157  
  7158  			v == var( switch label )
  7159  			uncond jump = 0
  7160  			j = top_disp
  7161              pop stack
  7162              
  7163              t = new tag
  7164  			dumplabel(t);
  7165  			swtab(v_disp+j) = t;
  7166  		%end
  7167  
  7168  		%routine Constant Bounds
  7169  			vub = top_disp
  7170              pop stack
  7171  
  7172  			vlb = top_disp
  7173              pop stack
  7174  		%end
  7175  
  7176  		%routine Load Constant Bounds
  7177  
  7178              ! JDM JDM debug show the iCode instruction
  7179              %if (ShowIcode=1) %start
  7180                  ListICodeNoOp
  7181              %finish
  7182              ! JDM JDM end debug
  7183  
  7184              Constant Bounds
  7185          %end
  7186  
  7187  		%routine Internal Handler ( %integer id )
  7188              %record(stackfm)%name  lh,rh
  7189              %record(stackfm)  temp
  7190  
  7191              ! Check if event_sub, event_info values are present
  7192              ! if not then load a default value=0
  7193              push const(0) %while (stp < 2)
  7194  
  7195  
  7196              ! So swop the stack entries ensuring the internal macro has valid parameters
  7197              rh == top
  7198              lh == stack(stp-1)
  7199              temp = lh
  7200              lh = rh
  7201              rh = temp
  7202  
  7203              ! Now, stack the event_event value
  7204  			push const( id )
  7205              ! JDM JDM extra feature - report the line invoking the %signal
  7206              ! (extra parameter added to impsignal)
  7207              push const( current line )
  7208  
  7209              ! load the parameters for impsignal( line, event, extra, sub )
  7210              loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! line
  7211              loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! event
  7212              loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! sub
  7213              loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! extra
  7214  
  7215              ! call imp signal, then pop the 4 parameters from the stack
  7216  			perm(signal, 4)
  7217  			uncond jump = next cad %if (id # -1);     ! %monitor will return
  7218  		%end
  7219  
  7220  		%routine Signal Event( %integer event id )
  7221  
  7222              ! JDM JDM debug show the iCode instruction
  7223              %if (ShowIcode=1) %start
  7224                  ListICode
  7225                  spaces(4)
  7226                  printstring( itos(event id,0) )
  7227                  newline
  7228              %finish
  7229              ! JDM JDM end debug
  7230  
  7231  			Internal Handler ( event id )
  7232  		%end
  7233  
  7234  		%routine Monitor
  7235  			Internal Handler ( -1 )
  7236  		%end
  7237  
  7238          %routine Load Monitor
  7239  
  7240              ! JDM JDM debug show the iCode instruction
  7241              %if (ShowIcode=1) %start
  7242                  ListICodeNoOp
  7243              %finish
  7244              ! JDM JDM end debug
  7245  
  7246              Monitor
  7247          %end
  7248  
  7249  		%routine SelectField( %integer field index )
  7250  
  7251              ! JDM JDM debug show the iCode instruction
  7252              %if (ShowIcode=1) %start
  7253                  ListICode
  7254                  spaces(4)
  7255                  printstring( itos(field index,0) )
  7256                  newline
  7257              %finish
  7258              ! JDM JDM end debug
  7259  
  7260  			! Contrary to earlier iCode versions, this one seems to use 'n' for
  7261  			! both normal record member access and alternate formats?
  7262  
  7263              ! Points to the base record
  7264  			lhs == top
  7265  
  7266              ! Push descriptor for the i-th member
  7267  			Stack Var(var(top_format)_pbase - field index)
  7268  
  7269  			%if (top_aform # recordformat) %start
  7270                  !  not record format - must be a member
  7271  				%if (lhs_form = V in S) %or (lhs_form = V in REC) %start
  7272  					top_disp = top_disp + lhs_disp
  7273  					lhs_form = lhs_form - V in S + top_form
  7274  				%else
  7275  					%if (lhs_form = A in REC) %start
  7276  						lhs_form = V in REC
  7277                          lhs_type = integer
  7278  						loadreg(lhs,any)
  7279  						lhs_form = top_form
  7280  					%else
  7281  						%if (lhs_form <= V in R) %start
  7282  							lhs_form = top_form;    ! ????
  7283  						%else
  7284                              ! A in S
  7285  							lhs_extra = lhs_disp
  7286  							lhs_form = top_form + 3
  7287  						%finish
  7288  					%finish
  7289  				%finish
  7290  				lhs_disp = top_disp
  7291  				lhs_type = top_type
  7292  				lhs_aform = top_aform
  7293  				lhs_dim = top_dim
  7294  			%finish
  7295  			lhs_size = top_size
  7296              lhs_format = top_format
  7297  			pop stack
  7298  		%end
  7299  
  7300  		%routine EventTrap( %integer anevent, evfrom )
  7301  			! events: Events to trap (then comma)
  7302  			! evfrom: Label to skip to
  7303  			%integer temp
  7304  
  7305              ! JDM JDM debug show the iCode instruction
  7306              %if (ShowIcode=1) %start
  7307                  ListICode
  7308                  spaces(4)
  7309                  printstring( itos(anevent,0) )
  7310                  printsymbol( ',' )
  7311                  printstring( itos(evfrom,0) )
  7312                  newline
  7313              %finish
  7314              ! JDM JDM end debug
  7315  
  7316  			events = anevent
  7317  			temp = getwork(word size);	    ! get a temp location for SP
  7318  			dumpmr(MOV, BP, temp, 0, SP);	! because our signaller doesn't restore it
  7319  			jump to(evfrom, JMP, 1);	    ! go there now
  7320  			! We need to make EVFROM into a label ID that pass 3 will recognise
  7321  			! to build the trap table, so Jump To sets a variable we pick up here...
  7322  			evfrom = J Tag
  7323  			evep = new tag;				    ! tag for the event body entry point
  7324  			dump label(evep);			    ! which is here
  7325  			dumprm(MOV, SP, BP, temp, 0);	! First thing we do is restore SP
  7326  		%end
  7327  
  7328  		%routine DoubleOp( %integer opr )
  7329  			%integer j,t
  7330  
  7331  			lhs == stack(stp-1)
  7332  			t = lhs_type;
  7333  			j = lhs_size
  7334  			j = j+1 %if t = string
  7335  			amap(lhs)
  7336  			abort("++/-- size") %if (j = 0)
  7337  			push const(j)
  7338  			Operation(MULx)
  7339  			Operation(opr)
  7340  			vmap(top)
  7341              top_type = t
  7342  		%end
  7343  
  7344  		%routine Set CD(%integer Value, %integername CD)
  7345  
  7346              ! JDM JDM debug show the iCode instruction
  7347              %if (ShowIcode=1) %start
  7348                  ListICode
  7349                  spaces(4)
  7350                  printstring( itos(value,0) )
  7351                  newline
  7352              %finish
  7353              ! JDM JDM end debug
  7354  
  7355              ! JDM set value for the appropriate compiler pass
  7356              ! In this case we are in pass2
  7357  			CD = Value&x'3FFF' %if (Value&x'C000' = (PassId&3)<<14)
  7358  		%end
  7359  
  7360  		%predicate Finish Params
  7361  			%integer j
  7362  
  7363              ! JDM JDM debug show the iCode instruction
  7364              %if (ShowIcode=1) %start
  7365                  ListICodeNoOp
  7366              %finish
  7367              ! JDM JDM end debug
  7368  
  7369              in params = 0
  7370  
  7371  			%true %if (amode < 0);            ! end of %record %format defn.
  7372  			%true %if (procvar_level = 128);  ! prim routine reference
  7373  
  7374  			! Here it's a real subroutine - copy any parameters to the PARM area
  7375  			%if (names > first name) %start
  7376                  procvar_pbase = parms;  ! Point one beyond the first parameter
  7377  				frame = (frame + align) & (\align);	! Even up the stack size
  7378  				%if (procvar_type = string) %and (procvar_form = 8) %start
  7379  					frame = frame + word size;  ! string functions have a hidden result parameter
  7380  				%finish
  7381  				procvar_extra = frame;             ! Remember the stack offset
  7382  				procvar_dim = names - first name;  ! and the number of parameters
  7383  				frame = frame + (2 * word size);   ! leave space for return linkage (IP + BP)
  7384  				%for j = first name+1, 1, names %cycle
  7385  					ap == var(j)
  7386  					parms = parms-1
  7387                      fp == var(parms)
  7388  					fp = ap
  7389  					! formal parameter base and displacement is implicit (on the stack)
  7390  					fp_level = 0
  7391  					! we also need to adjust the offsets of the actual parameters, because
  7392  					! they were allocated going "forwards", but will be pushed on the stack
  7393  					! "backwards" - that is, the first item passed will end up with the
  7394  					! highest address.  DefineVar has done part of the work for us by tagging
  7395  					! the displacements in the right style, but it can't tell the whole frame
  7396  					! offset, so we calculate the final offsets here...
  7397  					ap_disp = frame - ap_disp
  7398  				%repeat
  7399  				abort("Params") %if parms < names
  7400  			%finish
  7401  			%true %if (amode = 2);  ! this was just a spec
  7402  			dumplabel(procvar_disp)
  7403  			static alloc = enter
  7404  			frame = -(level * word size);  ! one word for each display entry
  7405  			%false
  7406  		%end
  7407  
  7408          %routine Start Params
  7409  
  7410              ! JDM JDM debug show the iCode instruction
  7411              %if (ShowIcode=1) %start
  7412                  ListICodeNoOp
  7413              %finish
  7414              ! JDM JDM end debug
  7415  
  7416              in params = -1
  7417  			! this is either
  7418              ! a record format,
  7419              ! a procedure,
  7420              ! or a proc spec;
  7421  			!   - block type was set by decvar to tell us which
  7422  			assemble(block type,labs,names);
  7423          %end
  7424  
  7425  		%predicate AlternateFormat( %integer N )
  7426  
  7427              ! JDM JDM debug show the iCode instruction
  7428              %if (ShowIcode=1) %start
  7429                  ListICode
  7430                  spaces(4)
  7431                  printsymbol( N )
  7432                  newline
  7433              %finish
  7434              ! JDM JDM end debug
  7435  
  7436  			! Check the ICODE for faults
  7437              ! and abort for any faulty intermediate code
  7438  			abort("Alt Record '".tostring(sym)."'.") %unless (N = 'A') %or (N = 'B') %or (N = 'C')
  7439  
  7440  			%true %if (N = 'B');             ! alt end
  7441  
  7442  			%if (N = 'A') %start
  7443                  ! alt start
  7444  				decvar == procvar
  7445  				assemble(-2,labs,names)
  7446  			%finish
  7447  
  7448  			%if (N = 'C') %start
  7449  				! Compile the next alternate - update limit and set frame back to where we started
  7450  				max frame = frame %if (frame > max frame)
  7451  				frame = old frame
  7452  			%finish
  7453  			%false
  7454  		%end
  7455  
  7456  ! ******************************************
  7457  ! JDM JDM attempt to include the plant icode and machine code icode
  7458          %routine  Plant
  7459              ! Plant in-line code values (from "*=constant")
  7460              %integer  j
  7461  
  7462              ! We only expect one item on the stack
  7463              abort("Machine Literal") %if (stp <> 1)
  7464  
  7465              %for j = 1, 1, stp %cycle
  7466  ! JDM JDM not sure what next 3 lines do, so commented out
  7467  !                lhs == stacked(j)
  7468  !                word (lhs_disp)
  7469  !                drop (lhs)
  7470  
  7471              %repeat
  7472              ! JDM empty the icode stack
  7473              stp = 0
  7474          %end
  7475  
  7476          %routine Load Plant
  7477  
  7478              ! JDM JDM debug show the iCode instruction
  7479              %if (ShowIcode=1) %start
  7480                  ListICodeNoOp
  7481              %finish
  7482              ! JDM JDM end debug
  7483  
  7484              Plant
  7485          %end
  7486  
  7487          ! JDM being lazy I created a dual purpose list to map
  7488          ! op (NOP:JMP) to a corresponding opX
  7489          ! op (NOP:JMP) to a text version of opX
  7490              
  7491          ! This list maps opId to internal opX
  7492          %constant %integer %array opGenericId(NOP:JMP) =
  7493+               -1,   -1,    -1,     -1,     -1,     -1,     -1,   NEGx,
  7494+         {    NOP,  CWD,   RET,   SAHF,  LEAVE,    DEC,    INC,    NEG, }
  7495+              NOTx,     POP,    PUSH,      -1,      -1,      -1,      -1,    ADDx,
  7496+         {    NOT,  POP,  PUSH,    LEA,    MOV,   XCHG,    ADC,    ADD, }
  7497+             ANDx,   -1,   ORx,   SUBx,   XORx,   LSHx,   RSHx,   DIVx,
  7498+         {    AND,  CMP,    OR,    SUB,    XOR,    SHL,    SHR,   IDIV, }
  7499+             MULx,   -1,    -1,     -1,     -1,     -1,     -1,     -1,
  7500+         {   IMUL, CALL,    JE,    JNE,     JG,    JGE,     JL,    JLE, }
  7501+               -1,   -1,    -1,     -1,     -1
  7502          {     JA,  JAE,    JB,    JBE,    JMP }
  7503  
  7504          ! This list maps opId to internal opX name
  7505          %constant %string(5) %array opGenericName(NOP:JMP) =
  7506+             "NOP",   "CWD",   "RET",  "SAHF", "LEAVE",   "DEC",   "INC",  "NEGx",
  7507+             "NOT",   "POP",  "PUSH",   "LEA",   "MOV",  "XCHG",   "ADC",   "ADD",
  7508+             "AND",   "CMP",    "OR",   "SUB",   "XOR",   "SHL",   "SHR",  "IDIV",
  7509+            "IMUL",  "CALL",    "JE",   "JNE",    "JG",   "JGE",    "JL",   "JLE",
  7510+              "JA",   "JAE",    "JB",   "JBE",   "JMP"
  7511  
  7512          !                                              >> MACHINE CODE <<
  7513          %routine Machine Code( %string(255) code )
  7514              ! This is meant to insert a machine code fragment into the code stream
  7515  
  7516              ! classify the type of the machine code instruction parameter
  7517              %constant %integer     unknown = 0, variable = 1, register = 2, number = 3, mask = 4,    name = 5,  pointer = 6
  7518              ! param type is one of unknown,     variable,     register,     number,     mask,        name,      pointer
  7519              ! param value is       ???,         tag,          reg id,       number,     32-bit mask, integer,   reg id,
  7520              ! param data  is       ???,         tag name,     reg name,     N/A,        N/A,         name,      reg name
  7521              ! param offset is      N/A,         N/A,          N/A,          N/A,        N/A,         N/A,       offset
  7522              !
  7523              ! ass-u-me that a machine code instruction has at most 8 parameters
  7524              %constant %integer param limit = 8;
  7525  
  7526              ! Remember number of CPU registers (1..register limit)
  7527              %constant %integer register limit = 8
  7528  
  7529              ! A machine code string has the form *op_ (item(',' item)*)?
  7530              ! where *,? have the usual regular grammar repetition semantics
  7531              ! op is an instruction name
  7532              !   - (a sequence of alphanumeric chars terminated by '_')
  7533              ! An item has one of the forms:
  7534              ! B such that 0 <= B <= 255
  7535              ! X such that 0 <= X <= 255 returning x = X - 128
  7536              ! 1) varname  == ' ' BB   (BB is a definition tag)
  7537              ! 2) constant == 'N' BBBB (BBBB is 32-bit signed integer)
  7538              ! 3) text     == X+       (X+ converted to an ASCII sequence of x)
  7539              ! The code string can also include ASCII chars
  7540              ! (excluding any varname,constant,text format)
  7541              ! 4) chars    == c*
  7542              ! (where c is one of '<','>','[',']','(',')','#',',')
  7543              !
  7544              ! An instruction can have 0.."param limit" parameters
  7545              ! where the parameters are separated by a ','
  7546              ! One parameter type is a register mask of form
  7547              !  mask == '<' number (',' number)* '>'
  7548              ! This is the ONLY other legal use of a ','
  7549              ! The following defines the legal opcode parameters
  7550              ! 1) register == constant
  7551              !                (a register index, beware register range)
  7552              ! 2) number   == # constant
  7553              !                (a 32-bit signed integer)
  7554              ! 3) mask     == '<' register (',' register)* '>'
  7555              !                (a bit set of registers)
  7556              !                beware limit on count of registers)
  7557              ! 4) modifier == text number
  7558              ! 5) variable == varname,
  7559              !                pointer
  7560              ! 6) pointer  == '[' register ']',
  7561              !                '[' register '+' offset ']',
  7562              !                '{ register '-' offset ']'
  7563              ! 7) offset   == constant
  7564              !                (a 32-bit signed integer)
  7565              !
  7566              ! N.B. a variable could be the value held in varname
  7567              !                 or the address of varname.
  7568              ! N.B. register always refers to its value,
  7569              ! N.B. pointer becomes an address
  7570              !
  7571              ! Legal Intel 386 instruction formats
  7572              ! The modifier, mask parameters are unused
  7573              ! No-op instruction
  7574              ! *op_
  7575              !
  7576              ! One-op instruction
  7577              ! *op_ register
  7578              ! *op_ number
  7579              ! *op_ variable
  7580              !
  7581              ! Two-op MOV instruction
  7582              ! N.B. *op_ A ',' B          == A := B 
  7583              ! *op_ register ',' register == register := register
  7584              ! *op_ register ',' number   == register := number
  7585              ! *op_ register ',' variable == register := variable
  7586              ! *op_ variable ',' register == variable := register
  7587              ! *op_ variable ',' number   == variable := number
  7588              !
  7589              ! Two-op instruction (non-MOV instruction)
  7590              ! *op_ register ',' register == register := register op register
  7591              ! *op_ register ',' number   == register := register op number
  7592              ! *op_ register ',' variable == register := register op variable
  7593              ! *op_ variable ',' register == variable := variable op register
  7594              ! *op_ variable ',' number   == variable := variable op number
  7595  
  7596              %recordformat paramFm(%string(255) data, param name,
  7597+                                   %integer scomma,
  7598+                                            pcomma,
  7599+                                            start,
  7600+                                            end,
  7601+                                            param type,
  7602+                                            param value,
  7603+                                            param offset)
  7604              %string(5) instruction
  7605              %integer params count
  7606              %record(paramFm)%array params(1:param limit)
  7607  
  7608              %routine dump parameter( %integer index )
  7609                  %string(255) t
  7610                  %integer tag,n
  7611                  %string(255) param name
  7612                  %integer param value
  7613                  %integer param offset 
  7614                  %switch sw(0:6)
  7615  
  7616                  param name = params( index )_param name
  7617                  param value = params( index )_param value
  7618                  param offset = params( index )_param offset
  7619  
  7620                  printstring( "Parameter(".itos(index,0).")='".param name."'")
  7621                  newline
  7622  
  7623                  ->sw(params(index)_param type)
  7624                  sw(variable):
  7625                      ! dump the variable data
  7626                      dump tag var( param value, "VAR" )
  7627                      -> esac
  7628                  sw(register):
  7629                      ! dump the register data
  7630                      printstring(" REG   id=".itos(param value,0))
  7631                      newline
  7632                      printstring(" REG name=".param name)
  7633                      newlines(2)
  7634                      -> esac
  7635                  sw(number):
  7636                      ! dump the number data
  7637                      printstring(" NUMBER value=".itos(param value,0))
  7638                      newlines(2)
  7639                      -> esac
  7640                  sw(mask):
  7641                      ! dump the mask data
  7642                      printstring(" MASK value=2_".int2ascii(param value,2,0))
  7643                      newlines(2)
  7644                  sw(name):
  7645                      ! dump the name data
  7646                      printstring(" NAME  name=".param name); newline
  7647                      printstring(" NAME value=2_".int2ascii(param value,2,0))
  7648                      newlines(2)
  7649                      -> esac
  7650                  sw(pointer):
  7651                      ! dump the pointer data
  7652                      printstring(" PTR   id=".itos(param value,0))
  7653                      newline
  7654                      printstring(" PTR name=[".param name)
  7655                      %if (param offset # 0) %start
  7656                          printstring(itos(param offset,0))
  7657                      %finish
  7658                      printstring("]")
  7659                      newline
  7660                      printstring(" PTR offset=".itos(param offset,0))
  7661                      newlines(2)
  7662                      -> esac
  7663                  sw(*):
  7664                      -> esac
  7665                  esac:
  7666              %end
?N unused
?TAG unused
?T unused
  7667  
  7668              %routine parseMachineCode( %string(255) code )
  7669                  %string(255) s,t
  7670                  %string(255) parameters
  7671                  %byte ch
  7672                  %byte inrbflag,insbflag,inabflag,hashflag,plusFlag,minusFlag
  7673                  %switch c(0:127)
  7674                  %label esac, default
  7675                  %integer i,j,k,n,plen,tag
  7676  
  7677                  code -> instruction.("_").parameters
  7678  
  7679                  s = ""
  7680  
  7681                  %if (parameters # "") %start
  7682                      ! parameters is a non-empty string so we ass-u-me at least one parameter
  7683                      params count = 1
  7684                      plen = length(parameters)
  7685                      inrbFlag  = 0; ! not inside round bracket sequence
  7686                      insbFlag  = 0; ! not inside square bracket sequence
  7687                      inabFlag  = 0; ! not inside angle bracket sequence
  7688                      hashFlag  = 0; ! not expecting a number to follow
  7689                      plusFlag  = 0; ! set to indicate a + constant offset (inside [...] sequence)
  7690                      minusFlag = 0; ! set to indicate a - constant offset (inside [...] sequence)
  7691  
  7692                      i = 1;
  7693                      %while (i <= plen) %cycle
  7694  
  7695                          ch = charno( parameters, i)
  7696                          -> c(ch) %if (ch < 128); ! this is an ordinary ASCII char
  7697  
  7698                          ! So, ch > 127, thus this "char" starts a tweaked "name"
  7699                          t = "%"
  7700                          %while (charno(parameters, i) > 127) %cycle
  7701                              ! Append the converted char
  7702                              length(t) = length(t) + 1
  7703                              ! tweak appended "char" to be a legal 7-bit ASCII char
  7704                              charno( t, length(t)) = charno(parameters, i) - 128
  7705                              i = i + 1
  7706                          %repeat
  7707  
  7708                          params( params count )_param type  = name
  7709                          params( params count )_param value = 0; ! value acquired by next N section
  7710  
  7711                          params( params count )_param name  = t
  7712                          s = s.t." "
  7713  
  7714                          -> esac
  7715  
  7716                   c(' '):
  7717                          ! a variable/pointer reference is prefixed by a space.
  7718                          n = (charno( parameters, i+1 ) << 8) + charno( parameters, i+2 )
  7719  
  7720                          ! now determine the variable name
  7721                          t = var( n )_idname
  7722  
  7723                          ! remember this parameter is a variable/pointer (and its tag)
  7724                          %if (insbflag = 1) %start
  7725                              params( params count )_param type = pointer
  7726                          %finish %else %start
  7727                              params( params count )_param type = variable
  7728                          %finish
  7729                          params( params count )_param value = n
  7730                          params( params count )_param name = t
  7731                          s = s.t
  7732  
  7733                          i = i + 3
  7734                          -> esac
  7735                   c('N'):
  7736                          ! A number is prefixed by an ASCII 'N'
  7737                          n = 0
  7738                          n = n + charno( parameters, i+1 ); n = n << 8
  7739                          n = n + charno( parameters, i+2 ); n = n << 8
  7740                          n = n + charno( parameters, i+3 ); n = n << 8
  7741                          n = n + charno( parameters, i+4 )
  7742  
  7743                          %if (params( params count )_param type  = name) %start
  7744                              ! this number is associated with a "name" (i.e. %shl 4)
  7745                              hashFlag = 0
  7746  
  7747                              ! we have the "name" (i.e %shl)
  7748                              ! but now to get the associated numeric value
  7749                              params( params count )_param value = n
  7750  
  7751                              ! convert number to text
  7752                              %if (n > 127) %start
  7753                                  t = "16_".int2ascii( n, 16, 0 )
  7754                              %finish %else %start
  7755                                  t = itos( n, 0 )
  7756                              %finish
  7757  
  7758                              ! now to add the associated number to the s string
  7759                              s = s.t
  7760  
  7761                          %finish %else %if (hash flag <> 0) %and (params( params count )_param type = unknown) %start
  7762                              ! hashflag indicates this is a genuine integer
  7763                              hashFlag = 0
  7764  
  7765                              ! remember this parameter is a number
  7766                              params( params count )_param type  = number
  7767                              params( params count )_param value = n
  7768                              params( params count )_param name  = ""
  7769  
  7770                              %if (n > 127) %start
  7771                                  t = "16_".int2ascii( n, 16, 0 )
  7772                              %finish %else %start
  7773                                  t = itos( n, 0 )
  7774                              %finish
  7775                              
  7776                              s = s.t
  7777                              params( params count )_param name  = t
  7778  
  7779                          %finish %else %if (params( params count )_param type  = mask) %start
  7780  
  7781                              ! Ah, we are between <> == mask
  7782                              ! So we need to update the mask
  7783                              %if (0 < n <= register limit) %start
  7784                                  ! ok, legal register mask range
  7785                                  k = 1<<(n - 1)
  7786                              %finish %else %if (0 < n <= 32) %start
  7787                                  ! oops, bad mask specifier for this CPU
  7788                                  k = 1<<(n - 1)
  7789                              %finish %else %start
  7790                                  ! oops, even worse! Is this a CPU with > 32 registers.
  7791                                  ! we can't fit this mask into a 32-bit integer
  7792                                  ! so, we won't try
  7793                                  k = 0
  7794                              %finish
  7795  
  7796                              ! add the register flag to the mask
  7797                              params( params count )_param value = params( params count )_param value!k
  7798  
  7799                              ! remember N represents the register number but add the reg name
  7800                              ! Ensure we are referencing a valid register
  7801                              ! Adjust register limit for a specific CPU
  7802                              %if (0 < n <= register limit) %start
  7803                                  s = s.regname(n)
  7804                              %finish %else %start
  7805                                  s = s."R??"
  7806                              %finish
  7807                              
  7808                          %finish %else %start
  7809                              ! ok this came from a constant integer in the IMP program
  7810                              ! ASS-U-ME that this constant represents a register
  7811                              ! So, replace the number with the register name
  7812                              ! Register name is specific to a processor architecture
  7813                              ! IMP code with embedded assembler should reference a
  7814                              ! register by number.
  7815                              ! The IMP pass2 for that processor should store a mapping
  7816                              ! between "register" number and register name.
  7817                              ! eg Intel eax or ebp
  7818  
  7819                              ! remember this parameter is a variable/pointer (and its tag)
  7820                              %if (insbflag = 1) %start
  7821                                  params( params count )_param type = pointer
  7822                              %finish %else %start
  7823                                  params( params count )_param type  = register
  7824                              %finish
  7825  
  7826                              %if (plusFlag = 1) %start
  7827                                  ! remember this "parameter" is a positives pointer offset
  7828                                  params( params count )_param offset = n
  7829                                  t = itos( n, 0)
  7830                              %finish %else %if (minusFlag = 1) %start
  7831                                  ! remember this "parameter" is a negative pointer offset
  7832                                  params( params count )_param offset = -n
  7833                                  ! however, negative sign (and or #) already output
  7834                                  t = itos( n, 0)
  7835                              %finish %else %start
  7836                                  ! remember this parameter is a register
  7837                                  params( params count )_param value = n
  7838  
  7839                                  ! Ensure we are referencing a valid register
  7840                                  ! Adjust register limit for a specific CPU
  7841                                  %if (0 < n <= register limit) %start
  7842                                      t = regname(n)
  7843                                  %finish %else %start
  7844                                      t = "R??"
  7845                                  %finish
  7846  
  7847                                  params( params count )_param name  = t
  7848                              %finish
  7849  
  7850                              s = s.t
  7851                          %finish
  7852                          i = i + 5
  7853                          -> esac
  7854  
  7855                   c('#'):
  7856                          ! let this char through
  7857                          ! BUT remember # is assumed to prefix a positive number
  7858                          hashFlag = 1
  7859                          -> default
  7860  
  7861                   c(','):
  7862                          ! let this char through
  7863                          ! comma separates instruction parameters
  7864                          ! (or values between brackets)
  7865  
  7866                          { ok, check to see if this is a parameter separator }
  7867                          %if ((inabFlag + inrbFlag + insbFlag) = 0) %start
  7868                             { ok, we are not inside one of the "bracket" types }
  7869                             ! REMEMBER, the parameter type and value should have been
  7870                             ! determined previously
  7871                             ! note comma location in the s string
  7872                             params(params count)_scomma = length(s) + 1
  7873  
  7874                             ! note comma location in the parameters string
  7875                             params(params count)_pcomma = i
  7876                             ! beware fence post error
  7877                             ! we are counting fence posts (,)
  7878                             ! and their locations
  7879                             ! So "last" fence post at end of parameters string
  7880  
  7881                             ! we have an additional parameter
  7882                             params count = params count + 1
  7883                             ! BUT set the param type appropriately
  7884                             params( params count )_param type = unknown
  7885                             params( params count )_param offset = 0
  7886  
  7887                          %finish
  7888                          -> default
  7889  
  7890                   c('+'):
  7891                          ! pass this char( only allowed between [] brackets
  7892                          plusFlag = 1
  7893                          minusFlag = 0
  7894                          -> default
  7895                      
  7896                   c('-'):
  7897                          ! pass this char( only allowed between [] brackets
  7898                          plusFlag = 0
  7899                          minusFlag = 1
  7900                          -> default
  7901                      
  7902                   c('('):
  7903                          ! pass this char (opening round brackets)
  7904                          inrbFlag = 1
  7905                          -> default
  7906  
  7907                   c(')'):
  7908                          ! pass this char (closing round brackets)
  7909                          inrbFlag = 0
  7910                          -> default
  7911  
  7912                   c('['):
  7913                          ! we are referencing an indirect variable
  7914                          params( params count )_param type = pointer
  7915                          ! initialise the name,value and offset
  7916                          params( params count )_param name  = ""
  7917                          params( params count )_param value = 0
  7918                          params( params count )_param offset = 0
  7919  
  7920                          ! pass this char (opening square brackets)
  7921                          insbFlag = 1
  7922                          -> default
  7923  
  7924                   c(']'):
  7925                          ! pass this char (closing square brackets)
  7926                          plusFlag = 0
  7927                          minusFlag = 0
  7928                          insbFlag = 0
  7929                          -> default
  7930  
  7931                   c('<'):
  7932                          ! We are starting a mask parameter
  7933                          params( params count )_param type  = mask
  7934                          ! initialise the value and name
  7935                          params( params count )_param name  = ""
  7936                          params( params count )_param value = 0
  7937                          params( params count )_param offset = 0
  7938                          ! pass this char (opening angle brackets)
  7939                          inabFlag = 1
  7940                          -> default
  7941  
  7942                   c('>'):
  7943                          ! pass this char (closing angle brackets)
  7944                          inabFlag = 0
  7945                          -> default
  7946  
  7947                  default:
  7948                   c(*):
  7949                          ! pass these chars
  7950                          ! chars > 127 are already dealt with
  7951                          ! So, this deals with remaining chars
  7952                          s = s.tostring( charno( parameters, i) )
  7953                          i = i + 1
  7954                          -> esac
  7955                      esac:
  7956  
  7957                      %repeat
  7958  
  7959                  %finish %else %start
  7960                      ! Oh, this instruction has no parameters
  7961                      params count = 0
  7962                  %finish
  7963  
  7964                  %if (params count # 0) %start
  7965                      ! now to identify each instruction parameter inside the s string
  7966                      %for i = 1,1,params count %cycle
  7967  
  7968                          %if (i = 1) %then params(i)_start = 1 %else params(i)_start = params(i-1)_scomma + 1
  7969                          %if (i = params count) %then params(i)_end = length(s) %else params(i)_end = params(i)_scomma - 1
  7970                          params(i)_data = ""
  7971                          %for j = params(i)_start,1,params(i)_end %cycle
  7972                              params(i)_data = params(i)_data.toString( charno(s,j) )
  7973                          %repeat
  7974  
  7975                      %repeat
  7976                  %finish
  7977  
  7978                  ! JDM JDM debug show the iCode instruction
  7979                  %if (ShowIcode=1) %start
  7980                      ListICode
  7981                      spaces(4)
  7982                      printstring( instruction )
  7983  
  7984                      %if (params count # 0) %start
  7985                          printsymbol( ' ' )
  7986                          ! now to identify each instruction parameter inside the s string
  7987                          %for i = 1,1,params count %cycle
  7988                              %if (i > 1) %start
  7989                                  printsymbol( ',' )
  7990                              %finish
  7991                              printstring( params(i)_data )
  7992                          %repeat
  7993                      %finish
  7994                      newline
  7995                  %finish
  7996                  ! JDM JDM end debug
  7997  
  7998              %end
?TAG unused
  7999  
  8000              %integer %fn validateMachineCode( %string(5) instruction )
  8001                  %string(5) opNameX
  8002                  %integer i
  8003                  %integer opId,opIdx
  8004  
  8005                  ! determine the opId for this instruction
  8006                  ! set a default "ILLEGAL" value for the opId
  8007                  ! Although Intel 386 has opCodes 0..255
  8008                  ! the count of opCode names is much less than 255
  8009                  ! so, we are safe to set opId and opIdx = 255
  8010                  opId = -1
  8011                  opIdx = -1
  8012                  %for i = NOP,1,JMP %cycle
  8013                      %if (instruction = opGenericName(i)) %start
  8014                          opId = i
  8015                          opIdx = opGenericId(opId)
  8016                          %if (opIdx # -1) %start
  8017                              opNameX = instruction
  8018                          %finish %else %start
  8019                              opNameX = itos(opId,0)
  8020                          %finish
  8021                      %finish
  8022                  %repeat
  8023  
  8024                  ! Currently, we are NOT allowing any floating point instructions
  8025  !                %for i = FILD,1,FLDPI %cycle
  8026  !                   %if instruction = flopname(i) %then opId = i
  8027  !                %repeat
  8028  !                %if (opId < FILD) %then instruction = opName(opId) %else instruction = flopName(opId)
  8029             
  8030                  ! use short form of %if statement (as an example)
  8031                  abort("MCODE has illegal/unknown instruction name") %if (opId = -1)
  8032  
  8033                  %result = opId
  8034              %end
  8035  
  8036              %routine insertMachineCode( %string(5) instruction, %integer opId )
  8037                  %integer opIdx
  8038                  
  8039                  opIdx = opGenericId(opId)
  8040  
  8041                  %if (params count = 0) %start
  8042                      selectoutput(listout)
  8043                      printstring( "**** Instructions with no parameters not yet implemented" ); newline
  8044                  %finish %else %if (params count = 1) %start
  8045                      %if (opId # -1) %start
  8046                          %if (params(1)_param type = variable) %start
  8047                              Stack Var( params(1)_param value )
  8048                              Operation(opIdx)
  8049                          %finish %else %if (params(1)_param type = register) %start
  8050                              dumpur(opId, params(1)_param value)
  8051                          %finish %else %if (params(1)_param type = pointer) %start
  8052                              abort( "Opcode ".instruction." with one parameter can only operate on an address/register ".params(1)_param name )
  8053                          %finish %else %start
  8054                              abort( "Opcode ".instruction." is attempting to operate on unexpected location ".params(1)_param name )
  8055                          %finish
  8056                      %finish %else %start
  8057                          abort( "Attempting to apply unknown opcode ".instruction )
  8058                      %finish
  8059                  %finish %else %if (params count = 2) %start
  8060                      ! 3) output the implied code fragment
  8061                      %if (opId = MOV) %start
  8062                          %if (params(1)_param type = variable) %start
  8063                              %if (params(2)_param type = register) %start
  8064                                  Stack Var( params(1)_param value )
  8065                                  %if (top_type = general) %or (top_type = integer) %or (top_type = byte) %or (top_type = record) %start
  8066                                      storeReg( top, params(2)_param value )
  8067                                      pop rel
  8068                                  %finish %else %start
  8069                                      pop rel
  8070                                      abort( "Attempting to store reg ".params(2)_param name." in a non-integer variable" )
  8071                                  %finish
  8072                              %finish %else %if (params(2)_param type = number) %start
  8073                                  Stack Var( params(1)_param value )
  8074                                  Push Const( params(2)_param value )
  8075                                  Assign(1)
  8076                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8077                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8078                              %finish %else %start
  8079                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8080                              %finish
  8081                          %finish %else %if (params(1)_param type = pointer) %start
  8082                              %if (params(2)_param type = register) %start
  8083                                  dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8084                              %finish %else %if (params(2)_param type = number) %start
  8085                                  selectoutput(listout)
  8086                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8087                                  dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8088                                  printstring(" NOT YET IMPLEMENTED"); newline
  8089                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8090                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8091                              %finish %else %start
  8092                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8093                              %finish
  8094                          %finish %else %if (params(1)_param type = register) %start
  8095                              %if (params(2)_param type = variable) %start
  8096                                  Stack Var( params(2)_param value )
  8097                                  LoadReg( top, params(1)_param value )
  8098                                  pop rel
  8099                              %finish %else %if (params(2)_param type = pointer) %start
  8100                                  dumprm(opId, params(1)_param value, params(2)_param value, params(2)_param offset, 0)
  8101                              %finish %else %if (params(2)_param type = register) %start
  8102                                  dumprr(opId, params(1)_param value, params(2)_param value )
  8103                              %finish %else %if (params(2)_param type = number) %start
  8104                                  Push Const( params(2)_param value )
  8105                                  LoadReg( top, params(1)_param value )
  8106                                  pop rel
  8107                              %finish %else %start
  8108                                  abort( "Attempting to store unexpected type in register ".params(1)_param name )
  8109                              %finish
  8110                          %finish %else %start
  8111                              abort( "Attempting to ".instruction." into non-variable/register location" )
  8112                          %finish
  8113                      %finish %else %if (opIdx # -1) %start
  8114                          %if (params(1)_param type = variable) %start
  8115                              %if (params(2)_param type = register) %start
  8116                                  Stack Var( params(1)_param value )
  8117                                  dumpmr(opId, top_base!top_scope, top_disp, top_extdisp, top_base)
  8118                                  pop rel
  8119                              %finish %else %if (params(2)_param type = number) %start
  8120                                  Stack Var( params(1)_param value )
  8121                                  Stack Var( params(1)_param value )
  8122                                  Push Const( params(2)_param value )
  8123                                  Operation(opIdx)
  8124                                  Assign(1)
  8125                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8126                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8127                              %finish %else %start
  8128                                  abort( "Opcode ".instruction." is attempting to store unexpected type in variable ".params(1)_param name )
  8129                              %finish
  8130                          %finish %else %if (params(1)_param type = pointer) %start
  8131                              %if (params(2)_param type = register) %start
  8132                                  dumpmr(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8133                              %finish %else %if (params(2)_param type = number) %start
  8134                                  selectoutput(listout)
  8135                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8136                                  dumpmi(opId, params(1)_param value, params(1)_param offset, 0, params(2)_param value)
  8137                                  printstring(" NOT YET IMPLEMENTED"); newline
  8138                              %finish %else %if (params(2)_param type = variable) %or (params(2)_param type = pointer) %start
  8139                                  abort(" No INTEL instruction can have indirect pointers for both source and destination")
  8140                              %finish %else %start
  8141                                  abort( "Attempting to store unexpected type in variable ".params(1)_param name )
  8142                              %finish
  8143                          %finish %else %if (params(1)_param type = register) %start
  8144                              %if (params(2)_param type = variable) %start
  8145                                  Stack Var( params(2)_param value )
  8146                                  dumprv( opId, params(1)_param value, top)
  8147                                  pop rel;
  8148                              %finish %else %if (params(2)_param type = pointer) %start
  8149                                  selectoutput(listout)
  8150                                  printstring(" EXPERIMENTAL IMPLEMENTATION"); newline
  8151                                  dumprm(opId, params(1)_param value, params(2)_param value, params(1)_param offset, 0 )
  8152                                  printstring(" NOT YET IMPLEMENTED"); newline
  8153                              %finish %else %if (params(2)_param type = register) %start
  8154                                  dumprr(opId, params(1)_param value, params(2)_param value )
  8155                              %finish %else %if (params(2)_param type = number) %start
  8156                                  dumpri(opId, params(1)_param value, params(2)_param value )
  8157                              %finish %else %start
  8158                                  abort( "Opcode ".instruction." is attempting to store unexpected type in register ".params(1)_param name )
  8159                              %finish
  8160                          %finish %else %start
  8161                              abort( "Opcode ".instruction." is attempting to store in unexpected location ".params(1)_param name )
  8162                          %finish
  8163                      %finish %else %start
  8164                          abort( "Attempting to apply unknown opcode ".instruction )
  8165                      %finish
  8166                  %finish %else %start
  8167                      abort("Opcode ".instruction." has unexpected number ".itos(params count,0)."of parameters.")
  8168                  %finish
  8169              %end
  8170  
  8171              %integer opId
  8172  
  8173              ! ok, lets go
  8174              ! First, parse the machine code text
  8175              parseMachineCode( code )
  8176  
  8177              ! Next, check that we have a valid instruction
  8178              opId = validateMachineCode( instruction )
  8179  
  8180              ! Finally add the instruction to the output
  8181              insertMachineCode( instruction, opId )
  8182          %end
?DUMPPARAMETER unused
  8183  ! ******************************************
  8184  
  8185          !--------------------------------------------------------------
  8186          ! Code for ASSEMBLE starts here...
  8187          First Name = Names
  8188          First Label = Labs
  8189          Proc Var == Decvar
  8190          last skip = -1
  8191          old frame = frame
  8192          frame = 0
  8193          events = 0
  8194          evep = 0
  8195          evfrom = 0
  8196  
  8197          %if (amode >= 0) %start
  8198              ! Not a RecordFormat
  8199              level = level+1
  8200              abort("Level") %if (level > max level) %and (spec = 0)
  8201              worklist(level) = 0
  8202  
  8203              %if (amode = 0) %start;
  8204                  ! %begin block
  8205                  %if (level = 1) %start
  8206                      ! Initial %begin ?
  8207                      ! Name the block for stack traceback readability
  8208                      block name = program ip
  8209  
  8210                      ! remember the program entry name for the linker
  8211                      external id = program ep
  8212                      otype = external
  8213                      potype = otype
  8214                  %else
  8215                      block name = "%begin block"
  8216                  %finish
  8217                  static alloc = enter
  8218                  frame = -(level * word size);  ! 1 word for each display entry
  8219              %finish
  8220          %else
  8221              %if (amode = -1) %start
  8222                  ! normal record format
  8223                  ProcVar_pbase = parms;        ! where our members start
  8224              %else
  8225                  ! alternates start at the current offset
  8226                  %if (amode = -2) %then frame = oldframe
  8227              %finish
  8228              ! start counting space here
  8229              max frame = frame
  8230          %finish
  8231  
  8232  		!  --- main compilation loop ---
  8233  		%cycle
  8234  			sym = Pending
  8235              read symbol(Pending)
  8236  
  8237              ! count how many iCode instructions have been read
  8238              iCodeCount = iCodeCount + 1
  8239  
  8240              ! defend against illegal iCode instructions
  8241              %if (getiCodeName(sym)="ILLEGAL") %start
  8242  				selectoutput(0)
  8243  				printsymbol('(')
  8244                  write(sym, 0)
  8245                  printsymbol(',')
  8246                  write(Pending, 0)
  8247                  printsymbol(')')
  8248  				abort("Bad I Code")
  8249  			%finish
  8250              ! From this point the iCode is a legal iCode
  8251              ! So we remember the current iCode instruction
  8252              ! Hopefully the iCode instruction parameters are valid
  8253              iCodeInst = sym
  8254  
  8255  			-> c(iCodeInst)
  8256  
  8257  c('!'):     Load Operation( ORx );              %continue
  8258  c('"'):	    Load Compare Double;                %continue
  8259  c('#'):     Jump Forward( ReadTag, NE );        %continue
  8260  c('$'):     Define Var( ReadTag, Get Ascii( ',' ), ReadTagComma, ReadTagComma, ReadTag );  %continue
  8261  c('%'):     Load Operation( XORx );             %continue
  8262  c('&'):     Load Operation( ANDx );             %continue
  8263  c(''''):    Input String Value( ReadString );   %continue; ! Stack string constant
  8264  c('('):     Jump Forward( ReadTag, LE );        %continue
  8265  c(')'):     Jump Forward( ReadTag, GE );        %continue
  8266  c('*'):     Load Operation( MULx );             %continue
  8267  c('+'):     Load Operation( ADDx );             %continue
  8268  c('-'):     Load Operation( SUBx );             %continue
  8269  c('.'):     Load Operation( CONCx );            %continue
  8270  c('/'):     Load Operation( DIVx );             %continue
  8271  c(':'):     Define Compiler Label( ReadTag );   %continue; ! Define compiler label
  8272  c(';'):     Load End of Block;                  %exit
  8273  c('<'):     Jump Forward( ReadTag, LT );        %continue
  8274  c('='):     Jump Forward( ReadTag, EQ );        %continue
  8275  c('>'):     Jump Forward( ReadTag, GT );        %continue
  8276  c('?'):     Load Compare Values;                %continue; ! Compare values
  8277  c('@'):     Load Var( ReadTag );                %continue; ! Load variable descriptor (calls Stack Var)
  8278  c('A'):     Init( ReadTag );                    %continue; ! Initialise OWN variable
  8279  c('B'):     Jump Backward( ReadTag );           %continue; ! Backward Jump
  8280  c('C'):     Load Compare Addresses;             %continue; ! Compare addresses
  8281  c('D'):     Input Real Value( ReadReal );       %continue; ! Stack real constant
  8282  c('E'):     Load Compile Call( top );           %continue
  8283  c('F'):     Jump Forward( ReadTag, Always );    %continue; ! Forward Jump
  8284  c('G'):     Get Alias Value( ReadString );      %continue; ! Alias for item about to be declared
  8285  c('H'):     Load Compile Begin;                 %continue; ! Start of BEGIN block
  8286  c('I'):     Abort("Pascal?");                              ! {ESCAPE for Pascal etc.}
  8287  c('J'):     User Jump( ReadTag );               %continue; ! Jump to user label
  8288  c('K'):     Load Return( False );               %continue; ! %false
  8289  c('L'):     Define User Label( ReadTag );       %continue; ! Define user label
  8290  c('M'):     Load Return( Map );                 %continue; ! MAP result
  8291  c('N'):     Load Const( ReadInteger );          %continue; ! Load integer constant (calls Push Const)
  8292  c('O'):     Update Line( ReadTag );             %continue; ! Set line number
  8293  c('P'):     Load Plant;                         %continue; ! Machine code literal
  8294  c('Q'):     Load Operation( RDIVx );            %continue
  8295  c('R'):     Load Return( Routine );             %continue; ! RETURN
  8296  c('S'):     Load Assign( 1 );                   %continue; ! Normal value assignment
  8297  c('T'):     Load Return( True );                %continue; ! %true
  8298  c('U'):     Load Operation(NEGx);               %continue
  8299  c('V'):     Load Return ( Fn );                 %continue; ! FN result
  8300  c('W'):     Switch Jump( ReadTag );             %continue; ! Jump to switch
  8301  c('X'):     Load Operation( EXPx );             %continue
  8302  !'Y' - UNUSED
  8303  c('Z'):     Load Assign( 0 );                   %continue; ! Assign address '=='
  8304  c('['):     Load Operation( LSHx );             %continue
  8305  c('\'):     Load Operation( NOTx );             %continue
  8306  c(']'):     Load Operation( RSHx );             %continue
  8307  c('^'):     Set Record Format( ReadTag );       %continue; ! {Set Format}
  8308  c('_'):     Switch Label( ReadTag );            %continue; ! Define switch label
  8309  c('a'):     Load Array Ref( 0 );                %continue
  8310  c('b'):     Load Constant Bounds;               %continue; ! Define constant bounded Dope Vector
  8311  !'c' NOT IMPLEMENTED
  8312  c('d'):     Dimension( ReadTagComma, ReadTag ); %continue; ! dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  8313  c('e'):     Signal Event( ReadTag );            %continue; ! %signal event
  8314  c('f'):     Compile For( ReadTag );             %continue
  8315  c('g'):     Dimension( ReadTagComma, ReadTag ); %continue; ! (different to PSR) dimensions, count of variables - NB in params:  =0 -> simple array,  # 0 -> array-in-record
  8316  c('h'):
  8317  			! compiler op(n)
  8318  !			compiler op(ReadTag)
  8319                                                  %continue
  8320  c('i'):     Load Array Ref( 1 );                %continue
  8321  c('j'):     Load Assign( 2 );                   %continue; ! JAM transfer
  8322  c('k'):     Jump Forward( ReadTag, FF );        %continue; ! Branch on FALSE (= 0)
  8323  c('l'):     Load Language Flags( ReadTag );     %continue; ! We currently only support standard IMP - who knows the future
  8324  c('m'):     Load Monitor;                       %continue; ! %monitor
  8325  c('n'):     SelectField( ReadTag );             %continue; ! Select member from record format
  8326  c('o'):     EventTrap( ReadTagComma, ReadTag ); %continue; ! %on %event block
  8327  c('p'):     Load Assign( -1 );                  %continue; ! Pass a parameter
  8328  c('q'):     DoubleOp( SUBx);                    %continue; !--
  8329  c('r'):     Resolve( ReadTag );                 %continue
  8330  c('s'):     Load Perm(stop, 0);                 %continue; ! %stop
  8331  c('t'):     Jump Forward( ReadTag, TT );        %continue; ! Branch on TRUE (# 0)
  8332  c('u'):     DoubleOp( ADDx );                   %continue; !++
  8333  c('v'):     Load Operation( ABSx );             %continue
  8334  c('w'):     Machine Code( Get Ascii( ';' ) );   %continue; ! JDM: allowed call to Machine code
  8335  c('x'):     Load Operation(REXPx);              %continue
  8336  c('y'):     Set CD( ReadTag, diagnose);         %continue; ! %diagnose n (what about pass3? how do we send to pass3)
  8337  c('z'):     Set CD( ReadTag, control );         %continue; ! %control n
  8338  c('{'):     StartParams;                        %continue; ! Start of formal parameters
  8339  c('}'):     %exit %if Finish Params;            %continue; ! End of formal parameters
  8340  c('~'):     %exit %if AlternateFormat( ReadByte )
  8341                                                  %continue; ! alternate record format
  8342  c(*):       abort("Bad I Code");				           ! To catch the sinners!! (that is - an unimplemented iCode)
  8343          %repeat
  8344   
  8345          %if (amode >= 0) %start
  8346              ! end of declarative block
  8347              %while (worklist(level) # 0) %cycle
  8348                  worklist(level) = ret gp tag(worklist(level))
  8349              %repeat
  8350              level = level-1
  8351          %else
  8352              ! end of record format defn
  8353              %if (amode = -2) %start
  8354                  ! end of alternative only
  8355                  ! use the longest alternative
  8356                  frame = max frame %if (max frame > frame)
  8357                  old frame = frame
  8358              %else
  8359                  ! **** temporary ****
  8360                  frame = (frame+align)&(\align)
  8361                  procvar_size = frame
  8362              %finish
  8363          %finish
  8364          frame = old frame
  8365  
  8366      %end;  ! assemble
  8367  
  8368      %routine initialise pass2
  8369          %string(255) the source file name
  8370          %integer i,j
  8371  
  8372          ! The %signal 9,0 and %signal 9,1 events are allowed by default
  8373          ! However, these events should not be triggered inside  pass2
  8374          ! when reading the .icd or .imp source files
  8375          block eof event
  8376  
  8377          %if (length( getenv( getenvindex( "IMP_ICODE" ) ) ) # 0) %start
  8378              ! ok, we want to show the iCode records
  8379              ShowICode = 1
  8380          %finish
  8381  
  8382          ! JDM - Before we do any file I/O we need to get the source file name
  8383          ! (as used to feed the 'source' stream)
  8384  
  8385          select input( source )
  8386          the source file name = input name
  8387  
  8388          ! JDM - ok, now we can really start
  8389          select input( icode )
  8390          select output( objout )
  8391  
  8392          var(0) = 0;              !  for %RECORD(*) . . . . .
  8393          parms = max vars
  8394  
  8395          ! Initialise the GP Tag ASL
  8396          %for i=1,1,Max GP %cycle
  8397              GP Tags(i)_link = i - 1
  8398          %repeat
  8399          gp asl = Max GP
  8400  
  8401          ! Tell the linker our source file name
  8402          dumpsourcename( the source file name )
  8403  
  8404          ! predefine the perms for the linker
  8405          ! We ignore the number (j) because we know they are in sequence
  8406          %for i=1,1,lastperm %cycle
  8407              j = externalref(permname(i))
  8408          %repeat
  8409  
  8410      %end
  8411  
  8412      !              -------- it all starts here ---------
  8413      initialise pass2
  8414  
  8415      !  Prime SYM/NEXT pair
  8416      read symbol(Pending)
  8417      Spec = 0
  8418      decvar == begin
  8419      assemble(-3,0,0)
  8420  
  8421      ! We flush constants
  8422      flush cot
  8423      flush data
  8424      flush switch
  8425  
  8426  %endofprogram
?DUMPRR8 unused
?IFCALL unused
?GETINTERNALFORMNAME unused
?GETTYPEOFSTRING unused
?FPRESULTLOC unused
?NEGATED unused
?DISPLAY unused
?BSS unused
?FDIVR unused
?FSUBR unused
?XCHG unused
?PERMRT unused
?OWN unused
?XNAMEARRAY unused
?XARRAYNAME unused
?XARRAY unused
?DH unused
?CH unused
?AH unused
?BL unused
?DL unused
?CHECKUNASS unused

  5667 Statements compiled
