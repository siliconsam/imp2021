
    %include "inc.386.registers"

    ! Assign the constant values (MUST match values in prim-rtl-file.h)
    %constant %integer max stream = 8
    %constant %integer std null handle = 0
    %constant %integer std err handle  = 1
    %constant %integer std in handle   = 2
    %constant %integer std out handle  = 3
    %constant %integer IS INPUT = 0 << 0
    %constant %integer IS OUTPUT = 1 << 0
    %constant %integer IS TEXT = 0 << 1
    %constant %integer IS BINARY = 1 << 1

    %constant %integer FILE IN = 1
    %constant %integer FILE OUT = 2

    %constant %integer uninitialised = 0
    %constant %integer initialised = 1

    %record %format impstream ( %integer lookahead, flags, %string(255) file name, %integer handle )
    %record %format impio ( %integer current stream, 
                            %record(impstream) %array streams(0:max stream) )

    %own %record (impio) in
    %own %record (impio) out
    %own %record (impstream) null stream
    %own %record (impstream) error stream

    %own %integer initialised state = uninitialised
    %external %integer fileerror %alias "_errno"

    ! This converts an IMP string in-situ to become a C string
    ! We just need the address of the IMP string
    %routine imptocstring( %string(*) %name impstring )
        %integer len,i
        %byte %integer %name src

        %if addr( impstring ) # 0 %start
            ! Find the length of the IMP format string
            len = length( impstring )

            ! Convert to a C format string
            ! We do this in one step 0..len-1
            ! copying from impstring(i+1) to impstring(i)
            ! lastly, store 0 in impstring(len)
            %for i = 0,1,len - 1 %cycle
                src == byteinteger( addr( impstring ) + i + 1)
                charno( impstring, i ) = src
            %repeat
            charno( impstring, len ) = 0
        %finish
    %end

    %external %predicate need to initialise
        %true %if (initialised state = uninitialised)
        %false
    %end

    %external %integer %function get max stream
        %result = MAX STREAM
    %end

    %routine initialise stream( %record(impstream) %name s )
        s_handle = 0
        length(s_file name) = 0
        s_flags = 0
        s_lookahead = -1
    %end

    %routine finalise stream( %record(impstream) %name s )
        %if (s_handle # 0) %then close( s_handle)

        initialise stream( s )
    %end

    %external %routine initialise io
        %integer i

        in_current stream = 0
        out_current stream = 0

        %for i = 0,1,max stream %cycle
            initialise stream( in_streams(i) )
            initialise stream( out_streams(i) )
        %repeat
        initialise stream( error stream )

        null stream_handle = 0
        null stream_file name = "null"
        error stream_handle = get std err handle
        error stream_file name = "stderr"
        in_streams(0)_handle = get std in handle
        in_streams(0)_file name = "stdin" 
        out_streams(0)_handle = get std out handle
        out_streams(0)_file name = "stdout"

        initialised state = initialised
    %end

    %external %routine terminate io
        %integer i

        in_current stream = -1
        out_current stream = -1

        %for i = 1,1,max stream %cycle
            finalise stream( in_streams(i) )
            finalise stream( out_streams(i) )
        %repeat

        initialised state = uninitialised
    %end

    %external %routine debug symbol( %integer c )
        %if need to initialise %then initialise io

        %if (error stream_handle # 0) %then put char( error stream_handle, c )
    %end

    %external %routine debug real( %long %real d )
        %if need to initialise %then initialise io

        %if (error stream_handle # 0) %then put double( error stream_handle, d )
    %end

    %constant %integer  intgr  = 1
    %constant %integer  float  = 2
    %constant %integer  strng  = 3
    %constant %integer  byte   = 6
    %constant %integer  double = 8

    %external %integer %function readbuffer( %name ptr, %integer count )

        %integer i,actualcount

        %integer framep
        %integer %name dvp
        %integer dim, itemsz, intsz
        %integer lb, ub

        ! assume we are reading data into a byte array (or string)
        itemsz = 1

%if ((DEBUGMODE & dbgio) # 0) %start
debug string("READBUFFER: address(ptr)=".int2ascii(addr(ptr),16,0) ); debug newline
debug string("READBUFFER:  sizeof(ptr)=".int2ascii(sizeof(ptr),16,0) ); debug newline
debug string("READBUFFER:  typeof(ptr)=".int2ascii(typeof(ptr),16,0) ); debug newline
debug string("READBUFFER: count=".itos(count,0) ); debug newline
%finish

        %if (0 <= sizeof( ptr ) <= 255) %start
            ! Ok, it should be a primitive type
            ! We need to adjust itemsz to type size
            ! NB strings/byte arrays have itemsz = 1
            ! So only need to adjust for integer,float or double
            %if (typeof(ptr) = intgr) %then itemsz = 4
            %if (typeof(ptr) = float) %then itemsz = 4
            %if (typeof(ptr) = double) %then itemsz = 8
        %else
            ! Ok,This seems to be an array/record
            ! Get the Base/Frame Pointer
            *mov_ framep,ebp

            ! Now get the expected 3 parameters
%if ((DEBUGMODE & dbgio) # 0) %start
debug string("READBUFFER: [framep +  8]=".itos(integer( framep + 8 ),0) ); debug newline
debug string("READBUFFER: [framep + 12]=".int2ascii(integer( framep + 12 ),16,0) ); debug newline
debug string("READBUFFER: [framep + 16]=".int2ascii(integer( framep + 16 ),16,0) ); debug newline
%finish

            dvp == integer( framep + 16 )
            dim = integer( dvp )
            intsz = sizeof(dim); ! get the size of a 32-bit integer
            ! pick up the element size...
            itemsz = integer( dvp + sizeof(dim)*(2*dim + 1) )

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("READBUFFER: IMPADEF:     dim: dvp[0]='".itos(dim,0)."'"); debugnewline
%finish
            %for i=1,1,dim %cycle
                lb = integer( dvp + sizeof(dim)*(2*i - 1) )
                ub = integer( dvp + sizeof(dim)*(2*i) )

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("READBUFFER: IMPADEF: lb['".itos(i,0)."']: dvp[".itos(2*i-1,0)."]='".itos(lb,0)."'"); debug newline
debugstring("READBUFFER: IMPADEF: ub['".itos(i,0)."']: dvp[".itos(2*i,0)."]='".itos(ub,0)."'");   debug newline
%finish

            %repeat

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("READBUFFER: IMPADEF:      sz: dvp[".itos((2*dim)+ 1,0)."]='".itos(itemsz,0)."'"); debug newline
debugstring("READBUFFER: IMPADEF:   intsz:   ='".itos(sizeof(dim),0)."'"); debug newline
%finish

        %finish

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdin)
        %signal 9, 9 %unless (0 < in_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        ! We actually load the buffer as an array of bytes
        ! We need the stream handle, count of items space, item size, buffer address
        ! Where, count * itemsz = size in bytes of buffer storage
        actualcount = readbytes( in_streams( in_current stream )_handle, count, itemsz, byteinteger( addr(ptr) ) )

        ! If we are storing in an IMP string then we need to convert the stored buffer
        ! from C string format (zero start index)  to IMP string format
        %if (0 <= sizeof( ptr ) <= 255) %and (typeof(ptr) = strng) %start
            ! It is a string!!
            ! Therefore we need to move the chars from n to n+1 location
            ! Thus, we can store the IMP string length in location 0 (its expected location)
            ! Use actualcount as number of chars in the string
            ! JDM should check that actualcount < count else buffer overflow
            %for i=actualcount-1,-1,0 %cycle
                charno( string(addr(ptr)), i + 1 ) = charno( string(addr(ptr)), i )
            %repeat
            charno( string(addr(ptr)),0 ) = actualcount
        %finish

        %result = actualcount
    %end

    %external %integer %function writebuffer( %name ptr, %integer count )
        %integer i
        %integer framep
        %integer %name dvp
        %integer dim, itemsz, intsz
        %integer lb, ub

        itemsz = 1

%if ((DEBUGMODE & dbgio) # 0) %start
debug string("WRITEBUFFER: address(ptr)=".int2ascii(addr(ptr),16,0) ); debug newline
debug string("WRITEBUFFER:  sizeof(ptr)=".int2ascii(sizeof(ptr),16,0) ); debug newline
debug string("WRITEBUFFER:  typeof(ptr)=".int2ascii(typeof(ptr),16,0) ); debug newline
debug string("WRITEBUFFER: count=".itos(count,0) ); debug newline
%finish

        %if (0 <= sizeof( ptr ) <= 255) %start
            ! Ok, it should be a primitive type
            ! We need to adjust itemsz to type size
            ! NB strings/byte arrays have itemsz = 1
            ! So only need to adjust for integer,float or double
            %if (typeof(ptr) = intgr) %then itemsz = 4
            %if (typeof(ptr) = float) %then itemsz = 4
            %if (typeof(ptr) = double) %then itemsz = 8
        %else
            ! Ok,This seems to be an array/record
            ! Get the Base/Frame Pointer
            *mov_ framep,ebp

            ! Now show the expected 3 parameters
%if ((DEBUGMODE & dbgio) # 0) %start
debug string("WRITEBUFFER: [framep +  8]=".itos(integer( framep + 8 ),0) ); debug newline
debug string("WRITEBUFFER: [framep + 12]=".int2ascii(integer( framep + 12 ),16,0) ); debug newline
debug string("WRITEBUFFER: [framep + 16]=".int2ascii(integer( framep + 16 ),16,0) ); debug newline
%finish

            dvp == integer( framep + 16 )
            dim = integer( dvp )
            intsz = sizeof(dim); ! get the size of a 32-bit integer
            ! pick up the element size...
            itemsz = integer( dvp + sizeof(dim)*(2*dim + 1) )

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("WRITEBUFFER: IMPADEF:     dim: dvp[0]='".itos(dim,0)."'"); debugnewline
%finish

            %for i=1,1,dim %cycle
                lb = integer( dvp + sizeof(dim)*(2*i - 1) )
                ub = integer( dvp + sizeof(dim)*(2*i) )

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("WRITEBUFFER: IMPADEF: lb['".itos(i,0)."']: dvp[".itos(2*i-1,0)."]='".itos(lb,0)."'"); debug newline
debugstring("WRITEBUFFER: IMPADEF: ub['".itos(i,0)."']: dvp[".itos(2*i,0)."]='".itos(ub,0)."'");   debug newline
%finish
            %repeat
%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("WRITEBUFFER: IMPADEF:      sz: dvp[".itos((2*dim)+ 1,0)."]='".itos(itemsz,0)."'"); debug newline
debugstring("WRITEBUFFER: IMPADEF:   intsz:   ='".itos(sizeof(dim),0)."'"); debug newline
%finish

        %finish

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdout)
        %signal 9, 9 %unless (0 < out_currentstream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        ! We actually load the buffer as an array of bytes
        ! We need the stream handle, count of items space, item size, buffer address
        ! Where, count * itemsz = size in bytes of buffer storage
        %result = writebytes( out_streams( out_current stream )_handle, count, itemsz, byteinteger( addr(ptr) ) )
    %end

    %external %integer %function input stream

        %if need to initialise %then initialise io

        %result = in_current stream
    %end

    %external %integer %function output stream

        %if need to initialise %then initialise io

        %result = out_current stream
    %end

    %external %routine reset input

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdin)
        %signal 9, 9 %unless (0 < in_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        file rewind( in_streams(in_currentstream)_handle )
    %end

    %external %routine reset output

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdout)
        %signal 9, 9 %unless (0 < out_currentstream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        file rewind( out_streams(out_currentstream)_handle )
    %end

    %external %routine seek input( %integer displacement, pos )

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdin)
        %signal 9, 9 %unless (0 < in_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        %if (0 <= pos <= 2) %then file seek( in_streams( in_current stream)_handle, displacement, pos )
    %end

    %external %routine seek output( %integer displacement, pos )

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdout)
        %signal 9, 9 %unless (0 < out_currentstream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        %if (0 <= pos <= 2) %then file seek( out_streams( out_current stream)_handle, displacement, pos )
    %end

    %external %integer %function tell input

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdin)
        %signal 9, 9 %unless (0 < in_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        %result = tell( in_streams( in_current stream )_handle )
    %end

    %external %integer %function tell output

        %if need to initialise %then initialise io

        ! can't select an invalid stream id (not stdout)
        %signal 9, 9 %unless (0 < out_currentstream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        %result = tell( out_streams( out_current stream )_handle )
    %end

    %external %string(255) %function input name
        %string(255) name

        %if need to initialise %then initialise io

        ! can't select an invalid stream id
        %signal 9, 9 %unless (0 <= in_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        name = in_streams( in_current stream )_file name

        %result = name
    %end

    %external %string(255) %function output name
        %if need to initialise %then initialise io

        ! can't select an invalid stream id
        %signal 9, 9 %unless (0 <= out_current stream <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        %result = out_streams( out_current stream )_file name
    %end

    %external %routine select input( %integer stream id )
        %if need to initialise %then initialise io

        ! can't select an invalid stream id
        %signal 9, 9 %unless (0 <= stream id <= MAXSTREAM)
        ! can't select a closed file
        %signal 9, 4, stream id %unless (in_streams( stream id )_handle # 0)

        in_current stream = stream id;
    %end

    %external %routine select output( %integer stream id )
        %if need to initialise %then initialise io

        ! can't select an invalid stream id
        %signal 9, 9 %unless (0 <= stream id <= MAXSTREAM)

        ! can't select a closed file
        %signal 9, 5, stream id %unless (out_streams( stream id )_handle # 0)

        out_current stream = stream id;
    %end

    %external %routine close input
        %if need to initialise %then initialise io

        ! can't close terminal input
        ! can't close an already closed file
        %if (0 < in_current stream <= MAXSTREAM ) %and (in_streams( in_current stream )_handle # 0) %start
            close( in_streams( in_current stream )_handle )
            initialise stream( in_streams( in_current stream ) )
        %finish
    %end

    %external %routine close output
        %if need to initialise %then initialise io

        ! can't close terminal output
        ! can't close an already closed file
        %if (0 < out_current stream <= MAXSTREAM ) %and (out_streams( out_current stream )_handle # 0) %start
            close( out_streams( out_current stream )_handle )
            initialise stream( out_streams( out_current stream ) )
        %finish
    %end

    %external %routine open input( %integer stream  id, %string(255) file name )
        %integer handle
        %integer flags = IS INPUT ! IS TEXT
        %string(4) mode = "r"
        %string(255) xxx
        %string(4) yyy

        xxx = filename
        yyy = mode

        ! Tweak xxx,yyy to be C strings
        ! Why? because we are sending them to a C function expecting C strings
        imptocstring( xxx )
        imptocstring( yyy )

        %if need to initialise %then initialise io

        ! Error out if streamid not in legal range
        %signal 9, 9, stream id %unless (0 < stream id <= MAXSTREAM )

        ! If file not open
        %if (in_streams( stream id )_handle = 0) %start
            handle = openfile( addr(yyy), addr(xxx) )

            %if (handle = 0) %start

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
debugnewline
%finish
                %signal 9, 2, get error
            %else

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
debugnewline
%finish
                in_streams( stream id )_handle = handle
                in_streams( stream id )_file name = file name
                in_streams( stream id )_flags = flags
            %finish
        %finish
    %end

    %external %routine open binary input( %integer stream  id, %string(255) file name )
        %integer handle
        %integer flags = IS INPUT ! IS BINARY
        %string(4) mode = "rb"
        %string(255) xxx
        %string(4) yyy

        xxx = filename
        yyy = mode

        ! Tweak xxx,yyy to be C strings
        ! Why? because we are sending them to a C function expecting C strings
        imptocstring( xxx )
        imptocstring( yyy )

        %if need to initialise %then initialise io

        %signal 9, 9, stream id %unless (0 < stream id <= MAXSTREAM )

        ! If file not open
        %if (in_streams( stream id )_handle = 0) %start
            handle = openfile( addr(yyy), addr(xxx) )

            %if (handle = 0) %start

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENBINARYINPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
debugnewline
%finish
                %signal 9, 2, get error
            %else

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENBINARYINPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
debugnewline
%finish
                in_streams( stream id )_handle = handle
                in_streams( stream id )_file name = file name
                in_streams( stream id )_flags = flags
            %finish
        %finish
    %end

    %external %routine open output( %integer stream  id, %string(255) file name )
        %integer handle
        %integer flags = IS OUTPUT ! IS TEXT
        %string(4) mode = "w"
        %string(255) xxx
        %string(4) yyy

        xxx = filename
        yyy = mode

        ! Tweak xxx,yyy to be C strings
        ! Why? because we are sending them to a C function expecting C strings
        imptocstring( xxx )
        imptocstring( yyy )

        %if need to initialise %then initialise io

        ! Error out if streamid not in legal range
        %signal 9, 9, stream id %unless (0 < stream id <= MAXSTREAM )

        ! If file not open
        %if (out_streams( stream id )_handle = 0) %start
            handle = openfile( addr(yyy), addr(xxx) )

            %if (handle = 0) %start

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
debugnewline
%finish
                %signal 9, 2, get error
            %else

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
debugnewline
%finish
                out_streams( stream id )_handle = handle
                out_streams( stream id )_file name = file name
                out_streams( stream id )_flags = flags
            %finish
        %finish
    %end

    %external %routine open binary output( %integer stream  id, %string(255) file name )
        %integer handle
        %integer flags = IS OUTPUT ! IS BINARY
        %string(4) mode = "wb"
        %string(255) xxx
        %string(4) yyy

        xxx = filename
        yyy = mode

        ! Tweak xxx,yyy to be C strings
        ! Why? because we are sending them to a C function expecting C strings
        imptocstring( xxx )
        imptocstring( yyy )

        %if need to initialise %then initialise io
        %signal 9, 9, stream id %unless (0 < stream id <= MAXSTREAM )

        ! If file not open
        %if (out_streams( stream id )_handle = 0) %start
            handle = openfile( addr(yyy), addr(xxx) )

            %if (handle = 0) %start

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENBINARYOUTPUT: filename='".filename."' was unable to open for stream(".itos(stream id,0).")")
debugnewline
%finish
                %signal 9, 2, get error
            %else

%if ((DEBUGMODE & dbgio) # 0) %start
debugstring("OPENBINARYOUTPUT: filename='".filename."' now open for stream(".itos(stream id,0).")")
debugnewline
%finish
                out_streams( stream id )_handle = handle
                out_streams( stream id )_file name = file name
                out_streams( stream id )_flags = flags
            %finish
        %finish
    %end

    %external %routine flush output

        %if need to initialise %then initialise io
        ! only interrogate actual opened files (including stdout)
        %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAXSTREAM )
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        flush( out_streams( out_current stream )_handle )
    %end

    %own %string(31) prompt = "prompt ->"
    %own %integer tty needs a prompt = 1

    %external %routine set prompt( %string(31) s )
        prompt = s
    %end

    %external %integer %function next symbol
        %integer ch
        %integer i

        %if need to initialise %then initialise io
        %signal 9, 9, in_current stream %unless (0 <= in_current stream <= MAXSTREAM )
        %signal 9, 4, in_current stream %unless (in_streams( in_current stream )_handle # 0)

        ! Check to see if we already have a lookahead char (actually integer)
        %if (in_streams( in_current stream )_lookahead < 0) %start
            %if (in_current stream = 0) %start
                %if (tty needs a prompt # 0) %start
                    tty needs a prompt = 0;

                    %for i = 1,1,length( prompt ) %cycle
                        put char( error stream_handle, charno( prompt, i ) )
                    %repeat

                %finish
            %finish

            ch = get char ( in_streams( in_current stream )_handle )
            ! remember ch for future use
            in_streams( in_current stream )_lookahead = ch

            ! NL => we should prompt next time
            %if (in_current stream = 0) %and (ch = nl) %then tty needs a prompt = 1;
        %finish
        
        %result = in_streams( in_current stream )_lookahead
    %end

    %external %routine read symbol( %integer %name s )
        %if need to initialise %then initialise io

        s = next symbol
        in_streams( in_current stream )_lookahead = -1
    %end

    %external %routine print symbol( %integer c )
        %if need to initialise %then initialise io

        %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAXSTREAM )
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        ! Not sure what the official IMP behaviour is for output on a closed file.
        ! We choose to silently ignore it...
        ! check file open before writing?
        %if (out_streams( out_current stream )_handle # 0) %then put char( out_streams( out_current stream )_handle, c)
    %end

    %external %routine print real( %long %real d )
        %if need to initialise %then initialise io

        %signal 9, 9, out_current stream %unless (0 <= out_current stream <= MAXSTREAM )
        %signal 9, 5, out_current stream %unless (out_streams( out_current stream )_handle # 0)

        ! Not sure what the official IMP behaviour is for output on a closed file.
        ! We choose to silently ignore it...
        ! check file open before writing?
        %if (out_streams( out_current stream )_handle # 0) %then put double( out_streams( out_current stream )_handle, d)
    %end

    %routine parse list( %string(255) list, %integer direction)
        %string(255) x,a,c,mode,file
        %integer streamid

        x = list
        streamid = 1
        %while length(x) > 0 %cycle

            %exit %unless (streamid <= get max stream)

            ! split the comma separated list
            length(a) = 0
            length(c) = 0
            x->a.(",").c

            %exit %unless length(a) > 0

            file = a
            length(mode) = 0
            %if (charno(a,length(a)) = 'b') %and (charno(a,length(a) - 1 ) = ':') %start
                length(file) = length(file) - 2
                mode = ":b"
            %finish

            %exit %unless length( file ) > 0

            %if length(mode) = 0 %start
                %if (direction = FILE IN) %then open input( streamid, file )
                %if (direction = FILE OUT) %then open output( streamid, file )
            %finish %else %start
                %if (direction = FILE IN) %then open binary input( streamid, file )
                %if (direction = FILE OUT) %then open binary output( streamid, file )
            %finish
                
            x = c
            streamid = streamid + 1
        %repeat
    %end

    %external %integer %function split io list ( %string(255) io list )
        %string(255) s,a,b,c

        s = io list
        length(a) = 0
        b = tostring(FILE SEP)
        length(c) = 0

        s -> a.(b).c

        %if length( a ) > 0 %then parse list( a, FILE IN )
        %if length( c ) > 0 %then parse list( c, FILE OUT )

        %result = 0
    %end

%endoffile
