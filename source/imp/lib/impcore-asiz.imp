{-----------------------------------------------------------------------------}
    ! Given a dope vector calculate the array size (in bytes)
    ! We do this by calculating the number of array elements then
    ! scaling that by the individual element size (in bytes).
    !
    ! The tuple (dvp,address) represents the %name value for an array.
    ! dvp, address are pointers to the dopevector and array data.
    ! This function only works when invoked with an array 'name' is
    ! passed as a parameter.
    ! Use the routine as follows: X = impasiz( A )
    ! where X is an integer, A is an array
    !
    ! Memory layout of an array's dope vector
    !  Low                              High
    !  dvp
    !  |
    !  v
    !  dim=n:lb1:ub1:lb2:ub2:...lbn:ubn:size
    !
    ! call/spec this function as
    ! %external %integer %fn %spec arraysize %alias "_IMPASIZ" ( %name dvp )
    ! N.B. the %name parameter on the stack is actually:
    ! two integers dvp,address

    ! actual implementation as 2 integer parameters
    %external %integer %function impasiz ( %integer dvp,address )
        %constinteger address size = 4
        %integer dim, sz, entries
        %integer lb, ub
        %integer i,lbaddress,ubaddress

        ! obtain the dimensions of the array
        dim = integer( dvp )
        ! next obtain the addresses of the lower and upper bounds
        ! of the first dimension
        lbaddress = dvp + address size
        ubaddress = lbaddress + address size
        ! An array will have at minimum, one element
        entries  = 1

        ! code to iterate over the dimension ranges to calculate the
        ! number of array entries then scale by the size of each entry.
        %for i=1,1,dim %cycle
            ! General case iterates from first dimension
            ! at i=1, point to the leftmost lower bound
            lb = integer( lbaddress )

            ! at i=1, point to the leftmost upper bound
            ub = integer( ubaddress )

            ! we declare array bounds so that lb <= ub
            %signal 5, 3, i %unless lb <= ub
            ! Accumulate size of objects in a row
            ! Allowing for fence-post errors
            ! the number of entries for dimension i is:
            ! (ub - lb) + 1
            ! scale up the entries count so far
            entries = entries * ((ub - lb) + 1)

            ! now point to the next dimensions lb,ub values
            ! evaluate next lower bound index
            lbaddress = ubaddress + address size

            ! evaluate next upper bound index
            ubaddress = lbaddress + address size
        %repeat

        ! we've reached just past the range bound pairs
        ! so get the array element size (via the lb address)
        sz = integer( lbaddress )

        %result = entries * sz
    %end

{-----------------------------------------------------------------------------}
%endoffile
