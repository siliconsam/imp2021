
    %include "inc.386.registers"

{------------------------------------------------------------------------------}
    ! Array Reference function.

    ! Array indices are pushed left to right so we get them right to left.
    ! The last thing pushed (our first C parameter) is a pointer to the Dope Vector.
    ! Dope vectors are integer arrays of form :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ObjectSize:
    ! We need to fiddle with addresses because this function has a variable parameter count.
    ! This parameter count depends on the number of dimensions in the array
    ! The parameters are stacked for use by a C routine (but this is IMP!)
    ! However, this is an IMP routine so need to access in reverse order
    ! Even worse, there are a variable number of index values (One index value for each array index)
    ! We pretend there are no stacked parameters in the function declaration
    ! Fortunately the "last" IMP parameter (the dope vector) (but 1st C parameter) indicates
    ! the expected parameter count.
    ! We actually access parameters via the "ebp" register (=Base/Frame pointer)
    ! Remember [ebp]   = framep
    !          [ebp+4] = return address
    !          [ebp+8] = 1st C parameter = dope vector address
    !          [ebp+12] = last array index = dim'th index value
    !          [ebp+8+dim*4] = 1st array index = 1st index value (assuming 4 byte = 1 integer)
    ! The function result is the offset that needs to be added to the
    ! notional A(0,0,0) address to get the variable in the array
    !
    ! C declaration
    ! extern int imparef(int *dvp, int idim, ...,int i1 )
    !
    ! IMP declaration (C parameter order reversed to give IMP order)
    ! %external %integer %function imparef(%integer i1 { .. idim} , %integer %name dvp )
    !
    ! Arrgggh! Even worse, this function has a variable number of parameters (illegal IMP)
    ! Hence, the above mentioned contortions to deal with a variable count of parameters
    ! Fortunately, the "last" parameter stacked (the dopevector address) gives a clue as to
    ! the actual count of parameters.
    ! Luckily, the IMP compiler "pops" the set of parameters on return from this routine call
    ! Thus we can "pretend" this routine is declared with no parameters, however we need to
    ! use a bit of embedded machine code to access the real parameters via the frame pointer

    %external %integer %function imparef

        %integer framep
        %integer %name dvp
        %integer dim, sz
        %integer lb, ub
        %integer index
        %integer row, result
        %integer i
        %constant %integer wordsize = 4;        ! wordsize in bytes of integer/address
        %constant %integer param1 = 2*wordsize; ! frame pointer offset (in bytes) of "last" parameter on stack
                                                ! e.g. dopevector address
        %constant %integer param2 = 3*wordsize; ! frame pointer offset (in bytes) of "last" array index

        ! Get the Base/Frame Pointer
        *mov_ framep,ebp

        ! IMP does NOT allow routines with a variable number of parameters
        ! but we need 
        ! parameter        1) dope vector address
        ! parameter 2..dim+1) array index values (dim = array dimensionality)

        ! Now get various data items from the dope vector
        ! The "last" parameter stacked is the pointer to dope vector
        ! Get the dope vector address ("last" C parameter/"first" IMP parameter)
        dvp == integer( integer( framep + param1 ) )
        ! Now get the array dimensionality from the dope vector
        dim = dvp
        ! Now get the size of each array element
        sz = integer( addr(dvp) + wordsize*(2*dim + 1) )

        ! For a general number of dimensions, 1 or more, we do this the hard way...
        result = 0;        ! result so far
        %for i=0,1,dim - 1 %cycle

            ! General case iterates backwards toward first dimension
            lb = integer( addr(dvp) + wordsize*(2*(dim - i) - 1));  ! at i=0, point to the rightmost lower bound
            ub = integer( addr(dvp) + wordsize*(2*(dim - i)    ));  ! at i=0, point to the rightmost upper bound

            ! Get the index: at i=0, point to the rightmost array index
            index = integer( framep + param2 + wordsize*i )

            ! Check the index
            %signal 6, 2, index %unless (lb <= index) %and (index <= ub); ! check to see if index in range lb:ub

            row   = (ub - lb) + 1;         ! Number of objects in a row
            result = (result * row) + index; ! accumulate this index
        %repeat

        %result = result * sz; ! multiply by element size
    %end

{------------------------------------------------------------------------------}
%endoffile
