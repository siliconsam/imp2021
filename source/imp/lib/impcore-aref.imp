
    %include "inc.386.registers"

{-----------------------------------------------------------------------------}
    ! Array Reference function.

    ! Array indices are pushed left to right so we get them right to left.
    ! The last thing pushed (our first C parameter) is a 
    ! pointer to the Dope Vector.
    !
    ! Dope vectors are integer arrays of form
    !      :DIM:LB1:UB1:LB2:UB2:etc:LBn:UBn:ArrayElementSize:
    !      increasing address -->
    !
    ! We need to fiddle with addresses because this function has a 
    ! variable parameter count.
    !
    ! This parameter count depends on the number of dimensions in the array
    ! The parameters are stacked for use by a C routine (but this is IMP!)
    ! However, this is an IMP routine so need to access in reverse order
    ! Even worse, there are a variable number of index values
    !    (One index value for each array index)
    ! We pretend there are no stacked parameters in the function declaration
    ! Fortunately the "last" IMP parameter (the dope vector)
    !     (but 1st C parameter) indicates the expected parameter count.
    ! We actually access parameters via the "ebp" register
    !                                      (=Base/Frame pointer)
    ! Now assuming 4 byte = 1 integer
    ! Remember [ebp]   = framep
    !          [ebp+4] = return address
    !          [ebp+8] = 1st C parameter = dope vector address
    !          [ebp+12] = last array index = dim'th index value
    !          [ebp+8+dim*4] = 1st array index = 1st index value
    ! The function result is the offset that needs to be added to the
    ! notional A(0,0,0) address to get the variable in the array
    !
    ! C declaration
    ! extern int imparef(int *dvp, int idim, ...,int i1 )
    !
    ! IMP declaration (C parameter order reversed to give IMP order)
    ! %external %integer %function imparef(%integer i1 {.. idim},
    !                                      %integer %name dvp)
    !
    ! Arrgggh! Even worse, this function has a variable number of parameters
    ! (which is illegal in IMP)
    !
    ! Hence, the above mentioned contortions to deal with a variable count
    ! of parameters.
    ! Fortunately, the "last" parameter stacked (the dopevector address)
    ! gives a clue as to the actual count of parameters.
    !
    ! Luckily, the IMP compiler "pops" the set of parameters on return from
    ! this routine call. Thus we can "pretend" this routine is declared with
    ! no parameters, however we need to use a bit of embedded machine code
    ! to access the real parameters via the frame pointer

    %external %integer %function imparef

        ! wordsize in bytes of integer/address
        %constant %integer addressSize = 4

        %integer framep
        %integer %name dvp
        %integer dvpParameterAddress, indexAddress
        %integer szAddress, lbAddress, ubAddress
        %integer dim, sz, lb, ub, index
        %integer row, result
        %integer i

        ! Get the Base/Frame Pointer
        *mov_ framep,ebp

        ! IMP does NOT allow routines with a variable number of parameters
        ! but we need 
        ! parameter         1) dope vector address
        ! parameters 2..dim+1) array index values (dim = array dimensionality)

        ! Now get various data items from the dope vector
        ! The "last" parameter stacked is the pointer to dope vector
        ! Get the dope vector address
        !     ("last" C parameter/"first" IMP parameter)
        ! skip over the 'old' FramePointer and the routine's ReturnAddress
        ! on the stack
        dvpParameterAddress = framep + 2*addressSize
        dvp == integer( integer( dvpParameterAddress ) )

        ! get the address of the last array index
        ! remember the index values are stacked in reverse order
        ! The last shall be first!!!
        indexAddress = dvpParameterAddress + addressSize

        ! Now get the array dimensionality from the dope vector
        dim = dvp

        ! Now get the address of the size of each array element
        szAddress = addr(dvp) + addressSize*(2*dim + 1)

        ! get the address of the last upper bound
        ! placed just before the location of the array element size
        ubAddress = szAddress - addressSize
        ! and the address of it's associated lower bound
        lbAddress = ubAddress - addressSize

        ! General case iterates backwards toward first dimension
        ! For a general number of dimensions, 1 or more
        ! we do this the hard way...
        result = 0;        ! result so far
        ! at i=1, we start with the rightmost bounds
        ! their addresses have been 
        %for i=1,1,dim %cycle

            lb = integer( lbAddress )
            ub = integer( ubAddress )

            ! Get the index: at i=0, point to the rightmost array index
            index = integer( indexAddress )

            ! Check the index
            ! check to see if index in range lb:ub
            %signal 6, 2, index %unless (lb <= index) %and (index <= ub)

            row   = (ub - lb) + 1;         ! Number of objects in a row
            result = (result * row) + index; ! accumulate this index

            ! update the lb,ub,index addresses
            ! get the previous upper bound address
            ubAddress = lbAddress - addressSize
            ! get it's associated lower bound address
            lbAddress = ubAddress - addressSize
            ! hop to the next lower index address
            ! NB the index values are in reverse order
            indexAddress = indexAddress + addressSize
        %repeat

        ! finally get the array element size
        sz = integer( szAddress )

        %result = result * sz; ! multiply by element size
    %end

{-----------------------------------------------------------------------------}
%endoffile
